<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nathan naveen</title><link>https://nathannaveen.dev/</link><description>Recent content on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Wed, 10 Nov 2021 09:57:49 -0600</lastBuildDate><atom:link href="https://nathannaveen.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 543</title><link>https://nathannaveen.dev/posts/leetcode-543/</link><pubDate>Wed, 10 Nov 2021 09:57:49 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-543/</guid><description>I feel that enough people have explained the first type of solution, so I will not explain this.
Most People Do This:
var maximum = 0 func diameterOfBinaryTree(root *TreeNode) int { maximum = 0 helper(root) return maximum } func helper(root *TreeNode) int { if root == nil { return 0 } leftHeight, rightHeight := helper(root.Left), helper(root.Right) maximum = max(leftHeight + rightHeight, maximum) return 1 + max(leftHeight, rightHeight) } func max(a, b int) int { if a &amp;gt; b { return a } return b } The Second Solution Explanation:</description></item><item><title>Leetcode 1807</title><link>https://nathannaveen.dev/posts/leetcode-1807/</link><pubDate>Thu, 28 Oct 2021 15:59:20 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1807/</guid><description>1807. Evaluate the Bracket Pairs of a String
The idea of this solution is pretty simple:
We can first add all the knowledge into a map which I called storedKnowledge Then we can loop through s If s[i] == '(' we can make start = i + 1, so we know where the bracket starts Else if s[i] == ')' we can check whether storedKnowledge contains s[start : i] (For our non-Golang users s[start : i] is basically getting the substring from position start to the position i, if we think mathematically it could be shown as the inequality [start, i)), if it contains we can add the value to res, else add &amp;quot;?</description></item><item><title>Leetcode 1991</title><link>https://nathannaveen.dev/posts/leetcode-1991/</link><pubDate>Thu, 28 Oct 2021 15:59:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1991/</guid><description>1991. Find the Middle Index in Array
The idea of this solution is pretty simple:
We find the sum of all the numbers in nums (In this solution, I am calling it sum) Then we check whether sum - left - nums[i] == left (I will get back to what left is and what this whole thing means in the following parts). If so, we can return i (The index).</description></item><item><title>Leetcode 1984</title><link>https://nathannaveen.dev/posts/leetcode-1984/</link><pubDate>Thu, 28 Oct 2021 15:59:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1984/</guid><description>1984. Minimum Difference Between Highest and Lowest of K Scores
The idea of this solution is pretty simple:
We just sort nums And then we can use a sliding window to check for the min of the last number in the sub-array minus the first number in the sub-array. The reason we sort nums is the minimum distance will always be between the two closest numbers. For example if we have the array nums = [1, 2, 3, 4, 6, 10], and we had k = 3, we can see that the differences would be:</description></item><item><title>Leetcode 598</title><link>https://nathannaveen.dev/posts/leetcode-598/</link><pubDate>Thu, 28 Oct 2021 15:59:00 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-598/</guid><description>598. Range Addition II
The idea of this solution is pretty simple, the positions with the max value will be in the sub-matrix of range 0 to minimum y pos, and 0 to minimum x pos.
If you don&amp;rsquo;t understand look at the example bellow:
input: m = 6, n = 5, ops = [[4, 3], [2, 6], [3, 5]] (Note: They give the input 1-indexed, instead of 0-indexed)
As you can see, all rectangles top left corner is (0, 0) (I added an orange dot at (0, 0)).</description></item><item><title>Leetcode 2006</title><link>https://nathannaveen.dev/posts/leetcode-2006/</link><pubDate>Thu, 28 Oct 2021 15:58:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2006/</guid><description>2006. Count Number of Pairs With Absolute Difference K
The main idea of this solution is nums[i] + k = nums[j] and nums[i] - k = nums[j], if you don&amp;rsquo;t understand:
|nums[i] - nums[j| = k
Now if we took off the absolute value sign we get 2 equations:
-(nums[i] - nums[j]) = k and nums[i] - nums[j] = k
Let us start with -(nums[i] - nums[j]) = k:
-(nums[i] - nums[j]) = k Mulitply both sides by -1 so nums[i] - nums[j] = -k add k to both sides, and add nums[j] to both sides nums[i] + k = nums[j] Now we can do nums[i] - nums[j] = k:</description></item><item><title>Leetcode 2016</title><link>https://nathannaveen.dev/posts/leetcode-2016/</link><pubDate>Thu, 28 Oct 2021 15:58:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2016/</guid><description>2016. Maximum Difference Between Increasing Elements
The idea of this solution is we loop through nums, and if a number is greater than min we can check whether to make it max, otherwise if the number is smaller than min we can re-make min.
func maximumDifference(nums []int) int { min := nums[0] max := -1 for i := 0; i &amp;lt; len(nums); i++ { if nums[i] &amp;gt; min &amp;amp;&amp;amp; nums[i] - min &amp;gt; max { max = nums[i] - min } else if nums[i] &amp;lt; min { min = nums[i] } } return max }</description></item><item><title>Leetcode 1257</title><link>https://nathannaveen.dev/posts/leetcode-1257/</link><pubDate>Thu, 28 Oct 2021 15:58:40 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1257/</guid><description>1257. Smallest Common Region
A quick idea of this solution is (Note: This solution is not very good if you want a solution that is easy to understand, look after this):
To use a map to store every region as the key and the value as the region in which the original region is contained. Then loop through all the regions in the food chain of region1 (I am calling a food chain whenever we start with region1, and then find the region that contains it) and store all the values into another map.</description></item><item><title>Leetcode 2027</title><link>https://nathannaveen.dev/posts/leetcode-2027/</link><pubDate>Thu, 28 Oct 2021 15:58:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2027/</guid><description>2027. Minimum Moves to Convert String
The idea of this solution is if we are on a 'X' we can move the index up by three and add one to res.
An example could be:
input: s = &amp;quot;XXOXXXOOOXOXOXX&amp;quot; (I tried to capture as many edge cases as I could in this test case)
We can start with our index i = 0
s[i] == 'X', so we can skip the next two values (Skip the values at indexes 1 and 2 because according to the problem we have made s[0] = 'O', s[1] = 'O', s[2] = 'O'.</description></item><item><title>Leetcode 2028</title><link>https://nathannaveen.dev/posts/leetcode-2028/</link><pubDate>Thu, 28 Oct 2021 15:58:20 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2028/</guid><description>2028. Find Missing Observations
This solution aims to find the missing sum and then distribute it among n values.
The idea of the first part (Finding the missing sum) is first to find the sum of the m numbers given to us in rolls.
Then since the mean will always be mean = sum / (n + m) (the sum of elements divided by the number of elements), we know that the number of elements will always be n + m.</description></item><item><title>Leetcode 200</title><link>https://nathannaveen.dev/posts/leetcode-200/</link><pubDate>Thu, 28 Oct 2021 15:58:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-200/</guid><description>200. Number of Islands
The idea of this solution can be portrayed in its most basic idea by the following image:
var doneAlready = make(map[[2]int] bool) func numIslands(grid [][]byte) int { res := 0 doneAlready = make(map[[2]int] bool) for i := 0; i &amp;lt; len(grid); i++ { for j := 0; j &amp;lt; len(grid[0]); j++ { if helper(grid, i, j) { res++ } } } return res } func helper(grid [][]byte, i, j int) bool { temp := [2]int{i, j} if i &amp;lt; 0 || i &amp;gt;= len(grid) || j &amp;lt; 0 || j &amp;gt;= len(grid[0]) || doneAlready[temp] || grid[i][j] == &amp;#39;0&amp;#39; { return false } doneAlready[temp] = true helper(grid, i - 1, j) helper(grid, i + 1, j) helper(grid, i, j - 1) helper(grid, i, j + 1) return true } This is a variation of my Max Area of Island solution:</description></item><item><title>Leetcode 1428</title><link>https://nathannaveen.dev/posts/leetcode-1428/</link><pubDate>Thu, 28 Oct 2021 15:58:02 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1428/</guid><description>1428. Leftmost Column with at Least a One
This solution uses the fact that all rows are sorted. So, all the ones in every row will be at the end.
Basically, to not call binaryMatrix.Get(i, j) too many times. We can&amp;rsquo;t loop through all values of the matrix.
Since 1 &amp;lt;= rows, cols &amp;lt;= 100 the max number of elements in the matrix is 100 * 100, 10000. And the problem says that the max number of calls to binaryMatrix.</description></item><item><title>Leetcode 684</title><link>https://nathannaveen.dev/posts/leetcode-684/</link><pubDate>Thu, 28 Oct 2021 15:57:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-684/</guid><description>684. Redundant Connection
The idea of this solution is to use union find to connect all the edges together, then in the Union() function if edge[0] parent equals edge[1] parent we have a redundant connection.
Note that I modified the average union find for this problem.
type unionFind struct { parent []int n int } func (this *unionFind) Find(x int) int { if x != this.parent[x] { this.parent[x] = this.Find(this.parent[x]) return this.</description></item><item><title>Leetcode 2046</title><link>https://nathannaveen.dev/posts/leetcode-2046/</link><pubDate>Thu, 28 Oct 2021 15:57:20 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2046/</guid><description>2046. Sort Linked List Already Sorted Using Absolute Values
The idea of this solution is to check whether the current value is smaller than 0. If so, we can remove it from its current position, add it to the beginning of the list, and make that the new beginning.
This solution works because the absolute value of -1 will always be smaller than the absolute value of -5, but -1 is greater than -5.</description></item><item><title>Leetcode 319</title><link>https://nathannaveen.dev/posts/leetcode-319/</link><pubDate>Thu, 28 Oct 2021 15:56:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-319/</guid><description>319. Bulb Switcher
Note: If you don&amp;rsquo;t understand this problem, think of it as something similar to Seive of Eratosthenes.
At first I didn&amp;rsquo;t understand how to go about this problem, so I drew it out. I made a graph that might be easier to understand than my drawing:
In this graph the numbers represent what round we are on (Y-axis = what round we are on). And the bulbs represent each bulb (X-axis = what bulb we are on).</description></item><item><title>Leetcode 1804</title><link>https://nathannaveen.dev/posts/leetcode-1804/</link><pubDate>Tue, 17 Aug 2021 12:33:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1804/</guid><description>1804. Implement Trie II (Prefix Tree)
The idea of this solution can be shown using the following image:
type Node struct { m map[rune] *Node isEndCounter int starts int } type Trie struct { node *Node } func Constructor() Trie { return Trie{node: &amp;amp;Node{make(map[rune] *Node), 0, 0}} } func (this *Trie) Insert(word string) { root := this.node root.starts++ for _, s := range word { if root.m[s] == nil { root.</description></item><item><title>Leetcode 1903</title><link>https://nathannaveen.dev/posts/leetcode-1903/</link><pubDate>Tue, 17 Aug 2021 12:31:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1903/</guid><description>1903. Largest Odd Number in String
The idea of this solution is pretty simple, we find the last odd digit, and the number from the beginning of num to that odd digit is the greatest odd number we can get.
If you don&amp;rsquo;t understand, think &amp;ldquo;what makes an odd number?&amp;quot; An odd number is a number with its last digit being odd (The last digit can be 1, 3, 5, 7, or 9).</description></item><item><title>Leetcode 1936</title><link>https://nathannaveen.dev/posts/leetcode-1936/</link><pubDate>Tue, 17 Aug 2021 12:31:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1936/</guid><description>1936. Add Minimum Number of Rungs
func addRungs(rungs []int, dist int) int { prev := 0 res := 0 for i := 0; i &amp;lt; len(rungs); i++ { rung := rungs[i] res += (rung - prev - 1) / dist prev = rung } return res } The idea of both of these solution are pretty much the same except for this solution we pre-pend 0 to the rungs instead of having prev.</description></item><item><title>Leetcode 1945</title><link>https://nathannaveen.dev/posts/leetcode-1945/</link><pubDate>Tue, 17 Aug 2021 12:31:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1945/</guid><description>1945. Sum of Digits of String After Convert
The Mathematical Solution:
The idea of this solution uses the fact that k will always be 1 &amp;lt;= k &amp;lt;= 10. Since k will always be greater than 1 we can add the first transformation and conversion together, so we don&amp;rsquo;t add numbers that are greater than 9 to the result.
For an example let us use:
input: s = &amp;quot;hvmhoasabayzzzzzd&amp;quot;, k = 1</description></item><item><title>Leetcode 1954</title><link>https://nathannaveen.dev/posts/leetcode-1954/</link><pubDate>Tue, 17 Aug 2021 12:31:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1954/</guid><description>1954. Minimum Garden Perimeter to Collect Enough Apples
For this solution, I will try to explain it with an image.
I have drawn a picture to explain how this solution works. I have drawn a 2 x 2 and a 4 x 4 square. I will explain the reason for this later. And I have given each position a letter instead of coordinate so I can give a map with each letter and coordinate.</description></item><item><title>Leetcode 1910</title><link>https://nathannaveen.dev/posts/leetcode-1910/</link><pubDate>Tue, 17 Aug 2021 12:31:06 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1910/</guid><description>1910. Remove All Occurrences of a Substring
Solution One: (Iterative)
The idea of this solution is pretty simple:
We can loop through s using a counter i Then we check whether s[i : i + len(part)] == part (Is the part of s from i to i + len(part) equal to part). If so, we can re-make s without that part We can also move back the counter (i) by the length of part, so we can see whether removing the part from s makes another part.</description></item><item><title>Leetcode 1893</title><link>https://nathannaveen.dev/posts/leetcode-1893/</link><pubDate>Tue, 17 Aug 2021 12:30:59 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1893/</guid><description>1893. Check if All the Integers in a Range Are Covered
First, a walk-through of the code, and then an explanation.
A Walk Through Of the Solution:
We can sort ranges by the ranges left value (I think of ranges as ranges = [][]int{ []int{left, right} }). Then I loop through ranges and: If the ranges left value is greater than left, we can return false. If the ranges left value is smaller than or equal to left and the ranges right is smaller than right, we can re-make left.</description></item><item><title>Leetcode 1404</title><link>https://nathannaveen.dev/posts/leetcode-1404/</link><pubDate>Tue, 17 Aug 2021 12:30:51 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1404/</guid><description>1404. Number of Steps to Reduce a Number in Binary Representation to One
The idea of this solution is:
When we find a zero at the end of s, we know that s is divisible by 2, so we can remove the end of the string and add one to the result. When we find a 1 at the end of s, we know that s is not divisible by 2, so we can add 1 by keep making all values before the position equal to 0 if they are 1 and 1 if they are 0.</description></item><item><title>Leetcode 302</title><link>https://nathannaveen.dev/posts/leetcode-302/</link><pubDate>Tue, 17 Aug 2021 12:30:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-302/</guid><description>302. Smallest Rectangle Enclosing Black Pixels
Note: I think that the x and y coordinates are wrong in the problem because, in a graph, the axis are:
y ^ | | | +--------&amp;gt; x The idea of the solution can be shown using the following image:
The Code:
type key struct { x int y int } func minArea(image [][]byte, x int, y int) int { stack := []key{ key{ y, x } } minX, maxX := 101, 0 minY, maxY := 101, 0 for len(stack) !</description></item><item><title>Leetcode 582</title><link>https://nathannaveen.dev/posts/leetcode-582/</link><pubDate>Tue, 17 Aug 2021 12:30:39 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-582/</guid><description>582. Kill Process
Both of these solutions operate on the same idea:
We add all the parents and children to a map in the format of map[parent] []children (map of a parent then an array of children) Then we add the kill value to the result and the kills children (From the map), and then the kill&amp;rsquo;s children&amp;rsquo;s children, and so on (kill, kill children, kills children's children). Iterative</description></item><item><title>Leetcode 888</title><link>https://nathannaveen.dev/posts/leetcode-888/</link><pubDate>Tue, 17 Aug 2021 12:30:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-888/</guid><description>888. Fair Candy Swap
The idea of this solution can be shown using the following image:
The Code:
func fairCandySwap(A []int, B []int) []int { alice, bob := 0, 0 m := make(map[int] int) for _, i := range A { alice += i } for _, i := range B { bob += i m[i]++ } temp := (alice - bob) / 2 for _, i := range A { if m[i - temp] &amp;gt;= 1 { return []int{i, i - temp} } } return []int{} }</description></item><item><title>Leetcode 1940</title><link>https://nathannaveen.dev/posts/leetcode-1940/</link><pubDate>Sun, 25 Jul 2021 18:33:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1940/</guid><description>1940. Longest Common Subsequence Between Sorted Arrays
At first, I thought that this would need a nice algorithm, but then when I read the description, it said that
&amp;ldquo;arrays is sorted in strictly increasing order&amp;rdquo;
and
&amp;ldquo;longest common subsequence&amp;rdquo;
The first part, &amp;ldquo;arrays is sorted in strictly increasing order,&amp;rdquo; tells us that each array is sorted and each array has unique numbers.
The second part, &amp;ldquo;longest common subsequence&amp;rdquo; says that it is a subsequence and not a subarray.</description></item><item><title>Leetcode 199</title><link>https://nathannaveen.dev/posts/leetcode-199/</link><pubDate>Sun, 25 Jul 2021 18:33:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-199/</guid><description>199. Binary Tree Right Side View
The idea of both solutions is pretty simple, we just use BFS to iterate through all the rows and append the last element in the row (The right most element).
Iterative:
func rightSideView(root *TreeNode) []int { res := []int{} if root != nil { queue := []*TreeNode{ root } for len(queue) != 0 { n := len(queue) res = append(res, queue[n - 1].Val) for i := 0; i &amp;lt; n; i++ { pop := queue[0] queue = queue[1:] if pop.</description></item><item><title>Leetcode 495</title><link>https://nathannaveen.dev/posts/leetcode-495/</link><pubDate>Sun, 25 Jul 2021 18:33:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-495/</guid><description>495. Teemo Attacking
The idea of these two solutions is pretty simple, but in the second solution, I didn&amp;rsquo;t want to use a variable to store the result, so I manipulated timeSeries into storing the resulting values (Basically used DP).
The First Solution
I first did this solution like this:
func findPoisonedDuration(timeSeries []int, duration int) int { res := 0 for i := 1; i &amp;lt; len(timeSeries); i++ { if timeSeries[i - 1] + duration - 1 &amp;lt; timeSeries[i] { res += duration } else { res += timeSeries[i] - timeSeries[i - 1] } } if len(timeSeries) !</description></item><item><title>Leetcode 50</title><link>https://nathannaveen.dev/posts/leetcode-50/</link><pubDate>Sun, 25 Jul 2021 18:33:06 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-50/</guid><description>50. Pow(x, n)
This solution is if n &amp;lt; 0 (If n is negative) we can return 1 / (x ^ (-n)) (The -n is for making n positive). Otherwise we can just return math.Pow(x, n).
func myPow(x float64, n int) float64 { if n &amp;lt; 0 { return 1 / math.Pow(x, float64(-n)) } return math.Pow(x, float64(n)) } Technically we could do the following code and solve the problem, but that isn&amp;rsquo;t the idea of the problem because Golang takes care of test cases when n is negative.</description></item><item><title>Leetcode 1886</title><link>https://nathannaveen.dev/posts/leetcode-1886/</link><pubDate>Sun, 25 Jul 2021 18:33:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1886/</guid><description>1886. Determine Whether Matrix Can Be Obtained By Rotation
The idea of this solution is to loop through every point in mat and check whether it has been rotated 0, 90, 180, or 270 degrees.
We don&amp;rsquo;t need to check whether mat has been rotated by 0 degrees the way we are doing the rest of the rotations. All we have to do is check whether mat == target.
I am going to explain how we do the rotations using some images.</description></item><item><title>Leetcode 590</title><link>https://nathannaveen.dev/posts/leetcode-590/</link><pubDate>Sun, 25 Jul 2021 18:32:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-590/</guid><description>590. N-ary Tree Postorder Traversal
The First Solution:
This solution seems pretty self-explanatory.
func postorder(root *Node) []int { return helper(root, []int{}) } func helper(r *Node, l []int)[]int{ if r != nil{ for _,item := range r.Children{ l = helper(item,l) } l = append(l,r.Val) } return l } The Second Solution:
If you look at the following code and don&amp;rsquo;t understand, it is probably because of: r.Children[len(r.Children) - i - 1], but if you look at it carefully, you will see that it is the same as reversing r.</description></item><item><title>Leetcode 987</title><link>https://nathannaveen.dev/posts/leetcode-987/</link><pubDate>Sun, 25 Jul 2021 18:32:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-987/</guid><description>987. Vertical Order Traversal of a Binary Tree
I know that this solution is very cumbersome and annoying, so I am just going to explain what the main idea is:
We first use BFS to find every node with its row and column and store those values in an array. Then, we add all the values from the array to a matrix array which stores the nodes value and the row of the node in the position of the column.</description></item><item><title>Leetcode 1559</title><link>https://nathannaveen.dev/posts/leetcode-1559/</link><pubDate>Tue, 06 Jul 2021 18:32:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1559/</guid><description>1559. Detect Cycles in 2D Grid
The idea for this solution is to:
Find a backward L shape in the matrix. (Don&amp;rsquo;t worry if you don&amp;rsquo;t understand I will come back to it later) Then check whether the cycle all starts from one position. (I will also come back to this later) For this solution, I am going to explain how it works using an example:
If you look at the problem, you might see this example already there, I picked this example because we know the answer:</description></item><item><title>Leetcode 759</title><link>https://nathannaveen.dev/posts/leetcode-759/</link><pubDate>Tue, 06 Jul 2021 18:25:36 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-759/</guid><description>759. Employee Free Time
The idea of this solution is pretty simple:
We add everyone&amp;rsquo;s intervals into an array of intervals called arr. Then, we sort arr by their start values. Then when we loop through arr: If the end of the current element is smaller than the following elements start, we know that we have no overlap. Else if, the current elements end value is greater than the following elements start and the next elements end value, we know that the current elements time frame surrounds the following elements time frame.</description></item><item><title>Leetcode 1913</title><link>https://nathannaveen.dev/posts/leetcode-1913/</link><pubDate>Tue, 06 Jul 2021 18:25:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1913/</guid><description>1913. Maximum Product Difference Between Two Pairs
For this solution, we have to get the maximum Product Difference and to do this, we have to subtract the smallest product from the largest product. So in this solution, I decided to sort nums and return the max product minus the min product.
func maxProductDifference(nums []int) int { sort.Ints(nums) return nums[len(nums) - 1] * nums[len(nums) - 2] - nums[0] * nums[1] }</description></item><item><title>Leetcode 817</title><link>https://nathannaveen.dev/posts/leetcode-817/</link><pubDate>Tue, 06 Jul 2021 18:25:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-817/</guid><description>817. Linked List Components
The idea of this solution is:
We make a map to store all the values in nums because all the values in nums are unordered subsets of our linked list, so finding whether nums contains a value is now done in O(1) time (Note that to get all the values into the map it takes O(n) time). Then all we have to do is loop through our linked list and if m (Our map is called m) contains the current value and it doesn&amp;rsquo;t contain the previous value or the value is the head and m contains the value we know that we have another component.</description></item><item><title>Leetcode 933</title><link>https://nathannaveen.dev/posts/leetcode-933/</link><pubDate>Tue, 06 Jul 2021 18:25:16 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-933/</guid><description>933. Number of Recent Calls
For this solution, we have got to look at something that is said in the problem description:
It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.
So using that, we can make a variable (Which I called k) and store the position of the last position of the value that is greater than or equal to t - 3000.</description></item><item><title>Leetcode 61</title><link>https://nathannaveen.dev/posts/leetcode-61/</link><pubDate>Tue, 06 Jul 2021 18:25:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-61/</guid><description>61. Rotate List
The idea of this solution is pretty simple, and I will explain it using this image below:
Note: Before we get into what this picture represents, I want you to know that we already know the length of the linked list because the first loop in the code is for finding the length.
The image above is from the problem description and is showing the input and output as: Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3]</description></item><item><title>Leetcode 504</title><link>https://nathannaveen.dev/posts/leetcode-504/</link><pubDate>Tue, 06 Jul 2021 18:25:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-504/</guid><description>504. Base 7
The main idea of both solutions is to convert the number to base seven. To convert a number to base 7 we can do something similar to converting to base 2, 3, 4 and so on. So if you know how to convert a number to another base you can just scroll down to the code and skip the example image.
Using Math, and then returning string(res):</description></item><item><title>Leetcode 1669</title><link>https://nathannaveen.dev/posts/leetcode-1669/</link><pubDate>Tue, 06 Jul 2021 18:24:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1669/</guid><description>1669. Merge In Between Linked Lists
The idea of this solution can be explained with a simple image:
In image 1 we can see the input of list1 = [0, 1, 2, 3, 4, 5], list2 = [10, 11, 12], a = 3, and b = 4. We can iterate through list2 and store the beginning and end of the list. Then, we can iterate through list1 and find the pos of a - 1.</description></item><item><title>Leetcode 55</title><link>https://nathannaveen.dev/posts/leetcode-55/</link><pubDate>Tue, 06 Jul 2021 18:24:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-55/</guid><description>55. Jump Game
The idea of this solution is pretty simple once you understand it.
The idea of this solution is:
We get the maximum index we can go up to by getting the maximum of i + nums[i] and max. Then, if i has surpassed the maximum index, we can return false. Otherwise return true. If you don&amp;rsquo;t understand why this works, look at the following example:</description></item><item><title>Leetcode 280</title><link>https://nathannaveen.dev/posts/leetcode-280/</link><pubDate>Tue, 06 Jul 2021 18:24:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-280/</guid><description>280. Wiggle Sort
The idea of this solution is pretty simple. We sort nums and then keep switching the numbers, so we get the array wiggled.
func wiggleSort(nums []int) { sort.Ints(nums) for i := 1; i &amp;lt; len(nums) - 1; i += 2 { nums[i], nums[i + 1] = nums[i + 1], nums[i] } }</description></item><item><title>Leetcode 170</title><link>https://nathannaveen.dev/posts/leetcode-170/</link><pubDate>Tue, 06 Jul 2021 18:24:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-170/</guid><description>170. Two Sum III - Data structure design
I have to admit that this is not the best solution to solve this problem, but I think it is the easiest to understand. For all we do is:
Append to this.arr to Add(number). And use a two-pointer approach for Find(value). type TwoSum struct { arr []int } /** Initialize your data structure here. */ func Constructor() TwoSum { return TwoSum{[]int{}} } /** Add the number to an internal data structure.</description></item><item><title>Leetcode 1828</title><link>https://nathannaveen.dev/posts/leetcode-1828/</link><pubDate>Wed, 16 Jun 2021 11:22:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1828/</guid><description>1828. Queries on Number of Points Inside a Circle
The idea of this solution is to:
loop through the queries and then a nested loop to go through points.
After that we check whether squared(point[0] - query[0]) + squared(point[1] - query[1]) &amp;lt;= squared(query[2]). This is bascily checking whether the distance between two points is smaller than or equal to the radius but edited. This image that I have drawn and wrote up explains this part: (Note: point[0] = x1, query[0] = x2, point[1] = y1, query[1] = y2, query[2] = radius)</description></item><item><title>Leetcode 1837</title><link>https://nathannaveen.dev/posts/leetcode-1837/</link><pubDate>Wed, 16 Jun 2021 11:22:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1837/</guid><description>1837. Sum of Digits in Base K
Before I explain both solution I just want to say that for me the first solution is not as readable as the second solution but easyer to understand (Note: I wrote the first solution before the second solution so that might be why).
The first solution basicly uses the fact that n only goes up to 100 and that k has a range of 2 to 10</description></item><item><title>Leetcode 1854</title><link>https://nathannaveen.dev/posts/leetcode-1854/</link><pubDate>Wed, 16 Jun 2021 11:22:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1854/</guid><description>1854. Maximum Population Year
I first did this solution using an O(n^2) approach but then tried to think about how to do it better. I couldn&amp;rsquo;t, so I looked at the discussion and saw votrubac solution. The code below is pretty similar, except I make an array of size 101 instead of 2051 because we only need the years from 2050 to 1950.
func maximumPopulation(logs [][]int) int { populationPerYear := make([]int, 101) res := 0 for _, log := range logs { populationPerYear[log[0] - 1950]++ populationPerYear[log[1] - 1950]-- } for i := 1; i &amp;lt; 101; i++ { populationPerYear[i] += populationPerYear[i - 1] if populationPerYear[i] &amp;gt; populationPerYear[res] { res = i } } return res + 1950 }</description></item><item><title>Leetcode 1249</title><link>https://nathannaveen.dev/posts/leetcode-1249/</link><pubDate>Wed, 16 Jun 2021 11:22:30 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1249/</guid><description>1249. Minimum Remove to Make Valid Parentheses
The idea of this solution is:
Loop through every character in s, and: If the current character is a '(' add the index of the '(' to a stack If the current character is a ')': If the stack is not empty, we can pop off the stack If the stack is empty, remove the character from the string After looping through every character, if the stack is not empty, we remove the characters at the values in the stack.</description></item><item><title>Leetcode 48</title><link>https://nathannaveen.dev/posts/leetcode-48/</link><pubDate>Wed, 16 Jun 2021 11:22:22 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-48/</guid><description>48. Rotate Image
The idea of this solution is first to flip the matrix, so it is upside down, and then transpose the matrix. If you don&amp;rsquo;t understand, look at the following images:
We flip the matrix by fliping the top and bottom len(matrix) / 2 rows, like in this image:
And transposing the matrix is basically making matrix[i][j] = matrix[j][i], and the flips should only flip from yellow to the blue, or blue to yellow in the following image:</description></item><item><title>Leetcode 484</title><link>https://nathannaveen.dev/posts/leetcode-484/</link><pubDate>Wed, 16 Jun 2021 11:22:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-484/</guid><description>484. Find Permutation
The idea of this solution is to:
We get the first n + 1 numbers in order [1, 2, 3, ..., n + 1]. Then we reverse the numbers whenever we find a 'D', and we reverse a whole set of numbers when we find multiple 'D'&amp;rsquo;s together. Then we return the array. You might be wondering why we reverse sets of 'D'&amp;rsquo;s instead of just reversing every 'D', it can be shown using an image:</description></item><item><title>Leetcode 1874</title><link>https://nathannaveen.dev/posts/leetcode-1874/</link><pubDate>Wed, 16 Jun 2021 11:22:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1874/</guid><description>1874. Minimize Product Sum of Two Arrays
The idea of both solutions is pretty much the same: The smallest number multiplied by the greatest number always makes the smallest sum. If you don&amp;rsquo;t understand, look at the following image:
In the image above, the top array is sorted in non-decreasing order, and the bottom array is sorted in non-increasing order. So when we multiply nums1[i] and nums2[i] together, we get the minimum product, and when we sum the products up, we get the minimum sum.</description></item><item><title>Leetcode 1403</title><link>https://nathannaveen.dev/posts/leetcode-1403/</link><pubDate>Wed, 16 Jun 2021 11:22:07 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1403/</guid><description>1403. Minimum Subsequence in Non-Increasing Order
The idea of this solution is pretty simple, we first sort nums in non-increasing order and then find the sum of nums. After that, we can loop through nums and subtract the greatest numbers in nums from the total sum and add the greatest numbers in nums to a different sum. And then, we append the num to res (the resulting function). If the other sum is greater than the total sum, we can break out of the loop and return res.</description></item><item><title>Leetcode 944</title><link>https://nathannaveen.dev/posts/leetcode-944/</link><pubDate>Wed, 16 Jun 2021 11:21:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-944/</guid><description>944. Delete Columns to Make Sorted
This solution loops through every column, and then if the previous letter in the column is greater than the current letter, we know that this column can be removed.
func minDeletionSize(strs []string) int { res := 0 for i := 0; i &amp;lt; len(strs[0]); i++ { for j := 1; j &amp;lt; len(strs); j++ { if strs[j][i] &amp;lt; strs[j-1][i] { res++ break } } } return res }</description></item><item><title>Leetcode 1689</title><link>https://nathannaveen.dev/posts/leetcode-1689/</link><pubDate>Wed, 16 Jun 2021 11:21:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1689/</guid><description>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
The idea of this solution is that the max digit in n will be the result. But you might be wondering why this works.
This works because the max digit can only be made by adding the max digit number of 1&amp;rsquo;s. If you don&amp;rsquo;t understand, look at the following image: The first image is an example, and the second example is for anyone who doesn&amp;rsquo;t understand the first example.</description></item><item><title>Leetcode 1605</title><link>https://nathannaveen.dev/posts/leetcode-1605/</link><pubDate>Wed, 16 Jun 2021 11:21:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1605/</guid><description>1605. Find Valid Matrix Given Row and Column Sums
The idea of this solution is pretty simple:
We loop through len(rowSum), and len(colSum). We find the minimum for colSum[j], and rowSum[i], making the resulting matrix have the minimum. After that, we subtract the minimum from both colSum[j], and rowSum[i].
Here is an image example to help with the explanation:
func restoreMatrix(rowSum []int, colSum []int) [][]int { res := make([][]int, len(rowSum)) for i := 0; i &amp;lt; len(rowSum); i++ { arr := make([]int, len(colSum)) for j := 0; j &amp;lt; len(colSum); j++ { arr[j] = colSum[j] if colSum[j] &amp;gt; rowSum[i] { arr[j] = rowSum[i] } rowSum[i], colSum[j] = rowSum[i] - arr[j], colSum[j] - arr[j] } res[i] = arr } return res }</description></item><item><title>Leetcode 406</title><link>https://nathannaveen.dev/posts/leetcode-406/</link><pubDate>Wed, 16 Jun 2021 11:21:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-406/</guid><description>406. Queue Reconstruction by Height
The idea of this solution is to:
sort people&amp;rsquo;s height in non-decreasing order, and when two people have the same height, we sort their kth place in non-increasing order.
And then we add the following person to the resulting array in the kth vacant position (zero-indexed), like in this image: As you can see in row 1, k = 4, so we add the person of height 4 into res at position 4.</description></item><item><title>Leetcode 1338</title><link>https://nathannaveen.dev/posts/leetcode-1338/</link><pubDate>Wed, 16 Jun 2021 11:21:07 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1338/</guid><description>1338. Reduce Array Size to The Half
The idea of the first solution is to:
Find the frequency of all values in arr using a map called m. Then add all the values of m to an array called h. Then reverse sort h. Then loop through h, and subtract the maximum frequencies to be removing the minimum number of integers. While subtracting check whether n &amp;lt;= len(arr) / 2 if so return i + 1.</description></item><item><title>Leetcode 1663</title><link>https://nathannaveen.dev/posts/leetcode-1663/</link><pubDate>Wed, 16 Jun 2021 11:21:00 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1663/</guid><description>1663. Smallest String With A Given Numeric Value
This solution aims to make all the characters equal 'a' to start with, and then subtract n from k because we have added n amount of 'a'&amp;rsquo;s. After that, we can keep removing 'z'&amp;rsquo;s until k &amp;gt; 25, then we can remove the letter with an ASCII of k + 'a'.
func getSmallestString(n int, k int) string { k -= n res := make([]string, n) for i := 0; i &amp;lt; n; i++ { res[i] = &amp;#34;a&amp;#34; } for i := len(res) - 1; i &amp;gt;= 0; i-- { if k &amp;lt;= 25 { res[i] = string(k + &amp;#39;a&amp;#39;) break } else { res[i] = &amp;#34;z&amp;#34; k -= 25 } } return strings.</description></item><item><title>Leetcode 1154</title><link>https://nathannaveen.dev/posts/leetcode-1154/</link><pubDate>Wed, 16 Jun 2021 11:20:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1154/</guid><description>Note: I know that the second solution is pretty un-orthidoxed because we would have to change a lot of stuff if the input changed.
1154. Day of the Year
How the first solution works:
The first solution is pretty simple:
We find the year month and day (Note: We call the day res because the day is only used for adding to the result) We also have an array of the number of days per month Then we check whether it is a leep year, if so add 1 day to the result.</description></item><item><title>Leetcode 1880</title><link>https://nathannaveen.dev/posts/leetcode-1880/</link><pubDate>Wed, 16 Jun 2021 11:19:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1880/</guid><description>1880. Check if Word Equals Summation of Two Words
The idea of the first solution is:
We loop through every word and add the string(letter - '1') (basically add the string of the letter made into a number). Then we make that string into a number and check whether temp + temp2 == tempRes. The First Code:
func isSumEqual(firstWord string, secondWord string, targetWord string) bool { first, second, res := &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;&amp;#34; for _, letter := range firstWord { first += string(letter - &amp;#39;0&amp;#39;) } for _, letter := range secondWord { second += string(letter - &amp;#39;0&amp;#39;) } for _, letter := range targetWord { res += string(letter - &amp;#39;0&amp;#39;) } temp, _ := strconv.</description></item><item><title>Leetcode 1318</title><link>https://nathannaveen.dev/posts/leetcode-1318/</link><pubDate>Wed, 16 Jun 2021 11:19:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1318/</guid><description>1318. Minimum Flips to Make a OR b Equal to c
The idea of this solution is pretty simple because getting a || b == c means that:
If the last bit of c is 1: a can be either 1 if b is 1 or b is 0, or 0 if b is 1 Else if the last bit of c is 0: a and b have to be 0 because 0 || 0 == 0 is the only case which == 0.</description></item><item><title>Leetcode 1858</title><link>https://nathannaveen.dev/posts/leetcode-1858/</link><pubDate>Mon, 17 May 2021 09:50:59 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1858/</guid><description>1858. Longest Word With All Prefixes
This solution aims to sort words so we get the previous prefix of the max word before the word. An example of this could be
words = [&amp;quot;k&amp;quot;, &amp;quot;kiran&amp;quot;,&amp;quot;ki&amp;quot;,&amp;quot;kira&amp;quot;,&amp;quot;kir&amp;quot;] and when we sort, it becomes words = [&amp;quot;k&amp;quot;,&amp;quot;ki&amp;quot;,&amp;quot;kir&amp;quot;,&amp;quot;kira&amp;quot;, &amp;quot;kiran&amp;quot;].
Then we can use a map to build up the word. If the len(word) is equal to 1, we know that it is a start of a word, or if the map contains word without the last letter, we know that there is the prefix of the word.</description></item><item><title>Leetcode 1816</title><link>https://nathannaveen.dev/posts/leetcode-1816/</link><pubDate>Mon, 17 May 2021 09:50:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1816/</guid><description>1816. Truncate Sentence
Since the solution wants us to return the first k words
We can split the words Then we can return the the first k words joined together seperated by spaces. The Solution
func truncateSentence(s string, k int) string { return strings.Join(strings.Split(s, &amp;#34; &amp;#34;)[:k], &amp;#34; &amp;#34;) } Edited Solution for readability
func truncateSentence(s string, k int) string { arr := strings.Split(s, &amp;#34; &amp;#34;) return strings.Join(arr[:k], &amp;#34; &amp;#34;) }</description></item><item><title>Leetcode 1252</title><link>https://nathannaveen.dev/posts/leetcode-1252/</link><pubDate>Mon, 17 May 2021 09:50:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1252/</guid><description>1252. Cells with Odd Values in a Matrix
The idea of this solution is to use two maps, x, and y, and we can add all the values of indices to x, and y (index[0] to x, and index[1] to y).
Then we can check whether all the x&amp;rsquo;s plus all the y&amp;rsquo;s is odd. If so, we know that we can add one to the result.
If you don&amp;rsquo;t understand we can take an example:</description></item><item><title>Leetcode 1180</title><link>https://nathannaveen.dev/posts/leetcode-1180/</link><pubDate>Mon, 17 May 2021 09:50:40 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1180/</guid><description>1180. Count Substrings with Only One Distinct Letter
The idea of this solution is to use the number of consecutive letters. And to use the formula n * (n + 1) / 2 to find the number of valid substrings. We can use the example below to explain:
Before the example: n * (n + 1) / 2 is the equation for finding the sum of the first n consecutive elements.</description></item><item><title>Leetcode 1833</title><link>https://nathannaveen.dev/posts/leetcode-1833/</link><pubDate>Mon, 17 May 2021 09:50:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1833/</guid><description>1833. Maximum Ice Cream Bars
To be truthful, I think that this problem&amp;rsquo;s difficulty should be easy instead of medium.
This solution aims to sort costs because the maximum number of popsicles is obtained with the least price.
func maxIceCream(costs []int, coins int) int { sort.Ints(costs) res := 0 for _, cost := range costs { if coins - cost &amp;lt; 0 { break } res++ coins -= cost } return res }</description></item><item><title>Leetcode 1827</title><link>https://nathannaveen.dev/posts/leetcode-1827/</link><pubDate>Mon, 17 May 2021 09:50:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1827/</guid><description>1827. Minimum Operations to Make the Array Increasing
The ideas of both of the solutions are similar and simple. We know that an array is strictly increasing if the current element in the array, nums[i], is greater than the previous element nums[i - 1]. So if nums[i - 1] is greater than or equal to nums[i] we know that we have to make nums[i] = nums[i - 1] + 1.</description></item><item><title>Leetcode 1331</title><link>https://nathannaveen.dev/posts/leetcode-1331/</link><pubDate>Mon, 17 May 2021 09:49:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1331/</guid><description>1331. Rank Transform of an Array
The idea of this solution is to:
Copy arr. Then sort the copy Then loop through the copy and add all the values and indexes of the copy to a map called m. Then loop through 0 to len(arr) - 1, and make arr[i] = m[arr[i]]. Then return arr. func arrayRankTransform(arr []int) []int { g := make([]int, len(arr)) m := make(map[int]int) counter := 1 copy(g, arr) sort.</description></item><item><title>Leetcode 36</title><link>https://nathannaveen.dev/posts/leetcode-36/</link><pubDate>Mon, 17 May 2021 09:32:30 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-36/</guid><description>36. Valid Sudoku
The main idea of this solution is to find the rows, columns, and squares of the numbers. By squares, I mean the nine squares in the board:
The code goes through every position, and if the value is not a &amp;quot;.&amp;quot;, we check whether the row, column, or square contains the number. If so, we can return false.
How to Calculate The Rows And Columns
We check whether the row or column contains the number by using primes.</description></item><item><title>Leetcode 958</title><link>https://nathannaveen.dev/posts/leetcode-958/</link><pubDate>Wed, 05 May 2021 15:45:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-958/</guid><description>958. Check Completeness of a Binary Tree
This solution uses the facts that:
If there is a next row, we know that the whole row has to be full If there is no next row, all the nodes have to be to the left. If you have already looked at the code, you might have seen that we check whether there is a next row by checking whether queue[0].</description></item><item><title>Leetcode 1572</title><link>https://nathannaveen.dev/posts/leetcode-1572/</link><pubDate>Wed, 05 May 2021 15:45:36 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1572/</guid><description>1572. Matrix Diagonal Sum
The idea of the first solution is to add all the values in the diagonals, and if len(mat) is odd, we can subtract the middle element from res. You might be able to understand this solution a little more with two example images: The idea of the second solution is to find two positions in the array (Where a position is in the format (x, y)) which are on diagonals and are equal.</description></item><item><title>Leetcode 103</title><link>https://nathannaveen.dev/posts/leetcode-103/</link><pubDate>Mon, 03 May 2021 10:26:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-103/</guid><description>103. Binary Tree Zigzag Level Order Traversal
The idea of this solution is to use BFS and a variable called fromRight. The fromRight checks whether the current row needs to be traversed from the right. If it does, we prepend all the nodes to temp.
func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int queue := []*TreeNode{root} fromRight := false for len(queue) != 0 { temp := []int{} n := len(queue) for i := 0; i &amp;lt; n; i++ { node := queue[0] queue = queue[1:] if node !</description></item><item><title>Leetcode 1609</title><link>https://nathannaveen.dev/posts/leetcode-1609/</link><pubDate>Mon, 03 May 2021 10:17:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1609/</guid><description>1609. Even Odd Tree
The main idea of this solution is to use BFS, but the details are:
We have a counter called row to count every row (We use this to check whether it is an even row or an odd row). Then we have a queue that has only the root to start. We loop while len(queue) != 0 Then we make a variable n equal to the len(queue).</description></item><item><title>Leetcode 107</title><link>https://nathannaveen.dev/posts/leetcode-107/</link><pubDate>Mon, 03 May 2021 10:17:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-107/</guid><description>107. Binary Tree Level Order Traversal II
First solution: faster than 100% Second solution: faster than 100%
I put in the edited for people who don&amp;rsquo;t code in go because people who don&amp;rsquo;t code in go won&amp;rsquo;t understand res = append(res[:0], append([][]int{temp}, res[0:]...)...). So if you don&amp;rsquo;t understand the first solution look at the edited.
First solution:
func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} queue := []*TreeNode{root} for len(queue) !</description></item><item><title>Leetcode 1602</title><link>https://nathannaveen.dev/posts/leetcode-1602/</link><pubDate>Mon, 03 May 2021 10:17:00 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1602/</guid><description>1602. Find Nearest Right Node in Binary Tree
The idea of this solution is to use a queue to loop through the tree, and then for every node we loop through, we check whether the node.Val == u.Val, if so, we go through the if statement if i == n - 1. Using this, we know whether the node is the last. If so, we return nil. Else we return the node after the current node.</description></item><item><title>Leetcode 1161</title><link>https://nathannaveen.dev/posts/leetcode-1161/</link><pubDate>Mon, 03 May 2021 10:16:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1161/</guid><description>1161. Maximum Level Sum of a Binary Tree
What the Problem is Asking Us:
The problem is asking us to go through each level of the binary tree and find the maximum sum and make that the returned level, but if the maximum sum is on two levels, we get the minimum level of those two.
The Code:
func maxLevelSum(root *TreeNode) int { maximum, minLevel, level := root.Val, 1, 0 queue := []*TreeNode{root} for len(queue) !</description></item><item><title>Leetcode 844</title><link>https://nathannaveen.dev/posts/leetcode-844/</link><pubDate>Wed, 28 Apr 2021 21:33:02 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-844/</guid><description>844. Backspace String Compare
To be truthful I am not sure whether this solution is an O(n) time or a O(2n) time because this code loops through s then t. Could someone tell me which it is?
So the idea of this solution is: *Note: I will be explaining only the loop for s because the loop for s is pretty much the same as the loop for t.
So the code first loops from 0 to len(s).</description></item><item><title>Leetcode 720</title><link>https://nathannaveen.dev/posts/leetcode-720/</link><pubDate>Wed, 28 Apr 2021 21:30:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-720/</guid><description>720. Longest Word in Dictionary
The idea of this solution is pretty simple:
The code will sort words, so the minor parts we use to build the biggest words are before the built-up words. Also, since words is sorted, we don&amp;rsquo;t have to worry about the &amp;ldquo;longest word with the smallest lexicographical order&amp;rdquo;; we only have to care about the &amp;ldquo;longest word&amp;rdquo; part. After that, the code will loop through words.</description></item><item><title>Leetcode 500</title><link>https://nathannaveen.dev/posts/leetcode-500/</link><pubDate>Wed, 28 Apr 2021 21:30:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-500/</guid><description>500. Keyboard Row
I know that this code is not pretty, but the idea of the solution is pretty simple:
We can first make a map of letters where the top rows letters are assigned to the number 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, the middle row&amp;rsquo;s characters are assigned to the numbers 10, 11, 12, 13, 14, 15, 16, 17, 18, and the last rows characters are assigned to the numbers 19, 20, 21, 22, 23, 24, 25.</description></item><item><title>Leetcode 1374</title><link>https://nathannaveen.dev/posts/leetcode-1374/</link><pubDate>Mon, 26 Apr 2021 07:51:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1374/</guid><description>1374. Generate a String With Characters That Have Odd Counts
This solution is relatively straightforward. All it does is if n is odd, we can return n numbers of 'a', but if n is even, we can return a count of n - 1, 'a'&amp;rsquo;s plus one 'b'.
You might be wondering why we are doing n number of a&amp;rsquo;s for when n is odd and n - 1 number of a&amp;rsquo;s and a b for when n is even.</description></item><item><title>Leetcode 1232</title><link>https://nathannaveen.dev/posts/leetcode-1232/</link><pubDate>Sun, 25 Apr 2021 21:15:52 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1232/</guid><description>1232. Check If It Is a Straight Line
The idea of this solution is we use 3 points to find whether two slopes are equal. We can use the equation:where x0, x1, x2, y0, y1, y2 are all coordinates: You might not understand the equation, so we can multiply divide both sides by (x1 - x0) and (x2 - x1) and we can get: The equation above is based off of a familar slope equation: The reason we are doing the original equation instead of the where we have divided both sides by (x1 - x0) and (x2 - x1) is we don&amp;rsquo;t have to worry about dividing by 0 such as when we divide both sides by (x1 - x0) and (x2 - x1) but (x1 - x0) = 0 or (x2 - x1) = 0 we have to contumplate what to do.</description></item><item><title>Leetcode 1564</title><link>https://nathannaveen.dev/posts/leetcode-1564/</link><pubDate>Sun, 25 Apr 2021 18:43:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1564/</guid><description>1564. Put Boxes Into the Warehouse I
The idea of this solution is:
We sort boxes. Then, we make an array called minimums, and put the minimum values of warehouse from left to right into the array. If you don&amp;rsquo;t understand, look at the following images: Then we can just look from len(minimums) - 1 to 0 and check whether minimums[i] &amp;gt;= boxes[boxCounter] we can go to the next box, other wise we continue going through the loop until minimums[i] &amp;gt;= boxes[boxCounter].</description></item><item><title>Leetcode 1422</title><link>https://nathannaveen.dev/posts/leetcode-1422/</link><pubDate>Sun, 25 Apr 2021 11:08:11 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1422/</guid><description>1422. Maximum Score After Splitting a String
The idea of the first solution is pretty simple, and the second solution is based on the first solution.
The idea of the first solution is:
We loop through s and add all the numbers to a counter called numberOfOnes to count the number of ones. We do this by using ASCII. The ASCII of 0 is 48, and the ASCII of 1 is 49, so we can get the int of s[i] and then subtract 48 from it to get 0 or 1.</description></item><item><title>Leetcode 748</title><link>https://nathannaveen.dev/posts/leetcode-748/</link><pubDate>Sun, 25 Apr 2021 11:08:04 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-748/</guid><description>Shortest Completing Word
Here is how I got to this solution. I couldn&amp;rsquo;t think of any way to solve this problem without doing a naive solution, so I looked at the discussion and saw jmcelvenny&amp;rsquo;s solution.
The idea of this solution is:
we get all the letters in licensePlate and multiply each letter&amp;rsquo;s prime number to a variable called product. We have an array of 26 prime numbers, so each letter has its own prime number (upper case and lower case of the same letter share a prime number), such as a : primes[0], b : primes[1], c : primes[2], and A : primes[0], B : primes[1], C : primes[2].</description></item><item><title>Leetcode 1151</title><link>https://nathannaveen.dev/posts/leetcode-1151/</link><pubDate>Thu, 22 Apr 2021 09:14:35 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1151/</guid><description>1151. Minimum Swaps to Group All 1&amp;rsquo;s Together
The idea of this solution is:
We find the number of 1&amp;rsquo;s. Then we know that the 1&amp;rsquo;s have to be in a subarray of the length of all the 1&amp;rsquo;s. We know that this works because the problem statement says that all the 1&amp;rsquo;s should be together in any place. Since we know that all the ones should be in a substring of length the number of ones in data, we just have to find the substring with the maximum number of 1&amp;rsquo;s in it already so, we get the minimum switches.</description></item><item><title>Leetcode 859</title><link>https://nathannaveen.dev/posts/leetcode-859/</link><pubDate>Thu, 22 Apr 2021 09:14:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-859/</guid><description>859. Buddy Strings
To check whether two strings are buddy strings we have to check whether:
len(a) == len(b) if a == b, and there is a duplicate letter in a if there are a[j] != b[j] and a[i] != b[i] and a[j] == b[i] and a[i] == b[j] func buddyStrings(a string, b string) bool { if len(a) != len(b) { return false } m := make(map[uint8]int) temp := -1 counter := 0 for i := 0; i &amp;lt; len(a); i++ { m[a[i]]++ if a == b &amp;amp;&amp;amp; m[a[i]] == 2 { return true } if a[i] !</description></item><item><title>Leetcode 1176</title><link>https://nathannaveen.dev/posts/leetcode-1176/</link><pubDate>Mon, 19 Apr 2021 10:48:25 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1176/</guid><description>1176. Diet Plan Performance
This is how the code works:
We sum up the first k elements. Then compare whether sum is greater than upper or smaller than lower. After comparing we can loop from k to len(calories). Then we can take off the beggining of the subarray by subtracting calories[i - k]. And then we have to add the next element from the end of the subarray to the end to the subarray, we do this by adding calories[i].</description></item><item><title>Leetcode 1323</title><link>https://nathannaveen.dev/posts/leetcode-1323/</link><pubDate>Mon, 19 Apr 2021 10:48:16 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1323/</guid><description>1323. Maximum 69 Number
This solution is pretty simple once you understand it.
The idea of this solution is since 9 - 6 = 3, so 6 + 3 = 9. When we add 3 * the current place value to 6 * the current place value we get 9 * the current place value. So if we do 60 + (3 * 10) = 90, 600 + (3 * 100) = 900, 6000 + (3 * 1000) = 9000.</description></item><item><title>Leetcode 392</title><link>https://nathannaveen.dev/posts/leetcode-392/</link><pubDate>Mon, 19 Apr 2021 10:48:01 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-392/</guid><description>392. Is Subsequence
func isSubsequence(s string, t string) bool { sCounter, i := 0, 0 for i &amp;lt; len(t) &amp;amp;&amp;amp; sCounter &amp;lt; len(s) { if t[i] == s[sCounter] { sCounter++ } i++ } return sCounter == len(s) }</description></item><item><title>Leetcode 229</title><link>https://nathannaveen.dev/posts/leetcode-229/</link><pubDate>Sat, 17 Apr 2021 09:23:24 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-229/</guid><description>229. Majority Element II
This solution is pretty simple:
We loop through nums We add 1 to a map of integers called m, so we add 1 to m[num] where num is the current number in nums. Then we check whether m[num] == len(nums) / 3 + 1 this is checking whether the element is a majority element. Note: We can&amp;rsquo;t do m[num] &amp;gt;= len(nums) / 3 + 1.</description></item><item><title>Leetcode 1100</title><link>https://nathannaveen.dev/posts/leetcode-1100/</link><pubDate>Fri, 16 Apr 2021 10:48:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1100/</guid><description>1100. Find K-Length Substrings With No Repeated Characters
The Idea Of This Solution:
This solution aims to use a counter called counter to count the number of duplicates. Also, when counter == 0, the substring has no duplicates.
How This Solution Works:
First, we make the variables counter, res, and m. counter is the duplicate counter, res is the resulting number of substrings that have unique characters, and m is a map that is used to find out whether a character is a duplicate.</description></item><item><title>Leetcode 1822</title><link>https://nathannaveen.dev/posts/leetcode-1822/</link><pubDate>Thu, 15 Apr 2021 09:40:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1822/</guid><description>1822. Sign of the Product of an Array
The idea of this solution is elementary:
If the current number in nums is negative, then we can flip the sign If the current number in nums is equal to 0, we can return 0 because any number multiplied by 0 is 0. You might think that we can check for if num == 0 after we have iterated, but that won&amp;rsquo;t work because we only switch the sign and don&amp;rsquo;t multiply by 0, so we will never know whether there is a 0 in the array.</description></item><item><title>Leetcode 1800</title><link>https://nathannaveen.dev/posts/leetcode-1800/</link><pubDate>Thu, 15 Apr 2021 08:50:00 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1800/</guid><description>1800. Maximum Ascending Subarray Sum
The idea of this solution is pretty simple:
We need two variables, sum for the current sum of ascending values and maximum for the maximum sum. Then we loop through nums. Inside the loop, we check whether the current number is greater than the previous number. If so, we can add the number to sum. Else the number is smaller than or equal to the previous number, we can make maximum equal to the math.</description></item><item><title>Leetcode 119</title><link>https://nathannaveen.dev/posts/leetcode-119/</link><pubDate>Thu, 15 Apr 2021 08:49:51 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-119/</guid><description>119. Pascal&amp;rsquo;s Triangle II
I will explain the first solution.
If you want to understand the second solution click on the link above the code.
So the first solution only wants us to return the last row of the triangle.
Since we need two rows always for this problem the current row and the previous row. In this problem res is the current row and temp is the previous row.</description></item><item><title>Leetcode 118</title><link>https://nathannaveen.dev/posts/leetcode-118/</link><pubDate>Wed, 14 Apr 2021 12:29:07 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-118/</guid><description>118. Pascal&amp;rsquo;s Triangle
The idea of this solution is pretty simple:
We first have a matrix array called res Then we loop through numRows While iterating through numRows we have to make an array called temp. It is going to be our current row. We make temp[0] and temp[len(temp)] equal to 1 so we get the outer 1&amp;rsquo;s. Then we loop through the middle elements (basically excluding the outside 1&amp;rsquo;s) We have to make every temp[j] equal to the previous rows previous rows[j - 1] + previous rows[j].</description></item><item><title>Leetcode 56</title><link>https://nathannaveen.dev/posts/leetcode-56/</link><pubDate>Wed, 14 Apr 2021 09:58:31 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-56/</guid><description>func merge(intervals [][]int) [][]int { res := [][]int{} for i := 1; i &amp;lt; len(intervals); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; intervals[i-1][0] &amp;gt; intervals[i][0] { intervals[i-1], intervals[i] = intervals[i], intervals[i-1] i -= 2 } } res = append(res, intervals[0]) for i := 1; i &amp;lt; len(intervals); i++ { if res[len(res)-1][1] &amp;gt;= intervals[i][0] { res[len(res)-1][1] = max(intervals[i][1], res[len(res)-1][1]) } else { res = append(res, intervals[i]) } } return res } func max(a, b int) int { if a &amp;gt; b { return a } return b }</description></item><item><title>Leetcode 824</title><link>https://nathannaveen.dev/posts/leetcode-824/</link><pubDate>Wed, 14 Apr 2021 09:58:25 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-824/</guid><description>824. Goat Latin
The idea of this solution is actualy pretty simple. We:
First add all the vowels to a map. We make a a string where we keep on appending &amp;quot;a&amp;quot; to it per word. Then we split S by spaces so we get all the words in an array called words. Then we loop through words. Inside the iteration we check whether the first letter of the current word is not a vowel we can move the first letter to the end.</description></item><item><title>Leetcode 252</title><link>https://nathannaveen.dev/posts/leetcode-252/</link><pubDate>Tue, 13 Apr 2021 10:11:45 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-252/</guid><description>252. Meeting Rooms
The Idea Of The Solutions:
The idea of these two solutions is pretty simple because the second solution is based on the first solution, and the first solution is pretty simple.
The idea of the first solution is:
First, we sort intervals. Then, we check whether the previous interval&amp;rsquo;s ends intersect with the following interval&amp;rsquo;s beginning. The idea of the second solution is:
While sorting, we check for overlaps.</description></item><item><title>Leetcode 1551</title><link>https://nathannaveen.dev/posts/leetcode-1551/</link><pubDate>Sat, 10 Apr 2021 20:14:34 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1551/</guid><description>1551. Minimum Operations to Make Array Equal
This is a pretty simple solution once you understand the concept.
What the Problem Is Asking:
The problem gives us an array where arr[i] = (2 * i) + 1, you could make an array where every arr[i] = (2 * i) + 1 but I am just going to tell you that this plots a sequence of odd integers. Bascily arr[1, 3, 5 .</description></item><item><title>Leetcode 1742</title><link>https://nathannaveen.dev/posts/leetcode-1742/</link><pubDate>Sat, 10 Apr 2021 09:44:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1742/</guid><description>1742. Maximum Number of Balls in a Box
The idea of this solution is pretty simple:
We use a map to store all the elements and their frequencies, and we use a variable called maximum to store the maximum frequency. We loop from lowLimit to highLimit. Inside the first loop, we make a nested loop to sum up all the digits of each number between lowLimit and highLimt. After we have got the sum, we do m[sum]++ because we have to add one to the frequency of sum.</description></item><item><title>Leetcode 1426</title><link>https://nathannaveen.dev/posts/leetcode-1426/</link><pubDate>Sat, 10 Apr 2021 09:44:48 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1426/</guid><description>1426. Counting Elements
This solution is straightforward, and the idea of this solution is we add all the values of arr into a map called m. All we do is check whether m contains arr[i] + 1. If it does, we can add one to the resulting counter.
So the code:
First, makes a map called m and a variable called res. Then we loop through arr and add all the values into m.</description></item><item><title>Leetcode 1071</title><link>https://nathannaveen.dev/posts/leetcode-1071/</link><pubDate>Fri, 09 Apr 2021 10:56:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1071/</guid><description>1071. Greatest Common Divisor of Strings
The idea of this solution is actually pretty simple. But before we go into the problem, we have to know that a string with a common factor has a prefix (the definition of a prefix is the beginning characters of a string, a prefix can be any length) that is repeated throughout the string. This can be shown using some examples:
&amp;quot;abcdabcdabcd&amp;quot; we know that the repeated substring is &amp;quot;abcd&amp;quot;, and we can see that &amp;quot;abcd&amp;quot; is a prefix.</description></item><item><title>Leetcode 892</title><link>https://nathannaveen.dev/posts/leetcode-892/</link><pubDate>Fri, 09 Apr 2021 10:56:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-892/</guid><description>892. Surface Area of 3D Shapes
The Idea Of This Solution:
This solution uses the fact that each stack of cubes surface area is the equation 2 + 4 * v. This works because each cube has 6 sides. This can be shown using some images:
We can see that each cube has 6 planes. There are 4 sides, 1 top, and 1 bottom.
Now, as we can see, there are 10 units of surface area while the other one only had 6, there are 8 sides, 1 top, and 1 bottom.</description></item><item><title>Leetcode 1272</title><link>https://nathannaveen.dev/posts/leetcode-1272/</link><pubDate>Wed, 07 Apr 2021 12:36:27 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1272/</guid><description>1272. Remove Interval
What This Code Is Doing:
We make a new resulting array and then loop through intervals.
What we need to know for the following if and else statements is when the code loops through intervals, we get interval per iteration. interval is in the format [start, end]. Also, the constraints say -10^9 &amp;lt;= start &amp;lt; end &amp;lt;= 10^9, so we can see that start and end are never on the exact same location and the start is always lesser than end.</description></item><item><title>Leetcode 874</title><link>https://nathannaveen.dev/posts/leetcode-874/</link><pubDate>Wed, 07 Apr 2021 12:36:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-874/</guid><description>874. Walking Robot Simulation
Warning: This solution is pretty annoying.
What The Problem is Telling Us:
The problem description says that they will give an array called commands that tell you to turn right, left, or move forward, and they will also give you a matrix array called obstacles. obstacles is pretty self-explanatory. It is points where an obstacle is at. The points are in the format of (x, y).</description></item><item><title>Leetcode 1475</title><link>https://nathannaveen.dev/posts/leetcode-1475/</link><pubDate>Tue, 06 Apr 2021 09:57:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1475/</guid><description>1475. Final Prices With a Special Discount in a Shop
This solution is pretty simple just loop through prices and then find the first price smaller than the current one. After that, remake prices[i] the current price minus the minimum.
The Code:
func finalPrices(prices []int) []int { for i, price := range prices { minimum := 1001 for j := i + 1; j &amp;lt; len(prices); j++ { if prices[j] &amp;lt;= price { minimum = prices[j] break } } if minimum !</description></item><item><title>Leetcode 633</title><link>https://nathannaveen.dev/posts/leetcode-633/</link><pubDate>Mon, 05 Apr 2021 12:24:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-633/</guid><description>633. Sum of Square Numbers
Both solutions use the simple knowledge of:
If c = a^2 + b^2 then b^2 = c - a^2 and a^2 = c - b^2.
The Idea of the First Solution:
The idea of this solution is pretty simple since we know that a^2 = c - b^2 we can store a^2 in a map called m, and then we check whether m contains c - b^2.</description></item><item><title>Leetcode 1465</title><link>https://nathannaveen.dev/posts/leetcode-1465/</link><pubDate>Mon, 05 Apr 2021 12:23:52 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1465/</guid><description>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
What The Problem Is Asking:
The problem is telling us that there are cuts in a rectangular cake of width w and height h. The cuts are only horizontal and vertical.
The problem wants us to find the largest slice of cake.
The Main Idea of This Solution:
We can find the maximum area slice by finding the maximum vertical length between each horizontal portion and the maximum horizontal length between each slice and then multiplying them together to get the maximum area.</description></item><item><title>Leetcode 658</title><link>https://nathannaveen.dev/posts/leetcode-658/</link><pubDate>Sun, 04 Apr 2021 16:47:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-658/</guid><description>658. Find K Closest Elements
What The Problem Is Asking:
The problem asks us to find the k closest elements in an array to the value x. We find the distance between elements by doing |value - x| and the k elements with the smallest distances.
The Main Idea Of This Solution:
Since we have to find the k closest elements, we can sort the array from the smallest distance to the greatest distance.</description></item><item><title>How the Manual Sort Works</title><link>https://nathannaveen.dev/posts/how-the-manual-sort-works/</link><pubDate>Sun, 04 Apr 2021 16:40:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/how-the-manual-sort-works/</guid><description>The idea of this is pretty simple:
We check whether the previous number is greater than the current number. If it is switch the two values in the array around and subtract two from i (i = The current position). After that we subtract 2 from i because we want to go back by one position. We subtract 2 to go back 1 because we add one to i in the for loop.</description></item><item><title>Leetcode 734</title><link>https://nathannaveen.dev/posts/leetcode-734/</link><pubDate>Fri, 02 Apr 2021 13:08:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-734/</guid><description>734. Sentence Similarity
The idea of this solution is to:
We have to first check whether the lengths of the two sentences are the same. If they aren&amp;rsquo;t, we return false. Then we have to make a map called m. The map is in a format of string, []string where string is the key and []string is the value. We add all the values from the matrix array called similarPairs to m.</description></item><item><title>Leetcode 1118</title><link>https://nathannaveen.dev/posts/leetcode-1118/</link><pubDate>Thu, 01 Apr 2021 13:15:33 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1118/</guid><description>1118. Number of Days in a Month
To start, I wouldn&amp;rsquo;t say that this is a good interview problem because it is not an algorithmic problem.
The months and the number of days in each month can be shown in the table below:
In February, it can be either 28 days or 29 days. 28 days in a regular year and 29 days in a leap year.
We can see that if the month is January, March, May, July, August, October, December, we return 31 days.</description></item><item><title>Leetcode 1708</title><link>https://nathannaveen.dev/posts/leetcode-1708/</link><pubDate>Thu, 01 Apr 2021 11:53:48 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1708/</guid><description>1708. Largest Subarray Length K
The idea of this solution is pretty simple we get every subarray so length k. We get the max subarray, compare it with the current subarray, and then check which array is greater, the current subarray, or the maximum subarray.
We compare subarrays by looping through the length of the subarrays (They are both have the same size). Every time we iterate, we check whether the index of the current subarray is greater than the index of the max subarray and the opposite.</description></item><item><title>Leetcode 246</title><link>https://nathannaveen.dev/posts/leetcode-246/</link><pubDate>Thu, 01 Apr 2021 10:34:39 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-246/</guid><description>246. Strobogrammatic Number
This solution is pretty simple and pretty similar to Leetcode 163.
The problem asks us to flip a number by 180 degrees and then return true if the fliped number is equal to the non-fliped number.
You might think that just flipping every digit and then check whether the following fliped number is equal to the non fliped number, but there is a problem with just flipping. Here is an example to show that just flipping doesn&amp;rsquo;t work:</description></item><item><title>Leetcode 1427</title><link>https://nathannaveen.dev/posts/leetcode-1427/</link><pubDate>Tue, 30 Mar 2021 13:23:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1427/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 163</title><link>https://nathannaveen.dev/posts/leetcode-163/</link><pubDate>Fri, 26 Mar 2021 10:27:54 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-163/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 1791</title><link>https://nathannaveen.dev/posts/leetcode-1791/</link><pubDate>Wed, 24 Mar 2021 12:35:49 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1791/</guid><description>1791. Find Center of Star Graph
This solution is straightforward.
We first make an array called nodes with edges + 1 values. We need edges + 1 values because len(edges) is the number of edge nodes, and the + 1 is for the center node. We only need edges + 1 nodes because the nodes are from 1...n. Then we loop through edges and get each edge. edge[0] and edge[1] are the two values given per edge.</description></item><item><title>Leetcode 1213</title><link>https://nathannaveen.dev/posts/leetcode-1213/</link><pubDate>Wed, 24 Mar 2021 10:44:39 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1213/</guid><description>1213. Intersection of Three Sorted Arrays
What The Problem Asks:
The problem statement is:
Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays.
They are giving us an input of three strictly increasing arrays, and we have to find all the numbers that repeat in all three arrays.
This problem statement&amp;rsquo;s critical thing is strictly increasing because strictly increasing is different from Non-decreasing.</description></item><item><title>Leetcode 360</title><link>https://nathannaveen.dev/posts/leetcode-360/</link><pubDate>Tue, 23 Mar 2021 12:20:59 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-360/</guid><description>360. Sort Transformed Array
The idea of this solution is to loop through nums and do the quadratic equation f(x) = ax^2 + bx + c where x = nums[i] and then make nums[i] the result of the ax^2 + bx + c. After that we can sort and return nums.
Solution Using Manual Sort
func sortTransformedArray(nums []int, a int, b int, c int) []int { for i := 0; i &amp;lt; len(nums); i++ { nums[i] = a*nums[i]*nums[i] + b*nums[i] + c } for i := 1; i &amp;lt; len(nums); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i-1] { nums[i], nums[i-1] = nums[i-1], nums[i] i -= 2 } } return nums } The Same Solution But Using a Built In Sort:</description></item><item><title>Leetcode 1198</title><link>https://nathannaveen.dev/posts/leetcode-1198/</link><pubDate>Mon, 22 Mar 2021 12:57:36 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1198/</guid><description>1198. Find Smallest Common Element in All Rows
m = len(mat), n = len(mat[0])
speed = O(mn) space = O(number of unique numbers) What The Problem Is Asking:
The problem description is
Given a matrix mat where every row is sorted in strictly increasing order, return the smallest common element in all rows.
If there is no common element, return -1.
The problem is asking us to return an element that appears in every array of the matrix array, and if there are multiple, we should return the smallest.</description></item><item><title>Leetcode 296</title><link>https://nathannaveen.dev/posts/leetcode-296/</link><pubDate>Mon, 22 Mar 2021 11:57:20 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-296/</guid><description>296. Best Meeting Point
What the Problem Is Asking:
The problem gives us an input binary matrix array called grid. If grid[i][j] = 1 then it is a house of a friend, and if grid[i][j] = 0 then there is no house there.
The problem asks us to find a point on the grid that is the smallest distance to walk from all the houses. Note that the point on the grid with the smallest distance can be on a house or an empty space.</description></item><item><title>Leetcode 1121</title><link>https://nathannaveen.dev/posts/leetcode-1121/</link><pubDate>Sun, 21 Mar 2021 22:01:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1121/</guid><description>1121. Divide Array Into Increasing Sequences
What the Problem is Asking Us To Do:
The problem statement is:
Given a non-decreasing array of positive integers nums and an integer K, find out if this array can be divided into one or more disjoint increasing subsequences of length at least K.
What this is saying is:
We are first given a sorted array of positive integers called nums and an integer K for our input.</description></item><item><title>Leetcode 1214</title><link>https://nathannaveen.dev/posts/leetcode-1214/</link><pubDate>Sun, 21 Mar 2021 11:36:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1214/</guid><description>1214. Two Sum BSTs
Quick Run-Down On The Solutions
The first solution is the easiest of the three solutions and the worst-time complexity solution. The second solution has a different approach from the first solution and a little better time but still not that great. The third solution has a lot better time than the first two solutions and has a similar approach to the second solution. The Ideas of These Solutions:</description></item><item><title>Leetcode 272</title><link>https://nathannaveen.dev/posts/leetcode-272/</link><pubDate>Fri, 19 Mar 2021 09:50:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-272/</guid><description>272. Closest Binary Search Tree Value II
The idea of this solution is pretty simple, we just iterate through the tree and append the absolute difference between the popped value and target to an array called differences, then we append the popped value to an array called eachNumber. After we have iterated through the whole array we can sort the difference array while sorting the eachNumber array. After that we return the first k numbers from eachNumber.</description></item><item><title>Leetcode 1762</title><link>https://nathannaveen.dev/posts/leetcode-1762/</link><pubDate>Fri, 19 Mar 2021 09:39:06 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1762/</guid><description>1762. Buildings With an Ocean View
The idea of the solution:
The idea of this solution is to loop through the array heights backwards. Then we just have to find if a height that is greater that the curent height. After that we can reverse the resulting array because the problem asks us to give us the sorted array of indexes that have an ocean view.
If you don&amp;rsquo;t understand the explaination just look at the following images:</description></item><item><title>Leetcode 1134</title><link>https://nathannaveen.dev/posts/leetcode-1134/</link><pubDate>Thu, 18 Mar 2021 17:44:12 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1134/</guid><description>1134. Armstrong Number
The idea of this solution is to just loop through every digit of n then add the n^(lengthOfNumber) to a variable called sum, then we return sum == n.
func isArmstrong(n int) bool { lengthOfNumber := len(strconv.Itoa(n)) sum := 0 newN := n for newN &amp;gt; 0 { sum += powerOfK(lengthOfNumber, newN%10) newN /= 10 } return sum == n } func powerOfK(lengthOfNumber, n int) int { res := 1 for i := 0; i &amp;lt; lengthOfNumber; i++ { res *= n } return res }</description></item><item><title>Leetcode 1085</title><link>https://nathannaveen.dev/posts/leetcode-1085/</link><pubDate>Thu, 18 Mar 2021 17:43:55 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1085/</guid><description>1085. Sum of Digits in the Minimum Number
The idea of the first two solutions is pretty simple. We sort the array A and then we just find the sum of the digits of the smallest number.
The idea of the second solution is pretty simple as well. We loop through A and find the minimum value, and the find the sum of the digits of the smallest number.
Solution: (Using a manual sort).</description></item><item><title>Leetcode 1133</title><link>https://nathannaveen.dev/posts/leetcode-1133/</link><pubDate>Thu, 18 Mar 2021 17:43:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1133/</guid><description>1133. Largest Unique Number
Here are two ways to solve this solution:
One way is to use an array of size 1001 which we call h (1001 because in the notes it says 0 &amp;lt;= A[i] &amp;lt;= 1000) and add one to h[A[i]]. Now we can see that the array will be sorted because we add the number of numbers to h. So all we have to do is iterate through h backward and check whether the value of h[i] == 1.</description></item><item><title>Leetcode 1469</title><link>https://nathannaveen.dev/posts/leetcode-1469/</link><pubDate>Thu, 18 Mar 2021 14:11:02 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1469/</guid><description>1469. Find All The Lonely Nodes
The idea of this solution is pretty simple, there are just four conditions:
if there is a left node but not a right node if there is a right node but not a left node if there is both a left and a right node if there are neither a left or a right node We can ignore the part where there is neither a left or a right node.</description></item><item><title>Leetcode 270</title><link>https://nathannaveen.dev/posts/leetcode-270/</link><pubDate>Thu, 18 Mar 2021 14:10:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-270/</guid><description>270. Closest Binary Search Tree Value
The idea of this solution is pretty simple. We have to iterate through the tree and then find the absolute minimum difference between the target and the value from the tree. (Keep in mind that we want everything to be a float64, so then we get proper comparisons). This can be shown with the equation:
The Code:
func closestValue(root *TreeNode, target float64) int { stack := []*TreeNode{root} minimum := float64(1000000000) number := 0 for len(stack) !</description></item><item><title>Leetcode 266</title><link>https://nathannaveen.dev/posts/leetcode-266/</link><pubDate>Thu, 18 Mar 2021 14:10:37 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-266/</guid><description>266. Palindrome Permutation
The idea of this solution is pretty simple. We add all the letters to a map, and then if there is a extra letter that does not have a partner for the other end of the palindrome add it to the numberOfOnes counter, if the counter is greater than 1 we know that it is not a palindrome. We can explain this with some examples:
There are three main examples that are going to be shown:</description></item><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description></item><item><title>Leetcode 1119</title><link>https://nathannaveen.dev/posts/leetcode-1119/</link><pubDate>Thu, 18 Mar 2021 11:32:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1119/</guid><description>1119. Remove Vowels from a String
The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.
The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.
This can be shown with some images:
We can have:
input: &amp;quot;leetcode&amp;quot; expected output: &amp;quot;ltcd&amp;quot; We can fast forward to our first vowel, 'e'.</description></item><item><title>Leetcode 1138</title><link>https://nathannaveen.dev/posts/leetcode-1138/</link><pubDate>Thu, 18 Mar 2021 11:32:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1138/</guid><description>1138. Alphabet Board Path
I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.
What the Problem is asking:
The problem asks us to make a board of letters:
[ [a, b, c, d, e] [f, g, h, i, j] [k, l, m, n, o] [p, q, r, s, t] [u, v, w, x, y] [z] ] Then it gives us a word target.</description></item><item><title>Leetcode 1041</title><link>https://nathannaveen.dev/posts/leetcode-1041/</link><pubDate>Tue, 16 Mar 2021 12:41:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1041/</guid><description>1041. Robot Bounded In Circle
What the problem is asking:
The problem says that it will give a string with the letters &amp;quot;L&amp;quot;, &amp;quot;R&amp;quot; and &amp;quot;G&amp;quot; to command a robot. &amp;quot;L&amp;quot; means to turn left 90 degrees, &amp;quot;R&amp;quot; means to turn right 90 degrees, and &amp;quot;G&amp;quot; means to go forward one unit. The problem says to return true if the robot can continue in that pattern forever and keep going in a circle.</description></item><item><title>Leetcode 692</title><link>https://nathannaveen.dev/posts/leetcode-692/</link><pubDate>Mon, 15 Mar 2021 11:52:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-692/</guid><description>692. Top K Frequent Words
The Main Idea:
This solution first adds the words to an array called frequency and sorts frequency after that, return the k most frequency words.
Adding to the array Frequency:
You might be confused when we do this part:
for _, ints := range frequency { if words[ints[0]] == word { contains = true ints[1]++ break } } We can simplify the if statement into if words[frequency[i][0]] = word.</description></item><item><title>Leetcode 1721</title><link>https://nathannaveen.dev/posts/leetcode-1721/</link><pubDate>Sun, 14 Mar 2021 15:57:58 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1721/</guid><description>1721. Swapping Nodes in a Linked List
The idea of this solution is pretty simple.
First, we find the length of the linked list Next, we iterate through the linked list up until the ending kth node And then we iterate through the linked list to to kth node Then, last of all, switch the value of the kth node with the value of the kth node from the end.</description></item><item><title>Leetcode 1329</title><link>https://nathannaveen.dev/posts/leetcode-1329/</link><pubDate>Sat, 13 Mar 2021 10:42:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1329/</guid><description>1329. Sort the Matrix Diagonally
The idea of this solution is kind of hard to explain so I will show it with the following images:
i = len(mat), and j = len(mat[0])
The yellow part is every where i and j will iterate
the diagonal lines are in red
Before we continue you might be confused about why we switch 2 and 1 even though i = 1 and j = 1.</description></item><item><title>Leetcode 1461</title><link>https://nathannaveen.dev/posts/leetcode-1461/</link><pubDate>Fri, 12 Mar 2021 12:03:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1461/</guid><description>1461. Check If a String Contains All Binary Codes of Size K
The idea of this solution is to make a sliding window and add all the substrings os size k to a map, if the maps length is equal to 2^k return true.
We do 2^k because we have to acount for all posibilitys of 0 and 1.
func hasAllCodes(s string, k int) bool { m := make(map[string]int) for i := 0; i &amp;lt; len(s)-k+1; i++ { m[s[i:i+k]]++ } return len(m) == twoPow(k) } func twoPow(k int) int { res := 1 for i := 0; i &amp;lt; k; i++ { res *= 2 } return res } By using bit maniplation we can simplify the code, left shifting is basicly multiplying by 2.</description></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty similar to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description></item><item><title>Leetcode 1750</title><link>https://nathannaveen.dev/posts/leetcode-1750/</link><pubDate>Tue, 09 Mar 2021 21:04:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1750/</guid><description>1750. Minimum Length of String After Deleting Similar Ends
The idea of this solution is pretty simple, so it can be shown with this image:
func minimumLength(s string) int { for len(s) &amp;gt; 1 &amp;amp;&amp;amp; s[0] == s[len(s)-1] { end := s[len(s)-1] lenS := len(s) for i := 0; i &amp;lt; lenS; i++ { if s[len(s)-1] != s[0] { s = s[:len(s)-i-1] break } } lenS = len(s) for i := 0; i &amp;lt; lenS; i++ { if s[0] !</description></item><item><title>Leetcode 1752</title><link>https://nathannaveen.dev/posts/leetcode-1752/</link><pubDate>Tue, 09 Mar 2021 21:04:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1752/</guid><description>1752. Check if Array Is Sorted and Rotated
The idea of this solution is to loop through the array, and then check whether there is a nums[i] which is greater than nums[(i+1) % len(nums)] (By the way (i+1) % len(nums) is for getting the next number) if nums[i] &amp;gt; nums[(i+1)%len(nums)] then add one to a counter called counter. Then we check whether counter is greater than or equal to 2.</description></item><item><title>Leetcode 1784</title><link>https://nathannaveen.dev/posts/leetcode-1784/</link><pubDate>Mon, 08 Mar 2021 14:31:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1784/</guid><description>1784. Check if Binary String Has at Most One Segment of Ones
The problem description is:
Given a binary string s without leading zeros, return true if s contains at most one contiguous segment of ones. Otherwise, return false.
This is kind of hard to understand, so I am going to explain it. A contiguous segment of ones looks like:
111000 100 10 1 11110000 And some of the ones that are not contiguous are:</description></item><item><title>Leetcode 1332</title><link>https://nathannaveen.dev/posts/leetcode-1332/</link><pubDate>Mon, 08 Mar 2021 09:42:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1332/</guid><description>1332. Remove Palindromic Subsequences
This problem asks us to find all the subsequences in a string called s. s only contains the letters a and b.
When we are doing this problem, the main thing to look at is that it says &amp;ldquo;subsequences,&amp;rdquo; not &amp;ldquo;substrings,&amp;rdquo; and that there are only two letters a and b.
The difference between &amp;ldquo;substrings&amp;rdquo; and &amp;ldquo;subsequences&amp;rdquo; is substrings are consecutive letters, while subsequences doesn&amp;rsquo;t have to be consecutive.</description></item><item><title>Leetcode 915</title><link>https://nathannaveen.dev/posts/leetcode-915/</link><pubDate>Mon, 08 Mar 2021 08:20:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-915/</guid><description>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index (1 indexed).
This can be shown with a picture:
func partitionDisjoint(A []int) int { max := A[0] for i := 0; i &amp;lt; len(A); i++ { shouldReturn := true if max &amp;lt; A[i] { max = A[i] } for j := i + 1; j &amp;lt; len(A); j++ { if A[j] &amp;lt; max { shouldReturn = false break } } if shouldReturn { return i + 1 } } return -1 }</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1773</title><link>https://nathannaveen.dev/posts/leetcode-1773/</link><pubDate>Sat, 06 Mar 2021 19:06:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1773/</guid><description>1773. Count Items Matching a Rule
The idea of this solution is pretty simple. We know that the array items has only 3 items. The first one is the ruleKey = &amp;quot;type&amp;quot; the next one is ruleKey = &amp;quot;color&amp;quot;, and the next one is ruleKey = &amp;quot;name&amp;quot;. We just have to set a index of each item to either 0, 1 or 2. Then just loop over each item and check whether the item[index] == ruleValue.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description></item><item><title>Leetcode 833</title><link>https://nathannaveen.dev/posts/leetcode-833/</link><pubDate>Thu, 04 Mar 2021 10:24:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-833/</guid><description>833. Find And Replace in String
func findReplaceString(S string, indexes []int, sources []string, targets []string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(S); i++ { index := 0 // this is the index that is used for indexes, sources, and targets for i2, i3 := range indexes { if i3 == i { index = i2 // we do this because the indexes are not sorted } } if index &amp;lt; len(indexes) &amp;amp;&amp;amp; i == indexes[index] { currentString := sources[index] isSubstring := true for i2 := range currentString { // checking whether the whole substring is equal if string(S[i+i2]) !</description></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description></item><item><title>Leetcode 34</title><link>https://nathannaveen.dev/posts/leetcode-34/</link><pubDate>Tue, 02 Mar 2021 11:27:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-34/</guid><description>34. Find First and Last Position of Element in Sorted Array
Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra if statment inside the loop, while the second solution checks it outside of the loop.
func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left &amp;lt; right { if nums[left] !</description></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description></item><item><title>Leetcode 647</title><link>https://nathannaveen.dev/posts/leetcode-647/</link><pubDate>Mon, 01 Mar 2021 09:27:16 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-647/</guid><description>647. Palindromic Substrings
func countSubstrings(s string) int { res := 0 for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if s[j:j+i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; isPalindromic(s[j:j+i]) { res++ } } } if isPalindromic(s) { res++ } return res } func isPalindromic(s string) bool { left, right := 0, len(s)-1 for left &amp;lt;= right { if s[left] != s[right] { return false } left++ right-- } return true }</description></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description></item><item><title>Leetcode 5</title><link>https://nathannaveen.dev/posts/leetcode-5/</link><pubDate>Sun, 28 Feb 2021 11:41:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-5/</guid><description>5. Longest Palindromic Substring
In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:
func longestPalindrome(s string) string { max := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if isPalindromic(s[j : j + i]) { max = s[j : j + i] // getting the substring } } } if isPalindromic(s) { max = s } return max } func isPalindromic(s string) bool { left, right := 0, len(s) - 1 for left &amp;lt; right { if s[left] !</description></item><item><title>Leetcode 1016</title><link>https://nathannaveen.dev/posts/leetcode-1016/</link><pubDate>Fri, 26 Feb 2021 13:58:32 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1016/</guid><description>1016. Binary String With Substrings Representing 1 To N
The idea of this solution is to loop through 1...N and then make the string by adding the bytes to a string called s. Then check if S contains the reversed string of the bytes. The string s is reversed by a helper function.
func queryString(S string, N int) bool { for i := 1; i &amp;lt;= N; i++ { s := &amp;quot;&amp;quot; n := i for n &amp;gt; 0 { if n &amp;amp; 1 == 1 { s += &amp;quot;1&amp;quot; } else { s += &amp;quot;0&amp;quot; } n &amp;gt;&amp;gt;= 1 } if !</description></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1592</title><link>https://nathannaveen.dev/posts/leetcode-1592/</link><pubDate>Thu, 25 Feb 2021 15:48:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1592/</guid><description>1592. Rearrange Spaces Between Words
The idea of this solution is pretty simple, first split text by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:
input = &amp;quot; this is a sentence &amp;quot; inbuiltSplit = [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;sentence&amp;quot;, &amp;quot;&amp;quot;] The Code:</description></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description></item><item><title>Leetcode 1768</title><link>https://nathannaveen.dev/posts/leetcode-1768/</link><pubDate>Thu, 25 Feb 2021 15:48:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.
func mergeAlternately(word1 string, word2 string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ { if i &amp;lt; len(word1) { res += string(word1[i]) } if i &amp;lt; len(word2) { res += string(word2[i]) } } return res }</description></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description></item><item><title>2021 Advent of code day 3</title><link>https://nathannaveen.dev/adventofcode/advent-of-code-day-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nathannaveen.dev/adventofcode/advent-of-code-day-3/</guid><description>Advent Of Code Day 3 2021
Part One The first solution is pretty simple, so I just brute forced it.
func oneDay3() { file, err := os.Open(&amp;#34;input3.txt&amp;#34;) if err != nil { panic(err) } defer file.Close() scanner := bufio.NewScanner(file) arr := make([]int, 12) gamma := 0 epsilon := 0 pos := 1 for scanner.Scan() { temp := scanner.Text() for i := 0; i &amp;lt; len(temp); i++ { if temp[i] == &amp;#39;1&amp;#39; { arr[i]++ } else { arr[i]-- } } } for i := len(arr) - 1; i &amp;gt;= 0; i-- { if arr[i] &amp;gt; 0 { gamma += pos } else { epsilon += pos } pos *= 2 } fmt.</description></item><item><title>2021 Advent of Code Day 8</title><link>https://nathannaveen.dev/adventofcode/advent-of-code-day-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nathannaveen.dev/adventofcode/advent-of-code-day-8/</guid><description>Day 8 Puzzle
func oneDay8() { file, err := os.Open(&amp;#34;input8.txt&amp;#34;) // opening the file if err != nil { panic(err) } defer file.Close() scanner := bufio.NewScanner(file) res := 0 for scanner.Scan() { temp := scanner.Text() // getting the line arr := strings.Split(temp, &amp;#34; | &amp;#34;) words := strings.Split(arr[1], &amp;#34; &amp;#34;) for _, s := range words { if len(s) == 2 || len(s) == 4 || len(s) == 3 || len(s) == 7 { res++ } } } fmt.</description></item><item><title>Advent of code day 9 2021</title><link>https://nathannaveen.dev/adventofcode/advent-of-code-day-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nathannaveen.dev/adventofcode/advent-of-code-day-9/</guid><description>Day 9 puzzle
Part One I think that the first part of day 9 was pretty easy, just check every values and whether it is smaller than all the adjacent values. If so add that value plus 1 to res.
func oneDay9() { input, _ := ioutil.ReadFile(&amp;#34;input9.txt&amp;#34;) var arr = strings.Split(string(input), &amp;#34;\n&amp;#34;) res := 0 i, j := 0, 0 isLow := func(y, x int) bool { // I put this function inside twoDay9() // because then I wouldn&amp;#39;t have to parse i, j, and arr which would make it really messy.</description></item></channel></rss>