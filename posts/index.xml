<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on nathan naveen</title><link>https://nathannaveen.dev/posts/</link><description>Recent content in Posts on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 07 Mar 2021 10:43:03 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin</a></p>
<p><strong>The New Distance Formula:</strong></p>
<p>The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&rsquo;t aline up when writen up in text)</p>
<p><img src="https://i.imgur.com/krhq25z.jpg" alt=""></p>
<p>This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&rsquo;t need to be square rooted. The distance not needing to be square rooted can be shown by doing an experiment, for example let us take the square root of 10 and the square root of 8, we know that the square root of 10 will allways be greater than the square root of 8. We also know that 10 will always be greater than 8. Try this with any two positive numbers. <em>Note: I said positve numbers because any square number is positive.</em></p>
<p>So now our equation for the distance is:</p>
<p><img src="https://i.imgur.com/U8tN3Zs.jpg" alt=""></p>
<p>We can simplify the equation again by taking out the x2 and the y2 because x2 and y2 will always be <code>0</code>. X2 and y2 will always be <code>0</code> because the first point is a regular point, but the second point will be <code>(0, 0)</code> because the second point will always be the origin. This can by shown by an example:</p>
<p><img src="https://i.imgur.com/sbAt4Eg.jpg" alt=""></p>
<p>So the new distance equation is:</p>
<p><img src="https://i.imgur.com/VDLMrjy.jpg" alt=""></p>
<hr>
<p><strong>The Idea Of This Solution:</strong></p>
<p>Now that we know that we know the distance formula for this problem is <code>x^2 + y^2</code> we just have to sort the matrix array.</p>
<p>The way we sort the array is we check whether the current distance is smaller than the the previous distance, then if so we switch the two points, then we move back a space, to check whether the previous value is greater than the current value. This can be show by the following example:</p>
<p><img src="https://i.imgur.com/CFPvZ2L.jpg" alt=""></p>
<p><img src="https://i.imgur.com/O4uLB9c.jpg" alt=""></p>
<p>We do nothing because <code>18 &lt; 26</code>. So we continue:</p>
<p><img src="https://i.imgur.com/n6q63xp.jpg" alt=""></p>
<p><code>26</code> is greater than <code>20</code> so we have to switch them. We also have to subtract <code>2</code> from <code>i</code>. <code>i</code> will only go back by <code>1</code> even though we subtract <code>2</code> from <code>i</code> because the for loop adds <code>1</code> to <code>i</code>.</p>
<p><img src="https://i.imgur.com/YhAlxxI.jpg" alt=""></p>
<p><code>18</code> is smaller than <code>20</code> so do nothing.</p>
<p><img src="https://i.imgur.com/KwfMZjn.jpg" alt=""></p>
<p><code>20</code> is smaller than <code>26</code> so do nothing again.</p>
<p><img src="https://i.imgur.com/fAbocNo.jpg" alt=""></p>
<p><code>26</code> is smaller than <code>130</code> so we do nothing again. Since <code>i</code> is at the end <code>points</code> is <code>[[3, 3], [-2, 4], [5, -1], [7, 9]]</code>.</p>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">kClosest</span>(<span style="color:#a6e22e">points</span> [][]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">points</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> {
            <span style="color:#a6e22e">distanceOfIMinusOne</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>])
            <span style="color:#a6e22e">distanceOfI</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>])
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">distanceOfIMinusOne</span> &gt; <span style="color:#a6e22e">distanceOfI</span> {
                <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">points</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>
            }
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">points</span>[:<span style="color:#a6e22e">k</span>]
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 1773</title><link>https://nathannaveen.dev/posts/leetcode-1773/</link><pubDate>Sat, 06 Mar 2021 19:06:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1773/</guid><description>1773. Count Items Matching a Rule
The idea of this solution is pretty simple. We know that the array items has only 3 items. The first one is the ruleKey = &amp;quot;type&amp;quot; the next one is ruleKey = &amp;quot;color&amp;quot;, and the next one is ruleKey = &amp;quot;name&amp;quot;. We just have to set a index of each item to either 0, 1 or 2. Then just loop over each item and check whether the item[index] == ruleValue.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/count-items-matching-a-rule/">1773. Count Items Matching a Rule</a></p>
<p>The idea of this solution is pretty simple. We know that the array <code>items</code> has only <code>3</code> items. The first one is the <code>ruleKey = &quot;type&quot;</code> the next one is <code>ruleKey = &quot;color&quot;</code>, and the next one is <code>ruleKey = &quot;name&quot;</code>. We just have to set a index of each item to either <code>0, 1</code> or <code>2</code>. Then just loop over each item and check whether the <code>item[index] == ruleValue</code>.</p>
<pre><code>func countMatches(items [][]string, ruleKey string, ruleValue string) int {
	res := 0
	index := 0
	if ruleKey == &quot;color&quot; {
		index = 1
	} else if ruleKey == &quot;name&quot; {
		index = 2
	}

	for _, item := range items {
		if item[index] == ruleValue {
			res++
		}
	}
	
	return res
}
</code></pre>]]></content></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/">1779. Find Nearest Point That Has the Same X or Y Coordinate</a></p>
<p><strong>What The Problem Is Asking:</strong></p>
<p>This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called <code>points</code>.</p>
<p>The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</p>
<p>Then the problem asks you to return the index of the minimum distance. If there is no point that has the same x value or the save y value <code>return -1</code>.</p>
<p>The Manhattan distance is the distance between two points by doing <code>abs(y1 - y2) + abs(x1 - x2)</code>.</p>
<p><strong>How The Solution Works:</strong></p>
<p>The main idea of this solution is that the problem asks to find the Manhattan distance of the points that have the same x or y value.</p>
<p><em>The reason this is so important can be shown using an image:</em></p>
<p>The average 2 points that don&rsquo;t have the same x value or y value can by shown by this image:</p>
<p><img src="https://i.imgur.com/9VP0fWS.jpg" alt=""></p>
<p>This is for two points that have the same x value:</p>
<p><img src="https://i.imgur.com/ppluacv.jpg" alt=""></p>
<blockquote>
<p>When the two <code>x</code> values are the same we just have to calculate the <code>y</code> part because when we subtract both the <code>x</code> parts we get <code>0</code>. This can be shown by the image above <code>(4 - 2) + (3 - 3) = 2 + 0 = 2</code>. The part <code>(4 - 2)</code> is the part that follows the <code>y</code> axis, and the part <code>(3 - 3)</code> is the <code>x</code> part.</p>
</blockquote>
<p>This is for two points that have the same y value:</p>
<p><img src="https://i.imgur.com/u4sdUZO.jpg" alt=""></p>
<blockquote>
<p>When both <code>y</code>&rsquo;s are equal then the <code>y</code> part will be equal to zero so we wont have to calculate the <code>y</code> part. This can be show by the above example, <code>(1 - 1) + (4 - 1) = 3</code>. The <code>y</code> part <code>(1 - 1) = 0</code>.</p>
</blockquote>
<p>So, when a point in the array has a <code>x</code> value equal to the given <code>x</code> value just calculate the <code>y</code> part. And when the <code>y</code> part of a point in the array is eqal to the given <code>y</code> value just calculate the <code>x</code> part.</p>
<p><strong>Extra Notes:</strong></p>
<p>This solution doesn&rsquo;t use a build in <code>math.Abs()</code> function because it would take longer to process than using a self made absolute function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">nearestValidPoint</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">points</span> [][]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">minimum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100000000</span> <span style="color:#75715e">// the max value has to be 10^4 * 10^4 = 10^8
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 10^8 = 100,000,000
</span><span style="color:#75715e"></span>    
    <span style="color:#a6e22e">resIndex</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">point</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">points</span> {
        <span style="color:#a6e22e">manhattanYAbs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">absoluteValue</span>(<span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>)
        <span style="color:#a6e22e">manhattanXAbs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">absoluteValue</span>(<span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#a6e22e">x</span>)
        
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">manhattanYAbs</span> &lt; <span style="color:#a6e22e">minimum</span> {
            <span style="color:#a6e22e">minimum</span> = <span style="color:#a6e22e">manhattanYAbs</span>
            <span style="color:#a6e22e">resIndex</span> = <span style="color:#a6e22e">i</span>
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">point</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">manhattanXAbs</span> &lt; <span style="color:#a6e22e">minimum</span> {
            <span style="color:#a6e22e">minimum</span> = <span style="color:#a6e22e">manhattanXAbs</span>
            <span style="color:#a6e22e">resIndex</span> = <span style="color:#a6e22e">i</span>
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">resIndex</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">absoluteValue</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">0</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">n</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/rectangle-area/">223. Rectangle Area</a></p>
<p>The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.</p>
<p>If you don&rsquo;t understand the <code>ABCDRectangle</code> and the <code>EFGHRectangle</code> then look at the following images:</p>
<p><strong>We can have the example:</strong></p>
<p><img src="https://i.imgur.com/St26i3w.jpg" alt=""></p>
<p>Let us start of with the <code>ABCDRectangle</code>:</p>
<p><img src="https://i.imgur.com/Td0G3vB.jpg" alt=""></p>
<p>When we do the equation <code>(D - B) * (C - A)</code> we are basicly doing <code>width * length</code>. The <code>width</code> is <code>(D - B)</code>. This can be show by using the image above where <code>A = -4, B = 2, C = 4, D = 5</code>. When we do <code>(D - B)</code> it equal <code>(5 - 2) = 3</code>. So we know that the rectangle has a width of <code>3</code>.</p>
<p>Now the <code>length</code> is going to be <code>(C - A)</code> which is equal to <code>(4 - (-4)) = (4 + 4) = 8</code>. Since we already know the width, and we know the height we can put them together. <code>width * height = 3 * 8 = 24</code>. The area of this rectangle is <code>24</code>.</p>
<p>Next let us do <code>EFGHRectangle</code>:</p>
<p><img src="https://i.imgur.com/D1uXC5Q.jpg" alt=""></p>
<p>This is pretty much the same as the <code>ABCDRectangle</code>. The equation <code>(H - F) * (G - E) = width * length</code>. As you can see in the image <code>E = 3, F = -2, G = 7, H = 8</code>. When we input the numbers in for the variables we get <code>(H - F) = (8 - (-2)) = (8 + 2) = 10</code>, so our width is <code>10</code>.</p>
<p>We can do the same thing but with length, The part of the equation that is for length is <code>(G - E)</code> when we input the numbers in for the variables we get <code>(7 - 3) = 4</code>. So we have a length of <code>4</code>.</p>
<p>When we multiply our width and our length together we get <code>10 * 4 = 40</code> so we have an area of <code>40</code>.</p>
<p>When we put both rectangles together we get:</p>
<p>Since we have an area of <code>24</code> for <code>ABCDRectangle</code> and an area of <code>40</code> for <code>EFGHRectangle</code>, when we add them up we get an area of <code>64</code>. The only problem is we have some over lap (Which I have colored purple in the image). We need to subtract the overlap from the total area.</p>
<p><img src="https://i.imgur.com/GBuwLLv.jpg" alt=""></p>
<p>The overlap is a rectangle as well so we know that it has two part, <code>length</code> and <code>width</code>. The idea of this part is the find the length and the width and then multiply them together and subtract that product from the total area.</p>
<p>I made four variables to find out where the overlap is, <code>left, right, up , down</code>. Left is the max of <code>A</code> and <code>E</code>. In this example the max is <code>E</code>, and it is the left side of the rectangle. The right is the min of <code>G</code> and <code>C</code>. In this example <code>C</code> is the minimum. Up is the minumum of <code>D</code> and <code>H</code>. <code>D</code> is smaller than <code>H</code> so up is <code>D</code>. Down is the max of <code>F</code> and <code>B</code>. <code>B</code> is greater than <code>F</code> so down is <code>B</code>.</p>
<p>Since we know that <code>left = E, right = C, up = D, down = B</code>, also we know that <code>A = -4, B = 2, C = 4, D = 5, E = 3, F = -2, G = 7, H = 8</code> so we can put those values in for their variables. <code>left = 3, right = 4, up = 5, down = 2</code>.</p>
<p>Before we even make the over lap rectangle we have to check whether there is a overlap rectangle. So we do <code>right &gt; left</code> because that means the right pointer is greater than the left pointer, and that there is not a negative area. Next it checks whether <code>up &gt; down</code> for the same reason that there is no negative area.</p>
<p>Now we can make a rectangle using these values and then subtract that rectangle from the total area. The length will be <code>(right - left) = (4 - 3) = 1</code>, and the width will be <code>(up - down) = (5 - 2) = 3</code>. Since we know that the area of a rectangle is <code>length * width</code> we can do <code>1 * 3 = 3</code>.</p>
<p>Now we can just subtract the area of the overlaping rectangle from the total area which is <code>64 - 3 = 61</code>. Now we know that our answer is 61.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">computeArea</span>(<span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">E</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">F</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">G</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">H</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">ABCDRectangle</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">D</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">B</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">C</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">A</span>) <span style="color:#75715e">// the first square
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">EFGHRectangle</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">H</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">F</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">G</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">E</span>) <span style="color:#75715e">// the second square
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ABCDRectangle</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">EFGHRectangle</span>

    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">E</span>), <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">G</span>, <span style="color:#a6e22e">C</span>)
    <span style="color:#a6e22e">up</span>, <span style="color:#a6e22e">down</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">H</span>), <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">F</span>, <span style="color:#a6e22e">B</span>)

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &gt; <span style="color:#a6e22e">left</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">up</span> &gt; <span style="color:#a6e22e">down</span> {
        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">-=</span> (<span style="color:#a6e22e">right</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">left</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">up</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">down</span>) <span style="color:#75715e">// overlap
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>}
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">min</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span> {<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>}
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/smallest-range-i/">908. Smallest Range I</a></p>
<pre><code>func smallestRangeI(A []int, K int) int {
	max, min := A[0], A[0]

	for _, i := range A {
		if i &gt; max {max = i}
		if i &lt; min {min = i}
	}
	if max-min-2*K &gt; 0 {
		return max - min - 2 * K
	}
	return 0
} 
</code></pre>]]></content></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></p>
<p>The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size <code>[number of different elements][2]</code>. Then sort the array, and then add the values to a regular array of size <code>K</code>.</p>
<hr>
<p>The matrix array has a size of <code>[number of different elemtnets][2]</code> because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it. The array is put in the format <code>[frequency][number]</code>.</p>
<hr>
<p>This array is sorted by frequency first and then the number. When we sort, we check whether the frequency of the last number is smaller than the frequency of the current number. If so, then switch the two items, and subtract <code>2</code> from the counter.</p>
<hr>
<p><strong>The sort can be shown using these images:</strong></p>
<p><img src="https://i.imgur.com/fcBnUG3.jpg" alt=""></p>
<p><img src="https://i.imgur.com/GQeJ16L.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] The frequency of the previous index is smaller than the current index, so switch them and subtract <code>2</code> from the index.</p>
</blockquote>
<p><img src="https://i.imgur.com/CyCoaX4.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] Even though we subtract <code>2</code> from the index, we only go back <code>1</code> place because we add <code>1</code> to the index with the for loop.</p>
<p>Since the index is at zero, which is smaller than <code>1</code>, we don&rsquo;t do anything. We can&rsquo;t check whether the current index&rsquo;s frequency is smaller than the previous index&rsquo;s frequency because there is no previous index.</p>
</blockquote>
<p><img src="https://i.imgur.com/KYCWTms.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] We don&rsquo;t do anything because the frequency of the previous number is greater than the current frequency.</p>
</blockquote>
<p><img src="https://i.imgur.com/zRoioun.jpg" alt=""></p>
<blockquote>
<p>[color=#0000ff] We still don&rsquo;t do anything because the previous frequency is greater than the current frequency. Since this is the last index, we know that <code>arr = [[4, 1], [2, 3], [1, 2]]</code> with the greatest frequency at the beginning and the smallest frequencies at the end.</p>
</blockquote>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">topKFrequent</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{}

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
        <span style="color:#a6e22e">contains</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
        
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ints</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">arr</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ints</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">num</span> {
                <span style="color:#a6e22e">ints</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">++</span>
                <span style="color:#a6e22e">contains</span> = <span style="color:#66d9ef">true</span>
                <span style="color:#66d9ef">break</span>
            }
        }
        
        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">contains</span> {
            <span style="color:#a6e22e">arr</span> = append(<span style="color:#a6e22e">arr</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">num</span>})
        }
    }

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">arr</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] &lt; <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">0</span>] {
            <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>]
            <span style="color:#a6e22e">i</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">2</span>
        }
    }

    <span style="color:#a6e22e">nums</span> = []<span style="color:#66d9ef">int</span>{}
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">nums</span> = append(<span style="color:#a6e22e">nums</span>, <span style="color:#a6e22e">arr</span>[<span style="color:#a6e22e">i</span>][<span style="color:#ae81ff">1</span>])
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nums</span>
}
</code></pre></div>]]></content></item><item><title>Leetcode 833</title><link>https://nathannaveen.dev/posts/leetcode-833/</link><pubDate>Thu, 04 Mar 2021 10:24:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-833/</guid><description>833. Find And Replace in String
func findReplaceString(S string, indexes []int, sources []string, targets []string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(S); i++ { index := 0 // this is the index that is used for indexes, sources, and targets for i2, i3 := range indexes { if i3 == i { index = i2 // we do this because the indexes are not sorted } } if index &amp;lt; len(indexes) &amp;amp;&amp;amp; i == indexes[index] { currentString := sources[index] isSubstring := true for i2 := range currentString { // checking whether the whole substring is equal if string(S[i+i2]) !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-and-replace-in-string/">833. Find And Replace in String</a></p>
<pre><code>func findReplaceString(S string, indexes []int, sources []string, targets []string) string {
	res := &quot;&quot;

	for i := 0; i &lt; len(S); i++ {
		index := 0 // this is the index that is used for indexes, sources, and targets

		for i2, i3 := range indexes {
			if i3 == i {
				index = i2 // we do this because the indexes are not sorted
			}
		}

		if index &lt; len(indexes) &amp;&amp; i == indexes[index] {
			currentString := sources[index]
			isSubstring := true
			for i2 := range currentString { // checking whether the whole substring is equal
				if string(S[i+i2]) != string(currentString[i2]) { 
					isSubstring = false
					break
				}
			}

			if isSubstring {
				res += targets[index]
				i += len(currentString) - 1 // we have to add to i because we dont want to repeat characters
			} else {
				res += string(S[i]) // if there is not a whole substring just add the character
			}
			index++
		} else {
			res += string(S[i]) // if there is no index in indexes that works for the current index
		}
	}

	return res
}

</code></pre>]]></content></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/sort-array-by-increasing-frequency/">1636. Sort Array by Increasing Frequency</a></p>
<p>The main idea of both the solutions is to add all the numbers to a matrix of lengths <code>[len(nums)][2]</code> and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to <code>nums</code> and return <code>nums</code>.</p>
<p><strong>This is the sort:</strong></p>
<pre><code>for i := 1; i &lt; len(arr); i++ {
    if i &gt;= 1 &amp;&amp; ((arr[i-1][0] &gt; arr[i][0]) || 
    (arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1])) {
        arr[i], arr[i-1] = arr[i-1], arr[i]
        i -= 2
    }
}
</code></pre><p>The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number. This is show like this in the code: <code>((arr[i-1][0] &gt; arr[i][0])</code>. Or it checks whether the frequency is the same and whether the current number is greater than the number before the current number, this is show in the code as this: <code>arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1]</code>. If either of these things is true, then switch the current and number before the current element and subtracts <code>2</code> from <code>i</code>. We subtract <code>2</code> from <code>i</code> to move back if we have to switch the next current and number before the current numbers. And we subtract <code>2</code>, not <code>1</code> because the loops <code>i++</code> cancel out one of the subtracts. Since we have an <code>i -= 2</code>, we have to check whether <code>i &gt;= 1</code> because if we don&rsquo;t and <code>i == 0</code>, we would have an out-of-bounds exception.</p>
<p>If you dont understand the explaination look at these images:</p>
<p><img src="https://i.imgur.com/2zecuOJ.jpg" alt="">
<img src="https://i.imgur.com/ZoBc0N6.jpg" alt="">
<img src="https://i.imgur.com/FFnnfj8.jpg" alt=""></p>
<p>The second code has better space complexity because, in the first solution, we use a <code>map</code> of size <code>len(nums)</code> and an <code>array</code> of size <code>[len(nums)][2]</code>. In the second solution, we just use an <code>array</code> of size <code>[len(nums)][2]</code>.</p>
<p><strong>Code One:</strong></p>
<pre><code>func frequencySort(nums []int) []int {
    m := make(map[int]int)
    arr := [][]int{}
    counter := 0

    for _, num := range nums {
        m[num]++
    }
    for i, i2 := range m {
        arr = append(arr, []int{i2, i})
    }

    for i := 1; i &lt; len(arr); i++ {
        if i &gt;= 1 &amp;&amp; ((arr[i-1][0] &gt; arr[i][0]) || 
        (arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1])) {
            arr[i], arr[i-1] = arr[i-1], arr[i]
            i -= 2
        }
    }

    for i := 0; i &lt; len(arr); i++ {
        for j := 0; j &lt; arr[i][0]; j++ {
            nums[counter] = arr[i][1]
            counter++
        }
    }

    return nums
}
</code></pre><p><strong>Code Two:</strong></p>
<pre><code>func frequencySort(nums []int) []int {
    arr := [][]int{}
    counter := 0

    for _, num := range nums {
        contains := false

        for _, ints := range arr {
            if ints[1] == num {
                ints[0]++
                contains = true
                break
            }
        }

        if !contains {
            arr = append(arr, []int{1, num})
        }
    }

    for i := 1; i &lt; len(arr); i++ {
        if i &gt;= 1 &amp;&amp; ((arr[i-1][0] &gt; arr[i][0]) ||
        (arr[i-1][0] == arr[i][0] &amp;&amp; arr[i-1][1] &lt; arr[i][1])) {
            arr[i], arr[i-1] = arr[i-1], arr[i]
            i -= 2
        }
    }

    for i := 0; i &lt; len(arr); i++ {
        for j := 0; j &lt; arr[i][0]; j++ {
            nums[counter] = arr[i][1]
            counter++
        }
    }

    return nums
}
</code></pre>]]></content></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-the-distance-value-between-two-arrays/">1385. Find the Distance Value Between Two Arrays</a></p>
<p>The idea of this solution is to iterate through <code>arr1</code> and then inside each iteration iterate through <code>arr2</code>. If the absolute value of <code>arr1[i] - arr2[j]</code> is smaller than or equal to <code>d</code>, we know that <code>arr1[i]</code> can&rsquo;t be added to the resulting counter, so we can just <code>break</code> from the loop.</p>
<p>There is a abs function because <code>math.Abs</code> takes longer. When using <code>math.Abs</code> we have to make <code>float64(arr1[i] - arr2[j])</code>, and then make the <code>int(math.Abs)</code>.</p>
<pre><code>func findTheDistanceValue(arr1 []int, arr2 []int, d int) int {
    res := 0
    shouldAdd := true
    for i := 0; i &lt; len(arr1); i++ {
        for j := 0; j &lt; len(arr2); j++ {
            if abs(arr1[i]-arr2[j]) &lt;= d {
                shouldAdd = false
                break
            }
        }
        if shouldAdd {res++} else {shouldAdd = true}
    }
    return res
}

func abs(n int) int {
    if n &lt; 0 {
        return -n
    }
    return n
}
</code></pre>]]></content></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/set-mismatch/">645. Set Mismatch</a></p>
<p>The idea of this solution is to add every number in the array <code>nums</code> to another array called <code>temp</code>. Next we go through the array temp and check whether the number of a certain number is equal to <code>2</code>, if it is then we know that it is the repeated number. If it is not <code>2</code> but it is <code>0</code> we know that it is the skiped number. We know that there is always a duplicate number, so if we found the duplicate but not the value that is skiped we return the duplicate and the duplicate plus one, because if the skiped is not inside the array we have to return the next number.</p>
<p><code>temp</code> has <code>10001</code> values because the constraints of the problem say <code>2 &lt;= nums.length &lt;= 10^4, 1 &lt;= nums[i] &lt;= 10^4</code>, since <code>10^4</code> equals <code>10000</code> and the constraints say <code>nums.length &lt;= 10^4</code> we have to do <code>10^4 + 1 = 10000 + 1 = 10001</code>.</p>
<pre><code>func findErrorNums(nums []int) []int {
    sort.Ints(nums)
    double, skip := 0, 0
    temp := make([]int, 10001)

    for _, num := range nums {
        temp[num]++
    }

    for i, value := range temp {
        if value == 2 {
            double = i
            if skip != 0 {return []int{double, skip}}
        } else if value == 0 {
            skip = i
            if double != 0 {return []int{double, skip}}
        }
    }

    return []int{double, double + 1}
}
</code></pre>]]></content></item><item><title>Leetcode 34</title><link>https://nathannaveen.dev/posts/leetcode-34/</link><pubDate>Tue, 02 Mar 2021 11:27:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-34/</guid><description>34. Find First and Last Position of Element in Sorted Array
Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra if statment inside the loop, while the second solution checks it outside of the loop.
func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left &amp;lt; right { if nums[left] !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></p>
<p>Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra <code>if</code> statment inside the loop, while the second solution checks it outside of the loop.</p>
<pre><code>func searchRange(nums []int, target int) []int {
    left := 0
    right := len(nums) - 1

    for left &lt; right {
        if nums[left] != target {
            left++
        }
        if nums[right] != target {
            right--
        }
        if nums[left] == target &amp;&amp; nums[right] == target {
            return []int{left, right}
        }
    }

    if len(nums) &gt; 0 &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target {
        return []int{left, right}
    }

    return []int{-1, -1}
}
</code></pre><pre><code>func searchRange(nums []int, target int) []int {
    left := 0
    right := len(nums) - 1

    for (left &lt; right) &amp;&amp; (nums[left] != target || nums[right] != target) {
        if nums[left] != target {
            left++
        }
        if nums[right] != target {
            right--
        }
    }

    if len(nums) &gt; 0 &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target {
        return []int{left, right}
    }

    return []int{-1, -1}
}
</code></pre>]]></content></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a></p>
<p>The idea of this solution is pretty simple, first append all the <code>nums2</code> values to <code>nums1</code>. Then sort <code>nums1</code>. If there are a even number of values then the median is the middle two numbers added together and divided by <code>2</code>. An example could be:</p>
<p><code>input: nums1 = [1,2], nums2 = [3,4]</code>
<code>expected output: 2.5</code></p>
<p>When the two arrays are combined the new array would be <code>[1, 2, 3, 4]</code> and the two middle numbers are <code>2</code>, and <code>3</code>. When <code>2</code> and <code>3</code> are added together we get <code>5</code>, and <code>5</code> divided by <code>2</code> is <code>2.5</code>.</p>
<p>If the number of values of <code>nums1</code> is odd, the median is the middle number.</p>
<pre><code>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    nums1 = append(nums1, nums2...)
    sort.Ints(nums1)

    if len(nums1) % 2 == 0 {
        return float64(nums1[len(nums1) / 2 - 1] + nums1[len(nums1) / 2]) / 2
    } else {
        return float64(nums1[len(nums1)/2])
    }
}
</code></pre>]]></content></item><item><title>Leetcode 647</title><link>https://nathannaveen.dev/posts/leetcode-647/</link><pubDate>Mon, 01 Mar 2021 09:27:16 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-647/</guid><description>647. Palindromic Substrings
func countSubstrings(s string) int { res := 0 for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if s[j:j+i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; isPalindromic(s[j:j+i]) { res++ } } } if isPalindromic(s) { res++ } return res } func isPalindromic(s string) bool { left, right := 0, len(s)-1 for left &amp;lt;= right { if s[left] != s[right] { return false } left++ right-- } return true }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a></p>
<pre><code>func countSubstrings(s string) int {
    res := 0
    for i := 0; i &lt; len(s); i++ {
        for j := 0; j &lt;= len(s)-i; j++ {
            if s[j:j+i] != &quot;&quot; &amp;&amp; isPalindromic(s[j:j+i]) {
                res++
            }
        }
    }
    if isPalindromic(s) {
        res++
    }
    return res
}

func isPalindromic(s string) bool {
    left, right := 0, len(s)-1

    for left &lt;= right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
</code></pre>]]></content></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/repeated-substring-pattern/">459. Repeated Substring Pattern</a></p>
<p>The idea of this solution is any substring that is repeated throughout the string <code>s</code> has to start at the <code>0</code>&lsquo;th index and end at another index, such as the <code>3</code>&lsquo;ed. This can be shown by using a image.</p>
<p><img src="https://i.imgur.com/JB4X253.jpg" alt=""></p>
<blockquote>
<p>In both the examples the substrings that are repeated are green.</p>
<p>In the first example the substring <code>abc</code> starts at the <code>0</code>&lsquo;th index and ends at the <code>2</code>&rsquo;d index.</p>
<p>In the next example the substring is <code>Tacos</code> it starts at the <code>0</code>&lsquo;th index and ends at the <code>4</code>&lsquo;th index</p>
</blockquote>
<p>If you have noticed in both the examples the repeated substring has to start at the <code>0</code>&lsquo;th index and has to end at a following index.</p>
<p>The way my code checks whether it is a substring that repeats through out is it adds that substring to a empty string as many times as it fits in the string. Then it checks whether the new string is equal to <code>s</code>. If it is then <code>return true</code>. If it is never equal then <code>return false</code>.</p>
<pre><code>func repeatedSubstringPattern(s string) bool {
	for i := 0; i &lt; len(s); i++ {
		end := len(s)
		str := &quot;&quot;
		if i != 0 {
			end = len(s) / i
		}
		for j := 0; j &lt; end; j++ {
			str += s[0:i]
		}
		if str == s {
			return true
		}
	}
	return false
}
</code></pre>]]></content></item><item><title>Leetcode 5</title><link>https://nathannaveen.dev/posts/leetcode-5/</link><pubDate>Sun, 28 Feb 2021 11:41:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-5/</guid><description>5. Longest Palindromic Substring
In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:
func longestPalindrome(s string) string { max := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if isPalindromic(s[j : j + i]) { max = s[j : j + i] // getting the substring } } } if isPalindromic(s) { max = s } return max } func isPalindromic(s string) bool { left, right := 0, len(s) - 1 for left &amp;lt; right { if s[left] !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p>
<p>In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:</p>
<p><img src="https://i.imgur.com/k9YUTYG.jpg" alt=""></p>
<pre><code>func longestPalindrome(s string) string {
	max := &quot;&quot;
	for i := 0; i &lt; len(s); i++ {
		for j := 0; j &lt;= len(s)-i; j++ {
			if isPalindromic(s[j : j + i]) {
				max = s[j : j + i] // getting the substring
			}
		}
	}
	if isPalindromic(s) {
		max = s
	}
	return max
}

func isPalindromic(s string) bool {
	left, right := 0, len(s) - 1

	for left &lt; right {
		if s[left] != s[right] {
			return false
		}
		left++
		right--
	}
	return true
}
</code></pre>]]></content></item><item><title>Leetcode 1016</title><link>https://nathannaveen.dev/posts/leetcode-1016/</link><pubDate>Fri, 26 Feb 2021 13:58:32 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1016/</guid><description>1016. Binary String With Substrings Representing 1 To N
The idea of this solution is to loop through 1...N and then make the string by adding the bytes to a string called s. Then check if S contains the reversed string of the bytes. The string s is reversed by a helper function.
func queryString(S string, N int) bool { for i := 1; i &amp;lt;= N; i++ { s := &amp;quot;&amp;quot; n := i for n &amp;gt; 0 { if n &amp;amp; 1 == 1 { s += &amp;quot;1&amp;quot; } else { s += &amp;quot;0&amp;quot; } n &amp;gt;&amp;gt;= 1 } if !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/">1016. Binary String With Substrings Representing 1 To N</a></p>
<p>The idea of this solution is to loop through <code>1...N</code> and then make the string by adding the bytes to a string called <code>s</code>. Then check if <code>S</code> contains the reversed string of the bytes. The string <code>s</code> is reversed by a helper function.</p>
<pre><code>func queryString(S string, N int) bool {
    for i := 1; i &lt;= N; i++ {
        s := &quot;&quot;
        n := i

        for n &gt; 0 {
            if n &amp; 1 == 1 {
                s += &quot;1&quot;
            } else {
                s += &quot;0&quot;
            }
            n &gt;&gt;= 1
        }
        if !strings.Contains(S, reverse(s)) {
            return false
        }
    }
    return true
}

func reverse(s string) string {
    res := &quot;&quot;

    for _, i := range s {
        res = string(i) + res
    }
    return res
}
</code></pre><p>This solution is pretty much the same as the first solution but this solution doesn&rsquo;t use a outside function to reverse.</p>
<pre><code>func queryString(S string, N int) bool {
    for i := 1; i &lt;= N; i++ {
        s := &quot;&quot;
        n := i

        for n &gt; 0 {
            if n&amp;1 == 1 {
                s = &quot;1&quot; + s
            } else {
                s = &quot;0&quot; + s
            }
            n &gt;&gt;= 1
        }
        if !strings.Contains(S, s) {
            return false
        }
    }
    return true
}
</code></pre>]]></content></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description><content type="html"><![CDATA[<p>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image</p>
<p><img src="https://i.imgur.com/ovNR5Oy.jpg" alt=""></p>
<pre><code>func validateStackSequences(pushed []int, popped []int) bool {
    stack := []int{}
    popCounter := 0
    for i := 0; i &lt; len(pushed); i++ {
        stack = append(stack, pushed[i])
        for len(stack) != 0 &amp;&amp; popped[popCounter] == stack[len(stack)-1] {
            stack = stack[:len(stack)-1]
            popCounter++
            if popCounter == len(popped) {
                break
            }
        }
    }

    return len(stack) == 0
}
</code></pre>]]></content></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a></p>
<p>The idea of this solution is to add all the numbers to a map and then check whether the map doesn&rsquo;t contain a number. If it doesn&rsquo;t contain then add it to the array <code>arr</code>.</p>
<p>We return the array from the first position to the end because when we make the array it comes out with a <code>0</code> at the zeroth index. For example a input array could be <code>[4,3,2,7,8,2,3,1]</code>. If we just returned <code>arr</code> then we would get <code>[0, 5, 6]</code> instead of <code>[5, 6]</code>. This can also be fixed by making <code>i</code> in the second loop start at <code>1</code> instead of <code>0</code>.</p>
<pre><code>func findDisappearedNumbers(nums []int) []int {

    m := make(map[int]int)
    arr := []int{}

    for _, i := range nums {
        m[i]++
    }

    for i := 0; i &lt;= len(nums); i++ {
        if _, ok := m[i]; !ok {
            arr = append(arr, i)
        }
    }
    return arr[1:]
}
</code></pre>]]></content></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description><content type="html"><![CDATA[<p>The idea of this solution is to first make the input string lowercase, and then add <code>1</code> to an integer array at the index of every letter, <code>a = 0, b = 1, c = 2...</code>. First we add to the array called <code>first</code>, then starting at a certain index start adding it to <code>second</code>.</p>
<p>After that, add the number of vowel that have occured. The code does this by doing</p>
<pre><code>firstCounter += first[0] + first[4] + first[8] + first[14] + first[20]
secondCounter += second[0] + second[4] + second[8] + second[14] + second[20]
</code></pre><p>You might be wondering why the code is adding from <code>first</code> and <code>second</code> at the indices <code>0, 4, 8, 14, 20</code>. It is because the ascii values of <code>'a', 'e', 'i', 'o', 'u'</code> are <code>97, 101, 105, 111, 117</code>, and when they get the indices of <code>a = 0, b = 1, c = 2...</code> it is bascily subtracting <code>97</code> from each of them, so <code>97 - 97 = 0, 101 - 97 = 4, 105 - 97 = 8, 111 - 97 = 14, 117 - 97 = 20</code>.</p>
<p>All of this can be show with a example:</p>
<pre><code>input = &quot;TacosAreCool&quot;
output = true
</code></pre><p>First off we have to make the input lower case so it becomes <code>&quot;tacosarecool&quot;</code>.</p>
<p>Next we can add all the characters from to their appropriate arrays.</p>
<p><img src="https://i.imgur.com/kYBK5as.jpg" alt=""></p>
<p>You might be wondering why it says <code>tacosa</code> and <code>recool</code>. The front part of the word is <code>tacosa</code> and the back part is <code>recool</code> when the length of the string is divided by two, <code>len(tacosa) == 6</code> and <code>len(recool) == 6</code>. combine they make <code>tacosarecool</code>.</p>
<p>Then we need to add all the vowels together.</p>
<p><img src="https://i.imgur.com/DEf68sC.jpg" alt=""></p>
<p>The number of vowels for <code>tacosa</code> is <code>3</code> because there are two <code>a</code>&rsquo;s and one <code>o</code>. The number of vowels for <code>recool</code> is <code>3</code> as well, because there is one <code>e</code> and two <code>o</code>&rsquo;s.</p>
<p>Since both <code>tacosa</code> and <code>recool</code> both have the same amount of vowels we return <code>true</code>.</p>
<pre><code>func halvesAreAlike(s string) bool {
    first, second := make([]int, 26), make([]int, 26)
    firstCounter, secondCounter := 0, 0
    s = strings.ToLower(s)
    for i, i2 := range s {
        if i &lt; len(s)/2 {
            first[int(i2-'a')]++
        } else {
            second[int(i2-'a')]++
        }
    }

    firstCounter += first[0] + first[4] + first[8] + first[14] + first[20]
    secondCounter += second[0] + second[4] + second[8] + second[14] + second[20]

    return firstCounter == secondCounter
}
</code></pre>]]></content></item><item><title>Leetcode 1592</title><link>https://nathannaveen.dev/posts/leetcode-1592/</link><pubDate>Thu, 25 Feb 2021 15:48:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1592/</guid><description>1592. Rearrange Spaces Between Words
The idea of this solution is pretty simple, first split text by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:
input = &amp;quot; this is a sentence &amp;quot; inbuiltSplit = [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;sentence&amp;quot;, &amp;quot;&amp;quot;] The Code:</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/rearrange-spaces-between-words/">1592. Rearrange Spaces Between Words</a></p>
<p>The idea of this solution is pretty simple, first split <code>text</code> by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:</p>
<pre><code>input = &quot;  this   is  a sentence &quot;

inbuiltSplit = [&quot;&quot;, &quot;&quot;, &quot;this&quot;, &quot;&quot;, &quot;&quot;, &quot;is&quot;, &quot;&quot;, &quot;a&quot;, &quot;sentence&quot;, &quot;&quot;]
</code></pre><p><strong>The Code:</strong></p>
<pre><code>func reorderSpaces(text string) string {
    spaceCounter := 0
    arr := []string{}
    str := &quot;&quot;
    res := &quot;&quot;
    for _, i := range text {
        if i == ' ' {
            if str != &quot;&quot; {
                arr = append(arr, str)
            }
            spaceCounter++
            str = &quot;&quot;
        } else {
            str += string(i)
        }
    }
    if str != &quot;&quot; {
        arr = append(arr, str)
    }
    space := &quot;&quot;

    if len(arr)-1 &gt; 0 {
        for i := 0; i &lt; spaceCounter/(len(arr)-1); i++ {
            space += &quot; &quot;
        }
        for i := 0; i &lt; len(arr)-1; i++ {
            res += arr[i] + space
        }
        res += arr[len(arr)-1]
        for i := 0; i &lt; spaceCounter%(len(arr)-1); i++ {
            res += &quot; &quot;
        }
    } else {
        for i := 0; i &lt; spaceCounter; i++ {
            space += &quot; &quot;
        }
        res = strings.Trim(text, space) + space
    }
    return res
}
</code></pre>]]></content></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree">501. Find Mode in Binary Search Tree</a></p>
<p>The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.</p>
<pre><code>func findMode(root *TreeNode) []int {
    max := 0
    m := make(map[int]int)
    res := []int{}
    stack := []*TreeNode{}
    stack = append(stack, root)

    for len(stack) != 0 {
        pop := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        if pop != nil {
            m[pop.Val]++
            stack = append(stack, pop.Left, pop.Right)
        }
    }

    for i, i2 := range m {
        if i2 &gt; max {
            res = []int{i}
            max = i2
        } else if i2 == max {
            res = append(res, i)
        }
    }
    return res
}
</code></pre>]]></content></item><item><title>Leetcode 1768</title><link>https://nathannaveen.dev/posts/leetcode-1768/</link><pubDate>Thu, 25 Feb 2021 15:48:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.
func mergeAlternately(word1 string, word2 string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ { if i &amp;lt; len(word1) { res += string(word1[i]) } if i &amp;lt; len(word2) { res += string(word2[i]) } } return res }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-strings-alternately/">1768. Merge Strings Alternately</a></p>
<p>The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.</p>
<pre><code>func mergeAlternately(word1 string, word2 string) string {
    res := &quot;&quot;

    for i := 0; i &lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ {
        if i &lt; len(word1) {
            res += string(word1[i])
        }
        if i &lt; len(word2) {
            res += string(word2[i])
        }
    }

    return res
}
</code></pre>]]></content></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/">Divide array in sets of k consecutive numbers</a></p>
<p>The idea of this solution is to loop over the <code>nums</code> array until all the values are <code>-1</code>. The reason they all will become negative one is, whenever a item is used the value will become <code>-1</code> so the code knows to not use that number again.</p>
<p><strong>If you didn&rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures:</strong>
<em>By the way sorry if my handwriting is messy</em></p>
<pre><code>input = [1, 2, 4, 3, 4, 5, 6, 3], k = 4
expected output = true
</code></pre><p>This is for getting the first consecutive sequence:
<img src="https://assets.leetcode.com/users/images/cfc0f0b7-8ffc-4ab0-8b83-143691f75526_1614179878.874795.png" alt="image"></p>
<p>And the second consecutive sequence:
<img src="https://assets.leetcode.com/users/images/eb4d3251-f7a8-4fe4-a3d2-ee89a0cc4e42_1614180843.1899865.png" alt="image"></p>
<p>Since we found two consecutive sequences we can return <code>true</code>.</p>
<hr>
<pre><code>func isPossibleDivide(nums []int, k int) bool {
	if len(nums)%k != 0 {
		return false
	}
	sort.Ints(nums)
	onlyNegetiveOnes := false

	for !onlyNegetiveOnes {
		onlyNegetiveOnes = true
		n := -1
		counter := 0
		for i := 0; i &lt; len(nums); i++ {
			if nums[i] != -1 {
				onlyNegetiveOnes = false
				if (n == -1) || (counter != k &amp;&amp; nums[i] == n+1) {
					n = nums[i]
					nums[i] = -1
					counter++
				} else if counter == k {
					break
				}
			}
		}
		if counter != k &amp;&amp; counter != 0 {
			return false
		}
	}
	return true
}
</code></pre>]]></content></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/">1566. Detect Pattern of Length M Repeated K or More Times</a>
The idea of this can be show by this image</p>
<p><img src="https://i.imgur.com/XEPQ2YV.jpg" alt=""></p>
<pre><code>func containsPattern(arr []int, m int, k int) bool {
    counter := 0

    for i := 0; i &lt; len(arr) - m; i++ {
        if arr[i] != arr[i+m] {
            counter = 0
        } else {
            counter++
        }

        if counter == (k-1)*m {
            return true
        }
    }

    return false
}
</code></pre>]]></content></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/largest-perimeter-triangle">976. Largest Perimeter Triangle</a></p>
<p>The idea of this solution is to sort the array and then keep on checking the largest three side lengths.</p>
<p>In the problem it asks us to &ldquo;return the largest perimeter of a triangle with non-zero area.&rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</p>
<p><img src="https://i.imgur.com/YOk3LWq.jpg" alt="">
<em>The triangle above is a proper triangle with an area greater than zero and we know that because the two smaller lengths, <code>5</code> and <code>5</code> added together is <code>10 &gt; 7</code>.</em>
<img src="https://i.imgur.com/HlspeLO.jpg" alt="">
<em>In the image above we can see that this is not a proper triangle because the area is zero. We know that this is not a proper triangle because the two smaller sides lengths are <code>4</code> and <code>3</code>. Four plus three is <code>7</code> and <code>7</code> is the length of the greatest triangle. So we don&rsquo;t have a triangle.</em></p>
<p><img src="https://i.imgur.com/LRxVW4L.jpg" alt="">
<img src="https://i.imgur.com/H1ySPp7.jpg" alt=""></p>
<p><em>The two images above are not proper triangles because the length of the two smaller sides are smaller than <code>7</code> and won&rsquo;t be able to form a triangle.</em></p>
<pre><code>func largestPerimeter(A []int) int {
    sort.Ints(A)
    for i := len(A) - 1; i &gt;= 2; i-- {
        if A[i] &lt; A[i - 1] + A[i - 2] {
            return A[i] + A[i - 1] + A[i - 2]
        }
    }
    return 0
}
</code></pre>]]></content></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/">1523. Count Odd Numbers in an Interval Range</a></p>
<p>The idea of this solution is to get the number odd numbers from <code>0</code> to <code>high</code>, and then subtract the number of odd numbers from <code>0</code> to <code>low - 1</code>. The idea can be shown by an example:</p>
<hr>
<pre><code>high: 7
low : 3
</code></pre><p><img src="https://assets.leetcode.com/users/images/2ca6929e-c01e-491f-9505-85dc303d779a_1614122599.638341.png" alt="image"></p>
<ul>
<li><em>The odd numbers from <code>0</code> to <code>high</code> (<code>7</code>).</em> There are <code>4</code> odd numbers from <code>0</code> to <code>7</code>.</li>
</ul>
<p><img src="https://assets.leetcode.com/users/images/0b5c316a-d1ed-426a-889f-2741c8b861f4_1614122953.1401534.png" alt="image"></p>
<ul>
<li><em>The odd numbers from <code>0</code> to <code>low - 1</code> (<code>2</code>).</em> There is <code>1</code> odd numbers from <code>0</code> to <code>2</code>.</li>
</ul>
<p>The number of odd numbers would be <code>4 - 1 = 3</code>. Three odd numbers.</p>
<hr>
<pre><code>func countOdds(low int, high int) int {
	return (high + 1)/2 - low / 2
}
</code></pre>]]></content></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/">1637. Widest Vertical Area Between Two Points Containing No Points</a></p>
<pre><code>points = {x, y}
</code></pre>
<p>The idea of this solution is to ignore the <code>y</code> part of <code>points</code> because the vertical area is the made of vertical lines. Vertical lines are made up off one <code>x</code> value for every <code>y</code> value. An example could be the line <code>x = 3</code>, this is a vertical line at the x value <code>3</code>.</p>
<p>The code first puts all the <code>x</code> points in the array <code>xPoints</code>. Then it sorts <code>xPoints</code> so all the <code>x</code>&rsquo;s are ready to use a sliding window approche of size two to find the greatest distance between all the two points. This can be show with this picture:</p>
<pre><code>input: [[8, 7], [9, 9], [7, 4], [9, 7]]
output: 1
</code></pre><p><img src="https://assets.leetcode.com/users/images/84ee2492-0703-4617-a38e-6691b4bcc3ea_1614125888.3422618.png" alt="image"></p>
<ul>
<li>Find all the <code>x</code>&rsquo;s and add them to a array</li>
<li>Sort the <code>x</code>&rsquo;s</li>
<li>Use a sliding window to find the max difference each <code>x</code> value.</li>
</ul>
<hr>
<pre><code>func maxWidthOfVerticalArea(points [][]int) int {
	xPoints := []int{}
	for _, point := range points {
		xPoints = append(xPoints, point[0])
	}
	sort.Ints(xPoints)
	max := 0

	for i := 0; i &lt; len(xPoints)-1; i++ {
		if xPoints[i+1]-xPoints[i] &gt; max {
			max = xPoints[i+1] - xPoints[i]
		}
	}

	return max
}
</code></pre>]]></content></item></channel></rss>