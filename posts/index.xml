<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on nathan naveen</title><link>https://nathannaveen.dev/posts/</link><description>Recent content in Posts on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 25 Feb 2021 15:48:58 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1592</title><link>https://nathannaveen.dev/posts/leetcode-1592/</link><pubDate>Thu, 25 Feb 2021 15:48:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1592/</guid><description>1592. Rearrange Spaces Between Words
The idea of this solution is pretty simple, first split text by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:
input = &amp;quot; this is a sentence &amp;quot; inbuiltSplit = [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;sentence&amp;quot;, &amp;quot;&amp;quot;] The Code:</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/rearrange-spaces-between-words/">1592. Rearrange Spaces Between Words</a></p>
<p>The idea of this solution is pretty simple, first split <code>text</code> by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:</p>
<pre><code>input = &quot;  this   is  a sentence &quot;

inbuiltSplit = [&quot;&quot;, &quot;&quot;, &quot;this&quot;, &quot;&quot;, &quot;&quot;, &quot;is&quot;, &quot;&quot;, &quot;a&quot;, &quot;sentence&quot;, &quot;&quot;]
</code></pre><p><strong>The Code:</strong></p>
<pre><code>func reorderSpaces(text string) string {
    spaceCounter := 0
    arr := []string{}
    str := &quot;&quot;
    res := &quot;&quot;
    for _, i := range text {
        if i == ' ' {
            if str != &quot;&quot; {
                arr = append(arr, str)
            }
            spaceCounter++
            str = &quot;&quot;
        } else {
            str += string(i)
        }
    }
    if str != &quot;&quot; {
        arr = append(arr, str)
    }
    space := &quot;&quot;

    if len(arr)-1 &gt; 0 {
        for i := 0; i &lt; spaceCounter/(len(arr)-1); i++ {
            space += &quot; &quot;
        }
        for i := 0; i &lt; len(arr)-1; i++ {
            res += arr[i] + space
        }
        res += arr[len(arr)-1]
        for i := 0; i &lt; spaceCounter%(len(arr)-1); i++ {
            res += &quot; &quot;
        }
    } else {
        for i := 0; i &lt; spaceCounter; i++ {
            space += &quot; &quot;
        }
        res = strings.Trim(text, space) + space
    }
    return res
}
</code></pre>]]></content></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree">501. Find Mode in Binary Search Tree</a></p>
<p>The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.</p>
<pre><code>func findMode(root *TreeNode) []int {
    max := 0
    m := make(map[int]int)
    res := []int{}
    stack := []*TreeNode{}
    stack = append(stack, root)

    for len(stack) != 0 {
        pop := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        if pop != nil {
            m[pop.Val]++
            stack = append(stack, pop.Left, pop.Right)
        }
    }

    for i, i2 := range m {
        if i2 &gt; max {
            res = []int{i}
            max = i2
        } else if i2 == max {
            res = append(res, i)
        }
    }
    return res
}
</code></pre>]]></content></item><item><title>Leetcode 1768</title><link>https://nathannaveen.dev/posts/leetcode-1768/</link><pubDate>Thu, 25 Feb 2021 15:48:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.
func mergeAlternately(word1 string, word2 string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ { if i &amp;lt; len(word1) { res += string(word1[i]) } if i &amp;lt; len(word2) { res += string(word2[i]) } } return res }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-strings-alternately/">1768. Merge Strings Alternately</a></p>
<p>The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.</p>
<pre><code>func mergeAlternately(word1 string, word2 string) string {
    res := &quot;&quot;

    for i := 0; i &lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ {
        if i &lt; len(word1) {
            res += string(word1[i])
        }
        if i &lt; len(word2) {
            res += string(word2[i])
        }
    }

    return res
}
</code></pre>]]></content></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/">Divide array in sets of k consecutive numbers</a></p>
<p>The idea of this solution is to loop over the <code>nums</code> array until all the values are <code>-1</code>. The reason they all will become negative one is, whenever a item is used the value will become <code>-1</code> so the code knows to not use that number again.</p>
<p><strong>If you didn&rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures:</strong>
<em>By the way sorry if my handwriting is messy</em></p>
<pre><code>input = [1, 2, 4, 3, 4, 5, 6, 3], k = 4
expected output = true
</code></pre><p>This is for getting the first consecutive sequence:
<img src="https://assets.leetcode.com/users/images/cfc0f0b7-8ffc-4ab0-8b83-143691f75526_1614179878.874795.png" alt="image"></p>
<p>And the second consecutive sequence:
<img src="https://assets.leetcode.com/users/images/eb4d3251-f7a8-4fe4-a3d2-ee89a0cc4e42_1614180843.1899865.png" alt="image"></p>
<p>Since we found two consecutive sequences we can return <code>true</code>.</p>
<hr>
<pre><code>func isPossibleDivide(nums []int, k int) bool {
	if len(nums)%k != 0 {
		return false
	}
	sort.Ints(nums)
	onlyNegetiveOnes := false

	for !onlyNegetiveOnes {
		onlyNegetiveOnes = true
		n := -1
		counter := 0
		for i := 0; i &lt; len(nums); i++ {
			if nums[i] != -1 {
				onlyNegetiveOnes = false
				if (n == -1) || (counter != k &amp;&amp; nums[i] == n+1) {
					n = nums[i]
					nums[i] = -1
					counter++
				} else if counter == k {
					break
				}
			}
		}
		if counter != k &amp;&amp; counter != 0 {
			return false
		}
	}
	return true
}
</code></pre>]]></content></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/">1566. Detect Pattern of Length M Repeated K or More Times</a>
The idea of this can be show by this image</p>
<p><img src="https://i.imgur.com/XEPQ2YV.jpg" alt=""></p>
<pre><code>func containsPattern(arr []int, m int, k int) bool {
    counter := 0

    for i := 0; i &lt; len(arr) - m; i++ {
        if arr[i] != arr[i+m] {
            counter = 0
        } else {
            counter++
        }

        if counter == (k-1)*m {
            return true
        }
    }

    return false
}
</code></pre>]]></content></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/largest-perimeter-triangle">976. Largest Perimeter Triangle</a></p>
<p>The idea of this solution is to sort the array and then keep on checking the largest three side lengths.</p>
<p>In the problem it asks us to &ldquo;return the largest perimeter of a triangle with non-zero area.&rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</p>
<p><img src="https://i.imgur.com/YOk3LWq.jpg" alt="">
<em>The triangle above is a proper triangle with an area greater than zero and we know that because the two smaller lengths, <code>5</code> and <code>5</code> added together is <code>10 &gt; 7</code>.</em>
<img src="https://i.imgur.com/HlspeLO.jpg" alt="">
<em>In the image above we can see that this is not a proper triangle because the area is zero. We know that this is not a proper triangle because the two smaller sides lengths are <code>4</code> and <code>3</code>. Four plus three is <code>7</code> and <code>7</code> is the length of the greatest triangle. So we don&rsquo;t have a triangle.</em></p>
<p><img src="https://i.imgur.com/LRxVW4L.jpg" alt="">
<img src="https://i.imgur.com/H1ySPp7.jpg" alt=""></p>
<p><em>The two images above are not proper triangles because the length of the two smaller sides are smaller than <code>7</code> and won&rsquo;t be able to form a triangle.</em></p>
<pre><code>func largestPerimeter(A []int) int {
    sort.Ints(A)
    for i := len(A) - 1; i &gt;= 2; i-- {
        if A[i] &lt; A[i - 1] + A[i - 2] {
            return A[i] + A[i - 1] + A[i - 2]
        }
    }
    return 0
}
</code></pre>]]></content></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/">1523. Count Odd Numbers in an Interval Range</a></p>
<p>The idea of this solution is to get the number odd numbers from <code>0</code> to <code>high</code>, and then subtract the number of odd numbers from <code>0</code> to <code>low - 1</code>. The idea can be shown by an example:</p>
<hr>
<pre><code>high: 7
low : 3
</code></pre><p><img src="https://assets.leetcode.com/users/images/2ca6929e-c01e-491f-9505-85dc303d779a_1614122599.638341.png" alt="image"></p>
<ul>
<li><em>The odd numbers from <code>0</code> to <code>high</code> (<code>7</code>).</em> There are <code>4</code> odd numbers from <code>0</code> to <code>7</code>.</li>
</ul>
<p><img src="https://assets.leetcode.com/users/images/0b5c316a-d1ed-426a-889f-2741c8b861f4_1614122953.1401534.png" alt="image"></p>
<ul>
<li><em>The odd numbers from <code>0</code> to <code>low - 1</code> (<code>2</code>).</em> There is <code>1</code> odd numbers from <code>0</code> to <code>2</code>.</li>
</ul>
<p>The number of odd numbers would be <code>4 - 1 = 3</code>. Three odd numbers.</p>
<hr>
<pre><code>func countOdds(low int, high int) int {
	return (high + 1)/2 - low / 2
}
</code></pre>]]></content></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description><content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/">1637. Widest Vertical Area Between Two Points Containing No Points</a></p>
<pre><code>points = {x, y}
</code></pre>
<p>The idea of this solution is to ignore the <code>y</code> part of <code>points</code> because the vertical area is the made of vertical lines. Vertical lines are made up off one <code>x</code> value for every <code>y</code> value. An example could be the line <code>x = 3</code>, this is a vertical line at the x value <code>3</code>.</p>
<p>The code first puts all the <code>x</code> points in the array <code>xPoints</code>. Then it sorts <code>xPoints</code> so all the <code>x</code>&rsquo;s are ready to use a sliding window approche of size two to find the greatest distance between all the two points. This can be show with this picture:</p>
<pre><code>input: [[8, 7], [9, 9], [7, 4], [9, 7]]
output: 1
</code></pre><p><img src="https://assets.leetcode.com/users/images/84ee2492-0703-4617-a38e-6691b4bcc3ea_1614125888.3422618.png" alt="image"></p>
<ul>
<li>Find all the <code>x</code>&rsquo;s and add them to a array</li>
<li>Sort the <code>x</code>&rsquo;s</li>
<li>Use a sliding window to find the max difference each <code>x</code> value.</li>
</ul>
<hr>
<pre><code>func maxWidthOfVerticalArea(points [][]int) int {
	xPoints := []int{}
	for _, point := range points {
		xPoints = append(xPoints, point[0])
	}
	sort.Ints(xPoints)
	max := 0

	for i := 0; i &lt; len(xPoints)-1; i++ {
		if xPoints[i+1]-xPoints[i] &gt; max {
			max = xPoints[i+1] - xPoints[i]
		}
	}

	return max
}
</code></pre>]]></content></item></channel></rss>