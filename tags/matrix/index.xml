<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>matrix on nathan naveen</title><link>https://nathannaveen.dev/tags/matrix/</link><description>Recent content in matrix on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 03 Mar 2022 15:29:12 -0600</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/matrix/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1861</title><link>https://nathannaveen.dev/posts/leetcode-1861/</link><pubDate>Thu, 03 Mar 2022 15:29:12 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1861/</guid><description>1861. Rotating the Box
The Base Idea of This Solution: I would say that this solution is like a line sweep solution.
This solution uses the fact that if an empty place separates two stones, they will be next to each other when the box is rotated. This is just like in the example input:
So this solution just moves all the stones together until we hit the end of the box or an obstacle.</description></item><item><title>Leetcode 417</title><link>https://nathannaveen.dev/posts/leetcode-417/</link><pubDate>Thu, 03 Mar 2022 15:28:59 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-417/</guid><description>417. Pacific Atlantic Water Flow
The idea of this solution is to do DFS from the ocean to the land, not from the land to the ocean. Basically we can do DFS from the water to each point, and we only move from one point to another if the next point has a height greater than the current height.
type point struct { i, j int } func pacificAtlantic(heights [][]int) [][]int { n, m := len(heights), len(heights[0]) pacificVisited := make(map[point] bool) atlanticVisited := make(map[point] bool) res := [][]int{} pacific, atlantic := findNextToWater(n, m) add := func(i, j, prevHeight int, pOrA string) { if pOrA == &amp;#34;pacific&amp;#34; { if i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt;= n || j &amp;gt;= m || pacificVisited[point{i, j}] { return } if heights[i][j] &amp;gt;= prevHeight { pacific = append(pacific, point{i, j}) } } else { // Otherwise it is &amp;#34;atlantic&amp;#34; if i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt;= n || j &amp;gt;= m || atlanticVisited[point{i, j}] { return } if heights[i][j] &amp;gt;= prevHeight { atlantic = append(atlantic, point{i, j}) } } } for len(pacific) !</description></item></channel></rss>