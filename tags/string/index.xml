<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>string on nathan naveen</title><link>https://nathannaveen.dev/tags/string/</link><description>Recent content in string on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 17 May 2021 09:50:53 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1816</title><link>https://nathannaveen.dev/posts/leetcode-1816/</link><pubDate>Mon, 17 May 2021 09:50:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1816/</guid><description>1816. Truncate Sentence
Since the solution wants us to return the first k words
We can split the words Then we can return the the first k words joined together seperated by spaces. The Solution
func truncateSentence(s string, k int) string { return strings.Join(strings.Split(s, &amp;#34; &amp;#34;)[:k], &amp;#34; &amp;#34;) } Edited Solution for readability
func truncateSentence(s string, k int) string { arr := strings.Split(s, &amp;#34; &amp;#34;) return strings.Join(arr[:k], &amp;#34; &amp;#34;) }</description></item><item><title>Leetcode 1180</title><link>https://nathannaveen.dev/posts/leetcode-1180/</link><pubDate>Mon, 17 May 2021 09:50:40 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1180/</guid><description>1180. Count Substrings with Only One Distinct Letter
The idea of this solution is to use the number of consecutive letters. And to use the formula n * (n + 1) / 2 to find the number of valid substrings. We can use the example below to explain:
Before the example: n * (n + 1) / 2 is the equation for finding the sum of the first n consecutive elements.</description></item><item><title>Leetcode 844</title><link>https://nathannaveen.dev/posts/leetcode-844/</link><pubDate>Wed, 28 Apr 2021 21:33:02 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-844/</guid><description>844. Backspace String Compare
To be truthful I am not sure whether this solution is an O(n) time or a O(2n) time because this code loops through s then t. Could someone tell me which it is?
So the idea of this solution is: *Note: I will be explaining only the loop for s because the loop for s is pretty much the same as the loop for t.
So the code first loops from 0 to len(s).</description></item><item><title>Leetcode 720</title><link>https://nathannaveen.dev/posts/leetcode-720/</link><pubDate>Wed, 28 Apr 2021 21:30:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-720/</guid><description>720. Longest Word in Dictionary
The idea of this solution is pretty simple:
The code will sort words, so the minor parts we use to build the biggest words are before the built-up words. Also, since words is sorted, we don&amp;rsquo;t have to worry about the &amp;ldquo;longest word with the smallest lexicographical order&amp;rdquo;; we only have to care about the &amp;ldquo;longest word&amp;rdquo; part. After that, the code will loop through words.</description></item><item><title>Leetcode 500</title><link>https://nathannaveen.dev/posts/leetcode-500/</link><pubDate>Wed, 28 Apr 2021 21:30:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-500/</guid><description>500. Keyboard Row
I know that this code is not pretty, but the idea of the solution is pretty simple:
We can first make a map of letters where the top rows letters are assigned to the number 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, the middle row&amp;rsquo;s characters are assigned to the numbers 10, 11, 12, 13, 14, 15, 16, 17, 18, and the last rows characters are assigned to the numbers 19, 20, 21, 22, 23, 24, 25.</description></item><item><title>Leetcode 1374</title><link>https://nathannaveen.dev/posts/leetcode-1374/</link><pubDate>Mon, 26 Apr 2021 07:51:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1374/</guid><description>1374. Generate a String With Characters That Have Odd Counts
This solution is relatively straightforward. All it does is if n is odd, we can return n numbers of 'a', but if n is even, we can return a count of n - 1, 'a'&amp;rsquo;s plus one 'b'.
You might be wondering why we are doing n number of a&amp;rsquo;s for when n is odd and n - 1 number of a&amp;rsquo;s and a b for when n is even.</description></item><item><title>Leetcode 1422</title><link>https://nathannaveen.dev/posts/leetcode-1422/</link><pubDate>Sun, 25 Apr 2021 11:08:11 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1422/</guid><description>1422. Maximum Score After Splitting a String
The idea of the first solution is pretty simple, and the second solution is based on the first solution.
The idea of the first solution is:
We loop through s and add all the numbers to a counter called numberOfOnes to count the number of ones. We do this by using ASCII. The ASCII of 0 is 48, and the ASCII of 1 is 49, so we can get the int of s[i] and then subtract 48 from it to get 0 or 1.</description></item><item><title>Leetcode 748</title><link>https://nathannaveen.dev/posts/leetcode-748/</link><pubDate>Sun, 25 Apr 2021 11:08:04 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-748/</guid><description>Shortest Completing Word
Here is how I got to this solution. I couldn&amp;rsquo;t think of any way to solve this problem without doing a naive solution, so I looked at the discussion and saw jmcelvenny&amp;rsquo;s solution.
The idea of this solution is:
we get all the letters in licensePlate and multiply each letter&amp;rsquo;s prime number to a variable called product. We have an array of 26 prime numbers, so each letter has its own prime number (upper case and lower case of the same letter share a prime number), such as a : primes[0], b : primes[1], c : primes[2], and A : primes[0], B : primes[1], C : primes[2].</description></item><item><title>Leetcode 859</title><link>https://nathannaveen.dev/posts/leetcode-859/</link><pubDate>Thu, 22 Apr 2021 09:14:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-859/</guid><description>859. Buddy Strings
To check whether two strings are buddy strings we have to check whether:
len(a) == len(b) if a == b, and there is a duplicate letter in a if there are a[j] != b[j] and a[i] != b[i] and a[j] == b[i] and a[i] == b[j] func buddyStrings(a string, b string) bool { if len(a) != len(b) { return false } m := make(map[uint8]int) temp := -1 counter := 0 for i := 0; i &amp;lt; len(a); i++ { m[a[i]]++ if a == b &amp;amp;&amp;amp; m[a[i]] == 2 { return true } if a[i] !</description></item><item><title>Leetcode 392</title><link>https://nathannaveen.dev/posts/leetcode-392/</link><pubDate>Mon, 19 Apr 2021 10:48:01 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-392/</guid><description>392. Is Subsequence
func isSubsequence(s string, t string) bool { sCounter, i := 0, 0 for i &amp;lt; len(t) &amp;amp;&amp;amp; sCounter &amp;lt; len(s) { if t[i] == s[sCounter] { sCounter++ } i++ } return sCounter == len(s) }</description></item><item><title>Leetcode 1100</title><link>https://nathannaveen.dev/posts/leetcode-1100/</link><pubDate>Fri, 16 Apr 2021 10:48:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1100/</guid><description>1100. Find K-Length Substrings With No Repeated Characters
The Idea Of This Solution:
This solution aims to use a counter called counter to count the number of duplicates. Also, when counter == 0, the substring has no duplicates.
How This Solution Works:
First, we make the variables counter, res, and m. counter is the duplicate counter, res is the resulting number of substrings that have unique characters, and m is a map that is used to find out whether a character is a duplicate.</description></item><item><title>Leetcode 824</title><link>https://nathannaveen.dev/posts/leetcode-824/</link><pubDate>Wed, 14 Apr 2021 09:58:25 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-824/</guid><description>824. Goat Latin
The idea of this solution is actualy pretty simple. We:
First add all the vowels to a map. We make a a string where we keep on appending &amp;quot;a&amp;quot; to it per word. Then we split S by spaces so we get all the words in an array called words. Then we loop through words. Inside the iteration we check whether the first letter of the current word is not a vowel we can move the first letter to the end.</description></item><item><title>Leetcode 1071</title><link>https://nathannaveen.dev/posts/leetcode-1071/</link><pubDate>Fri, 09 Apr 2021 10:56:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1071/</guid><description>1071. Greatest Common Divisor of Strings
The idea of this solution is actually pretty simple. But before we go into the problem, we have to know that a string with a common factor has a prefix (the definition of a prefix is the beginning characters of a string, a prefix can be any length) that is repeated throughout the string. This can be shown using some examples:
&amp;quot;abcdabcdabcd&amp;quot; we know that the repeated substring is &amp;quot;abcd&amp;quot;, and we can see that &amp;quot;abcd&amp;quot; is a prefix.</description></item><item><title>Leetcode 734</title><link>https://nathannaveen.dev/posts/leetcode-734/</link><pubDate>Fri, 02 Apr 2021 13:08:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-734/</guid><description>734. Sentence Similarity
The idea of this solution is to:
We have to first check whether the lengths of the two sentences are the same. If they aren&amp;rsquo;t, we return false. Then we have to make a map called m. The map is in a format of string, []string where string is the key and []string is the value. We add all the values from the matrix array called similarPairs to m.</description></item><item><title>Leetcode 246</title><link>https://nathannaveen.dev/posts/leetcode-246/</link><pubDate>Thu, 01 Apr 2021 10:34:39 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-246/</guid><description>246. Strobogrammatic Number
This solution is pretty simple and pretty similar to Leetcode 163.
The problem asks us to flip a number by 180 degrees and then return true if the fliped number is equal to the non-fliped number.
You might think that just flipping every digit and then check whether the following fliped number is equal to the non fliped number, but there is a problem with just flipping. Here is an example to show that just flipping doesn&amp;rsquo;t work:</description></item><item><title>Leetcode 1427</title><link>https://nathannaveen.dev/posts/leetcode-1427/</link><pubDate>Tue, 30 Mar 2021 13:23:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1427/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 163</title><link>https://nathannaveen.dev/posts/leetcode-163/</link><pubDate>Fri, 26 Mar 2021 10:27:54 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-163/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 266</title><link>https://nathannaveen.dev/posts/leetcode-266/</link><pubDate>Thu, 18 Mar 2021 14:10:37 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-266/</guid><description>266. Palindrome Permutation
The idea of this solution is pretty simple. We add all the letters to a map, and then if there is a extra letter that does not have a partner for the other end of the palindrome add it to the numberOfOnes counter, if the counter is greater than 1 we know that it is not a palindrome. We can explain this with some examples:
There are three main examples that are going to be shown:</description></item><item><title>Leetcode 1119</title><link>https://nathannaveen.dev/posts/leetcode-1119/</link><pubDate>Thu, 18 Mar 2021 11:32:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1119/</guid><description>1119. Remove Vowels from a String
The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.
The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.
This can be shown with some images:
We can have:
input: &amp;quot;leetcode&amp;quot; expected output: &amp;quot;ltcd&amp;quot; We can fast forward to our first vowel, 'e'.</description></item><item><title>Leetcode 1041</title><link>https://nathannaveen.dev/posts/leetcode-1041/</link><pubDate>Tue, 16 Mar 2021 12:41:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1041/</guid><description>1041. Robot Bounded In Circle
What the problem is asking:
The problem says that it will give a string with the letters &amp;quot;L&amp;quot;, &amp;quot;R&amp;quot; and &amp;quot;G&amp;quot; to command a robot. &amp;quot;L&amp;quot; means to turn left 90 degrees, &amp;quot;R&amp;quot; means to turn right 90 degrees, and &amp;quot;G&amp;quot; means to go forward one unit. The problem says to return true if the robot can continue in that pattern forever and keep going in a circle.</description></item><item><title>Leetcode 1750</title><link>https://nathannaveen.dev/posts/leetcode-1750/</link><pubDate>Tue, 09 Mar 2021 21:04:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1750/</guid><description>1750. Minimum Length of String After Deleting Similar Ends
The idea of this solution is pretty simple, so it can be shown with this image:
func minimumLength(s string) int { for len(s) &amp;gt; 1 &amp;amp;&amp;amp; s[0] == s[len(s)-1] { end := s[len(s)-1] lenS := len(s) for i := 0; i &amp;lt; lenS; i++ { if s[len(s)-1] != s[0] { s = s[:len(s)-i-1] break } } lenS = len(s) for i := 0; i &amp;lt; lenS; i++ { if s[0] !</description></item><item><title>Leetcode 1784</title><link>https://nathannaveen.dev/posts/leetcode-1784/</link><pubDate>Mon, 08 Mar 2021 14:31:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1784/</guid><description>1784. Check if Binary String Has at Most One Segment of Ones
The problem description is:
Given a binary string s without leading zeros, return true if s contains at most one contiguous segment of ones. Otherwise, return false.
This is kind of hard to understand, so I am going to explain it. A contiguous segment of ones looks like:
111000 100 10 1 11110000 And some of the ones that are not contiguous are:</description></item><item><title>Leetcode 1332</title><link>https://nathannaveen.dev/posts/leetcode-1332/</link><pubDate>Mon, 08 Mar 2021 09:42:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1332/</guid><description>1332. Remove Palindromic Subsequences
This problem asks us to find all the subsequences in a string called s. s only contains the letters a and b.
When we are doing this problem, the main thing to look at is that it says &amp;ldquo;subsequences,&amp;rdquo; not &amp;ldquo;substrings,&amp;rdquo; and that there are only two letters a and b.
The difference between &amp;ldquo;substrings&amp;rdquo; and &amp;ldquo;subsequences&amp;rdquo; is substrings are consecutive letters, while subsequences doesn&amp;rsquo;t have to be consecutive.</description></item><item><title>Leetcode 1773</title><link>https://nathannaveen.dev/posts/leetcode-1773/</link><pubDate>Sat, 06 Mar 2021 19:06:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1773/</guid><description>1773. Count Items Matching a Rule
The idea of this solution is pretty simple. We know that the array items has only 3 items. The first one is the ruleKey = &amp;quot;type&amp;quot; the next one is ruleKey = &amp;quot;color&amp;quot;, and the next one is ruleKey = &amp;quot;name&amp;quot;. We just have to set a index of each item to either 0, 1 or 2. Then just loop over each item and check whether the item[index] == ruleValue.</description></item><item><title>Leetcode 833</title><link>https://nathannaveen.dev/posts/leetcode-833/</link><pubDate>Thu, 04 Mar 2021 10:24:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-833/</guid><description>833. Find And Replace in String
func findReplaceString(S string, indexes []int, sources []string, targets []string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(S); i++ { index := 0 // this is the index that is used for indexes, sources, and targets for i2, i3 := range indexes { if i3 == i { index = i2 // we do this because the indexes are not sorted } } if index &amp;lt; len(indexes) &amp;amp;&amp;amp; i == indexes[index] { currentString := sources[index] isSubstring := true for i2 := range currentString { // checking whether the whole substring is equal if string(S[i+i2]) !</description></item><item><title>Leetcode 647</title><link>https://nathannaveen.dev/posts/leetcode-647/</link><pubDate>Mon, 01 Mar 2021 09:27:16 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-647/</guid><description>647. Palindromic Substrings
func countSubstrings(s string) int { res := 0 for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if s[j:j+i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; isPalindromic(s[j:j+i]) { res++ } } } if isPalindromic(s) { res++ } return res } func isPalindromic(s string) bool { left, right := 0, len(s)-1 for left &amp;lt;= right { if s[left] != s[right] { return false } left++ right-- } return true }</description></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description></item><item><title>Leetcode 5</title><link>https://nathannaveen.dev/posts/leetcode-5/</link><pubDate>Sun, 28 Feb 2021 11:41:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-5/</guid><description>5. Longest Palindromic Substring
In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:
func longestPalindrome(s string) string { max := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if isPalindromic(s[j : j + i]) { max = s[j : j + i] // getting the substring } } } if isPalindromic(s) { max = s } return max } func isPalindromic(s string) bool { left, right := 0, len(s) - 1 for left &amp;lt; right { if s[left] !</description></item><item><title>Leetcode 1016</title><link>https://nathannaveen.dev/posts/leetcode-1016/</link><pubDate>Fri, 26 Feb 2021 13:58:32 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1016/</guid><description>1016. Binary String With Substrings Representing 1 To N
The idea of this solution is to loop through 1...N and then make the string by adding the bytes to a string called s. Then check if S contains the reversed string of the bytes. The string s is reversed by a helper function.
func queryString(S string, N int) bool { for i := 1; i &amp;lt;= N; i++ { s := &amp;quot;&amp;quot; n := i for n &amp;gt; 0 { if n &amp;amp; 1 == 1 { s += &amp;quot;1&amp;quot; } else { s += &amp;quot;0&amp;quot; } n &amp;gt;&amp;gt;= 1 } if !</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1592</title><link>https://nathannaveen.dev/posts/leetcode-1592/</link><pubDate>Thu, 25 Feb 2021 15:48:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1592/</guid><description>1592. Rearrange Spaces Between Words
The idea of this solution is pretty simple, first split text by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:
input = &amp;quot; this is a sentence &amp;quot; inbuiltSplit = [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;sentence&amp;quot;, &amp;quot;&amp;quot;] The Code:</description></item><item><title>Leetcode 1768</title><link>https://nathannaveen.dev/posts/leetcode-1768/</link><pubDate>Thu, 25 Feb 2021 15:48:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.
func mergeAlternately(word1 string, word2 string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ { if i &amp;lt; len(word1) { res += string(word1[i]) } if i &amp;lt; len(word2) { res += string(word2[i]) } } return res }</description></item></channel></rss>