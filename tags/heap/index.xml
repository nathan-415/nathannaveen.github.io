<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>heap on nathan naveen</title><link>https://nathannaveen.dev/tags/heap/</link><description>Recent content in heap on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Fri, 04 Feb 2022 12:12:46 -0600</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/heap/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1102</title><link>https://nathannaveen.dev/posts/leetcode-1102/</link><pubDate>Fri, 04 Feb 2022 12:12:46 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1102/</guid><description>1102. Path With Maximum Minimum Value
This solution uses a max heap to keep track of all the paths, and which path we can go on to get the maximum minimum value.
type key struct { p pos min int } type pos struct { i, j int } type KeyHeap []key func (h KeyHeap) Len() int { return len(h) } func (h KeyHeap) Less(i, j int) bool { return h[i].</description></item><item><title>Leetcode 1926</title><link>https://nathannaveen.dev/posts/leetcode-1926/</link><pubDate>Wed, 19 Jan 2022 13:01:49 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1926/</guid><description>1926. Nearest Exit from Entrance in Maze
I decided to try a solution that is similar to Dijkstra&amp;rsquo;s. Even though the positions are not weighted, we can make the distance the weight, so the nodes farther away from the start have a higher weight than the closer ones. All in all, we have to find the node on the edge with the smallest weight.
This can be shown using the following image:</description></item><item><title>Leetcode 778</title><link>https://nathannaveen.dev/posts/leetcode-778/</link><pubDate>Wed, 19 Jan 2022 13:00:51 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-778/</guid><description>778. Swim in Rising Water
Time complexity = O(n2log(n))
n2is for looping through all the elements in grid where n == len(grid). Note that it is n2instead of n * m because len(grid) == len(grid[0]). log(n) is for the priority queue. Note that this is a computer science log(n) when log(n) == log2(n) instead of math where log(n) == log10(n). type key struct { max int r, c int } type RowAndCol struct { r, c int } type KeyHeap []key func (h KeyHeap) Len() int { return len(h) } func (h KeyHeap) Less(i, j int) bool { return h[i].</description></item></channel></rss>