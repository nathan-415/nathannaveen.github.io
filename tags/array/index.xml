<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>array on nathan naveen</title><link>https://nathannaveen.dev/tags/array/</link><description>Recent content in array on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Tue, 08 Feb 2022 20:06:54 -0600</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 42</title><link>https://nathannaveen.dev/posts/leetcode-42/</link><pubDate>Tue, 08 Feb 2022 20:06:54 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-42/</guid><description>42. Trapping Rain Water
I got the idea of this solution from qddpx&amp;rsquo;s solution. I thought that it was an ingenious solution, so I decided to explain it.
I think that this solution will be easier to understand if you first understand what the code is doing, so I decided to make a GIF about this.
We loop through height 3 different times:
The first time we loop through height, we loop from 0 to len(height) and make each value in a new array called lToR (left to right) the maximum value that we have reached so far in height.</description></item><item><title>Leetcode 2089</title><link>https://nathannaveen.dev/posts/leetcode-2089/</link><pubDate>Wed, 19 Jan 2022 13:01:15 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2089/</guid><description>2089. Find Target Indices After Sorting Array
Let us take an example of nums = [1, 2, 5, 2, 3, 1, 2] and target = 2. If we sort nums we get nums = [1, 1, 2, 2, 2, 3, 5]. If we know, there are three twos in nums and two items with values smaller than theirs. We know that the result will be [2, 3, 4].
So basically, this solution makes an array of the number of values that equal target where each value will be one more than the previous value.</description></item><item><title>Leetcode 1991</title><link>https://nathannaveen.dev/posts/leetcode-1991/</link><pubDate>Thu, 28 Oct 2021 15:59:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1991/</guid><description>1991. Find the Middle Index in Array
The idea of this solution is pretty simple:
We find the sum of all the numbers in nums (In this solution, I am calling it sum) Then we check whether sum - left - nums[i] == left (I will get back to what left is and what this whole thing means in the following parts). If so, we can return i (The index). The variable called left keeps track of the left sum, so we do left += nums[i].</description></item><item><title>Leetcode 2016</title><link>https://nathannaveen.dev/posts/leetcode-2016/</link><pubDate>Thu, 28 Oct 2021 15:58:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2016/</guid><description>2016. Maximum Difference Between Increasing Elements
The idea of this solution is we loop through nums, and if a number is greater than min we can check whether to make it max, otherwise if the number is smaller than min we can re-make min.
func maximumDifference(nums []int) int { min := nums[0] max := -1 for i := 0; i &amp;lt; len(nums); i++ { if nums[i] &amp;gt; min &amp;amp;&amp;amp; nums[i] - min &amp;gt; max { max = nums[i] - min } else if nums[i] &amp;lt; min { min = nums[i] } } return max }</description></item><item><title>Leetcode 2028</title><link>https://nathannaveen.dev/posts/leetcode-2028/</link><pubDate>Thu, 28 Oct 2021 15:58:20 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2028/</guid><description>2028. Find Missing Observations
This solution aims to find the missing sum and then distribute it among n values.
The idea of the first part (Finding the missing sum) is first to find the sum of the m numbers given to us in rolls.
Then since the mean will always be mean = sum / (n + m) (the sum of elements divided by the number of elements), we know that the number of elements will always be n + m.</description></item><item><title>Leetcode 200</title><link>https://nathannaveen.dev/posts/leetcode-200/</link><pubDate>Thu, 28 Oct 2021 15:58:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-200/</guid><description>200. Number of Islands
The idea of this solution can be portrayed in its most basic idea by the following image:
var doneAlready = make(map[[2]int] bool) func numIslands(grid [][]byte) int { res := 0 doneAlready = make(map[[2]int] bool) for i := 0; i &amp;lt; len(grid); i++ { for j := 0; j &amp;lt; len(grid[0]); j++ { if helper(grid, i, j) { res++ } } } return res } func helper(grid [][]byte, i, j int) bool { temp := [2]int{i, j} if i &amp;lt; 0 || i &amp;gt;= len(grid) || j &amp;lt; 0 || j &amp;gt;= len(grid[0]) || doneAlready[temp] || grid[i][j] == &amp;#39;0&amp;#39; { return false } doneAlready[temp] = true helper(grid, i - 1, j) helper(grid, i + 1, j) helper(grid, i, j - 1) helper(grid, i, j + 1) return true } This is a variation of my Max Area of Island solution:</description></item><item><title>Leetcode 1893</title><link>https://nathannaveen.dev/posts/leetcode-1893/</link><pubDate>Tue, 17 Aug 2021 12:30:59 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1893/</guid><description>1893. Check if All the Integers in a Range Are Covered
First, a walk-through of the code, and then an explanation.
A Walk Through Of the Solution:
We can sort ranges by the ranges left value (I think of ranges as ranges = [][]int{ []int{left, right} }). Then I loop through ranges and: If the ranges left value is greater than left, we can return false. If the ranges left value is smaller than or equal to left and the ranges right is smaller than right, we can re-make left.</description></item><item><title>Leetcode 302</title><link>https://nathannaveen.dev/posts/leetcode-302/</link><pubDate>Tue, 17 Aug 2021 12:30:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-302/</guid><description>302. Smallest Rectangle Enclosing Black Pixels
Note: I think that the x and y coordinates are wrong in the problem because, in a graph, the axis are:
y ^ | | | +--------&amp;gt; x The idea of the solution can be shown using the following image:
The Code:
type key struct { x int y int } func minArea(image [][]byte, x int, y int) int { stack := []key{ key{ y, x } } minX, maxX := 101, 0 minY, maxY := 101, 0 for len(stack) !</description></item><item><title>Leetcode 1940</title><link>https://nathannaveen.dev/posts/leetcode-1940/</link><pubDate>Sun, 25 Jul 2021 18:33:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1940/</guid><description>1940. Longest Common Subsequence Between Sorted Arrays
At first, I thought that this would need a nice algorithm, but then when I read the description, it said that
&amp;ldquo;arrays is sorted in strictly increasing order&amp;rdquo;
and
&amp;ldquo;longest common subsequence&amp;rdquo;
The first part, &amp;ldquo;arrays is sorted in strictly increasing order,&amp;rdquo; tells us that each array is sorted and each array has unique numbers.
The second part, &amp;ldquo;longest common subsequence&amp;rdquo; says that it is a subsequence and not a subarray.</description></item><item><title>Leetcode 495</title><link>https://nathannaveen.dev/posts/leetcode-495/</link><pubDate>Sun, 25 Jul 2021 18:33:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-495/</guid><description>495. Teemo Attacking
The idea of these two solutions is pretty simple, but in the second solution, I didn&amp;rsquo;t want to use a variable to store the result, so I manipulated timeSeries into storing the resulting values (Basically used DP).
The First Solution
I first did this solution like this:
func findPoisonedDuration(timeSeries []int, duration int) int { res := 0 for i := 1; i &amp;lt; len(timeSeries); i++ { if timeSeries[i - 1] + duration - 1 &amp;lt; timeSeries[i] { res += duration } else { res += timeSeries[i] - timeSeries[i - 1] } } if len(timeSeries) !</description></item><item><title>Leetcode 1886</title><link>https://nathannaveen.dev/posts/leetcode-1886/</link><pubDate>Sun, 25 Jul 2021 18:33:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1886/</guid><description>1886. Determine Whether Matrix Can Be Obtained By Rotation
The idea of this solution is to loop through every point in mat and check whether it has been rotated 0, 90, 180, or 270 degrees.
We don&amp;rsquo;t need to check whether mat has been rotated by 0 degrees the way we are doing the rest of the rotations. All we have to do is check whether mat == target.
I am going to explain how we do the rotations using some images.</description></item><item><title>Leetcode 1559</title><link>https://nathannaveen.dev/posts/leetcode-1559/</link><pubDate>Tue, 06 Jul 2021 18:32:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1559/</guid><description>1559. Detect Cycles in 2D Grid
The idea for this solution is to:
Find a backward L shape in the matrix. (Don&amp;rsquo;t worry if you don&amp;rsquo;t understand I will come back to it later) Then check whether the cycle all starts from one position. (I will also come back to this later) For this solution, I am going to explain how it works using an example:
If you look at the problem, you might see this example already there, I picked this example because we know the answer:</description></item><item><title>Leetcode 759</title><link>https://nathannaveen.dev/posts/leetcode-759/</link><pubDate>Tue, 06 Jul 2021 18:25:36 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-759/</guid><description>759. Employee Free Time
The idea of this solution is pretty simple:
We add everyone&amp;rsquo;s intervals into an array of intervals called arr. Then, we sort arr by their start values. Then when we loop through arr: If the end of the current element is smaller than the following elements start, we know that we have no overlap. Else if, the current elements end value is greater than the following elements start and the next elements end value, we know that the current elements time frame surrounds the following elements time frame.</description></item><item><title>Leetcode 1913</title><link>https://nathannaveen.dev/posts/leetcode-1913/</link><pubDate>Tue, 06 Jul 2021 18:25:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1913/</guid><description>1913. Maximum Product Difference Between Two Pairs
For this solution, we have to get the maximum Product Difference and to do this, we have to subtract the smallest product from the largest product. So in this solution, I decided to sort nums and return the max product minus the min product.
func maxProductDifference(nums []int) int { sort.Ints(nums) return nums[len(nums) - 1] * nums[len(nums) - 2] - nums[0] * nums[1] }</description></item><item><title>Leetcode 55</title><link>https://nathannaveen.dev/posts/leetcode-55/</link><pubDate>Tue, 06 Jul 2021 18:24:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-55/</guid><description>55. Jump Game
The idea of this solution is pretty simple once you understand it.
The idea of this solution is:
We get the maximum index we can go up to by getting the maximum of i + nums[i] and max. Then, if i has surpassed the maximum index, we can return false. Otherwise return true. If you don&amp;rsquo;t understand why this works, look at the following example:
input: [3, 2, 1, 0, 4] expected output: false</description></item><item><title>Leetcode 280</title><link>https://nathannaveen.dev/posts/leetcode-280/</link><pubDate>Tue, 06 Jul 2021 18:24:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-280/</guid><description>280. Wiggle Sort
The idea of this solution is pretty simple. We sort nums and then keep switching the numbers, so we get the array wiggled.
func wiggleSort(nums []int) { sort.Ints(nums) for i := 1; i &amp;lt; len(nums) - 1; i += 2 { nums[i], nums[i + 1] = nums[i + 1], nums[i] } }</description></item><item><title>Leetcode 48</title><link>https://nathannaveen.dev/posts/leetcode-48/</link><pubDate>Wed, 16 Jun 2021 11:22:22 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-48/</guid><description>48. Rotate Image
The idea of this solution is first to flip the matrix, so it is upside down, and then transpose the matrix. If you don&amp;rsquo;t understand, look at the following images:
We flip the matrix by fliping the top and bottom len(matrix) / 2 rows, like in this image:
And transposing the matrix is basically making matrix[i][j] = matrix[j][i], and the flips should only flip from yellow to the blue, or blue to yellow in the following image:</description></item><item><title>Leetcode 484</title><link>https://nathannaveen.dev/posts/leetcode-484/</link><pubDate>Wed, 16 Jun 2021 11:22:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-484/</guid><description>484. Find Permutation
The idea of this solution is to:
We get the first n + 1 numbers in order [1, 2, 3, ..., n + 1]. Then we reverse the numbers whenever we find a 'D', and we reverse a whole set of numbers when we find multiple 'D'&amp;rsquo;s together. Then we return the array. You might be wondering why we reverse sets of 'D'&amp;rsquo;s instead of just reversing every 'D', it can be shown using an image:</description></item><item><title>Leetcode 1403</title><link>https://nathannaveen.dev/posts/leetcode-1403/</link><pubDate>Wed, 16 Jun 2021 11:22:07 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1403/</guid><description>1403. Minimum Subsequence in Non-Increasing Order
The idea of this solution is pretty simple, we first sort nums in non-increasing order and then find the sum of nums. After that, we can loop through nums and subtract the greatest numbers in nums from the total sum and add the greatest numbers in nums to a different sum. And then, we append the num to res (the resulting function). If the other sum is greater than the total sum, we can break out of the loop and return res.</description></item><item><title>Leetcode 1605</title><link>https://nathannaveen.dev/posts/leetcode-1605/</link><pubDate>Wed, 16 Jun 2021 11:21:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1605/</guid><description>1605. Find Valid Matrix Given Row and Column Sums
The idea of this solution is pretty simple:
We loop through len(rowSum), and len(colSum). We find the minimum for colSum[j], and rowSum[i], making the resulting matrix have the minimum. After that, we subtract the minimum from both colSum[j], and rowSum[i].
Here is an image example to help with the explanation:
func restoreMatrix(rowSum []int, colSum []int) [][]int { res := make([][]int, len(rowSum)) for i := 0; i &amp;lt; len(rowSum); i++ { arr := make([]int, len(colSum)) for j := 0; j &amp;lt; len(colSum); j++ { arr[j] = colSum[j] if colSum[j] &amp;gt; rowSum[i] { arr[j] = rowSum[i] } rowSum[i], colSum[j] = rowSum[i] - arr[j], colSum[j] - arr[j] } res[i] = arr } return res }</description></item><item><title>Leetcode 406</title><link>https://nathannaveen.dev/posts/leetcode-406/</link><pubDate>Wed, 16 Jun 2021 11:21:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-406/</guid><description>406. Queue Reconstruction by Height
The idea of this solution is to:
sort people&amp;rsquo;s height in non-decreasing order, and when two people have the same height, we sort their kth place in non-increasing order.
And then we add the following person to the resulting array in the kth vacant position (zero-indexed), like in this image: As you can see in row 1, k = 4, so we add the person of height 4 into res at position 4.</description></item><item><title>Leetcode 1338</title><link>https://nathannaveen.dev/posts/leetcode-1338/</link><pubDate>Wed, 16 Jun 2021 11:21:07 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1338/</guid><description>1338. Reduce Array Size to The Half
The idea of the first solution is to:
Find the frequency of all values in arr using a map called m. Then add all the values of m to an array called h. Then reverse sort h. Then loop through h, and subtract the maximum frequencies to be removing the minimum number of integers. While subtracting check whether n &amp;lt;= len(arr) / 2 if so return i + 1.</description></item><item><title>Leetcode 1252</title><link>https://nathannaveen.dev/posts/leetcode-1252/</link><pubDate>Mon, 17 May 2021 09:50:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1252/</guid><description>1252. Cells with Odd Values in a Matrix
The idea of this solution is to use two maps, x, and y, and we can add all the values of indices to x, and y (index[0] to x, and index[1] to y).
Then we can check whether all the x&amp;rsquo;s plus all the y&amp;rsquo;s is odd. If so, we know that we can add one to the result.
If you don&amp;rsquo;t understand we can take an example:</description></item><item><title>Leetcode 1833</title><link>https://nathannaveen.dev/posts/leetcode-1833/</link><pubDate>Mon, 17 May 2021 09:50:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1833/</guid><description>1833. Maximum Ice Cream Bars
To be truthful, I think that this problem&amp;rsquo;s difficulty should be easy instead of medium.
This solution aims to sort costs because the maximum number of popsicles is obtained with the least price.
func maxIceCream(costs []int, coins int) int { sort.Ints(costs) res := 0 for _, cost := range costs { if coins - cost &amp;lt; 0 { break } res++ coins -= cost } return res }</description></item><item><title>Leetcode 1827</title><link>https://nathannaveen.dev/posts/leetcode-1827/</link><pubDate>Mon, 17 May 2021 09:50:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1827/</guid><description>1827. Minimum Operations to Make the Array Increasing
The ideas of both of the solutions are similar and simple. We know that an array is strictly increasing if the current element in the array, nums[i], is greater than the previous element nums[i - 1]. So if nums[i - 1] is greater than or equal to nums[i] we know that we have to make nums[i] = nums[i - 1] + 1.</description></item><item><title>Leetcode 1331</title><link>https://nathannaveen.dev/posts/leetcode-1331/</link><pubDate>Mon, 17 May 2021 09:49:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1331/</guid><description>1331. Rank Transform of an Array
The idea of this solution is to:
Copy arr. Then sort the copy Then loop through the copy and add all the values and indexes of the copy to a map called m. Then loop through 0 to len(arr) - 1, and make arr[i] = m[arr[i]]. Then return arr. func arrayRankTransform(arr []int) []int { g := make([]int, len(arr)) m := make(map[int]int) counter := 1 copy(g, arr) sort.</description></item><item><title>Leetcode 36</title><link>https://nathannaveen.dev/posts/leetcode-36/</link><pubDate>Mon, 17 May 2021 09:32:30 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-36/</guid><description>36. Valid Sudoku
The main idea of this solution is to find the rows, columns, and squares of the numbers. By squares, I mean the nine squares in the board:
The code goes through every position, and if the value is not a &amp;quot;.&amp;quot;, we check whether the row, column, or square contains the number. If so, we can return false.
How to Calculate The Rows And Columns
We check whether the row or column contains the number by using primes.</description></item><item><title>Leetcode 1572</title><link>https://nathannaveen.dev/posts/leetcode-1572/</link><pubDate>Wed, 05 May 2021 15:45:36 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1572/</guid><description>1572. Matrix Diagonal Sum
The idea of the first solution is to add all the values in the diagonals, and if len(mat) is odd, we can subtract the middle element from res. You might be able to understand this solution a little more with two example images: The idea of the second solution is to find two positions in the array (Where a position is in the format (x, y)) which are on diagonals and are equal.</description></item><item><title>Leetcode 720</title><link>https://nathannaveen.dev/posts/leetcode-720/</link><pubDate>Wed, 28 Apr 2021 21:30:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-720/</guid><description>720. Longest Word in Dictionary
The idea of this solution is pretty simple:
The code will sort words, so the minor parts we use to build the biggest words are before the built-up words. Also, since words is sorted, we don&amp;rsquo;t have to worry about the &amp;ldquo;longest word with the smallest lexicographical order&amp;rdquo;; we only have to care about the &amp;ldquo;longest word&amp;rdquo; part. After that, the code will loop through words.</description></item><item><title>Leetcode 1564</title><link>https://nathannaveen.dev/posts/leetcode-1564/</link><pubDate>Sun, 25 Apr 2021 18:43:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1564/</guid><description>1564. Put Boxes Into the Warehouse I
The idea of this solution is:
We sort boxes. Then, we make an array called minimums, and put the minimum values of warehouse from left to right into the array. If you don&amp;rsquo;t understand, look at the following images: Then we can just look from len(minimums) - 1 to 0 and check whether minimums[i] &amp;gt;= boxes[boxCounter] we can go to the next box, other wise we continue going through the loop until minimums[i] &amp;gt;= boxes[boxCounter].</description></item><item><title>Leetcode 1151</title><link>https://nathannaveen.dev/posts/leetcode-1151/</link><pubDate>Thu, 22 Apr 2021 09:14:35 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1151/</guid><description>1151. Minimum Swaps to Group All 1&amp;rsquo;s Together
The idea of this solution is:
We find the number of 1&amp;rsquo;s. Then we know that the 1&amp;rsquo;s have to be in a subarray of the length of all the 1&amp;rsquo;s. We know that this works because the problem statement says that all the 1&amp;rsquo;s should be together in any place. Since we know that all the ones should be in a substring of length the number of ones in data, we just have to find the substring with the maximum number of 1&amp;rsquo;s in it already so, we get the minimum switches.</description></item><item><title>Leetcode 1176</title><link>https://nathannaveen.dev/posts/leetcode-1176/</link><pubDate>Mon, 19 Apr 2021 10:48:25 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1176/</guid><description>1176. Diet Plan Performance
This is how the code works:
We sum up the first k elements. Then compare whether sum is greater than upper or smaller than lower. After comparing we can loop from k to len(calories). Then we can take off the beggining of the subarray by subtracting calories[i - k]. And then we have to add the next element from the end of the subarray to the end to the subarray, we do this by adding calories[i].</description></item><item><title>Leetcode 229</title><link>https://nathannaveen.dev/posts/leetcode-229/</link><pubDate>Sat, 17 Apr 2021 09:23:24 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-229/</guid><description>229. Majority Element II
This solution is pretty simple:
We loop through nums We add 1 to a map of integers called m, so we add 1 to m[num] where num is the current number in nums. Then we check whether m[num] == len(nums) / 3 + 1 this is checking whether the element is a majority element. Note: We can&amp;rsquo;t do m[num] &amp;gt;= len(nums) / 3 + 1. This can be shown with an example:</description></item><item><title>Leetcode 1822</title><link>https://nathannaveen.dev/posts/leetcode-1822/</link><pubDate>Thu, 15 Apr 2021 09:40:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1822/</guid><description>1822. Sign of the Product of an Array
The idea of this solution is elementary:
If the current number in nums is negative, then we can flip the sign If the current number in nums is equal to 0, we can return 0 because any number multiplied by 0 is 0. You might think that we can check for if num == 0 after we have iterated, but that won&amp;rsquo;t work because we only switch the sign and don&amp;rsquo;t multiply by 0, so we will never know whether there is a 0 in the array.</description></item><item><title>Leetcode 1800</title><link>https://nathannaveen.dev/posts/leetcode-1800/</link><pubDate>Thu, 15 Apr 2021 08:50:00 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1800/</guid><description>1800. Maximum Ascending Subarray Sum
The idea of this solution is pretty simple:
We need two variables, sum for the current sum of ascending values and maximum for the maximum sum. Then we loop through nums. Inside the loop, we check whether the current number is greater than the previous number. If so, we can add the number to sum. Else the number is smaller than or equal to the previous number, we can make maximum equal to the math.</description></item><item><title>Leetcode 119</title><link>https://nathannaveen.dev/posts/leetcode-119/</link><pubDate>Thu, 15 Apr 2021 08:49:51 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-119/</guid><description>119. Pascal&amp;rsquo;s Triangle II
I will explain the first solution.
If you want to understand the second solution click on the link above the code.
So the first solution only wants us to return the last row of the triangle.
Since we need two rows always for this problem the current row and the previous row. In this problem res is the current row and temp is the previous row.</description></item><item><title>Leetcode 118</title><link>https://nathannaveen.dev/posts/leetcode-118/</link><pubDate>Wed, 14 Apr 2021 12:29:07 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-118/</guid><description>118. Pascal&amp;rsquo;s Triangle
The idea of this solution is pretty simple:
We first have a matrix array called res Then we loop through numRows While iterating through numRows we have to make an array called temp. It is going to be our current row. We make temp[0] and temp[len(temp)] equal to 1 so we get the outer 1&amp;rsquo;s. Then we loop through the middle elements (basically excluding the outside 1&amp;rsquo;s) We have to make every temp[j] equal to the previous rows previous rows[j - 1] + previous rows[j].</description></item><item><title>Leetcode 56</title><link>https://nathannaveen.dev/posts/leetcode-56/</link><pubDate>Wed, 14 Apr 2021 09:58:31 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-56/</guid><description>func merge(intervals [][]int) [][]int { res := [][]int{} for i := 1; i &amp;lt; len(intervals); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; intervals[i-1][0] &amp;gt; intervals[i][0] { intervals[i-1], intervals[i] = intervals[i], intervals[i-1] i -= 2 } } res = append(res, intervals[0]) for i := 1; i &amp;lt; len(intervals); i++ { if res[len(res)-1][1] &amp;gt;= intervals[i][0] { res[len(res)-1][1] = max(intervals[i][1], res[len(res)-1][1]) } else { res = append(res, intervals[i]) } } return res } func max(a, b int) int { if a &amp;gt; b { return a } return b }</description></item><item><title>Leetcode 252</title><link>https://nathannaveen.dev/posts/leetcode-252/</link><pubDate>Tue, 13 Apr 2021 10:11:45 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-252/</guid><description>252. Meeting Rooms
The Idea Of The Solutions:
The idea of these two solutions is pretty simple because the second solution is based on the first solution, and the first solution is pretty simple.
The idea of the first solution is:
First, we sort intervals. Then, we check whether the previous interval&amp;rsquo;s ends intersect with the following interval&amp;rsquo;s beginning. The idea of the second solution is:
While sorting, we check for overlaps.</description></item><item><title>Leetcode 1551</title><link>https://nathannaveen.dev/posts/leetcode-1551/</link><pubDate>Sat, 10 Apr 2021 20:14:34 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1551/</guid><description>1551. Minimum Operations to Make Array Equal
This is a pretty simple solution once you understand the concept.
What the Problem Is Asking:
The problem gives us an array where arr[i] = (2 * i) + 1, you could make an array where every arr[i] = (2 * i) + 1 but I am just going to tell you that this plots a sequence of odd integers. Bascily arr[1, 3, 5 .</description></item><item><title>Leetcode 1426</title><link>https://nathannaveen.dev/posts/leetcode-1426/</link><pubDate>Sat, 10 Apr 2021 09:44:48 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1426/</guid><description>1426. Counting Elements
This solution is straightforward, and the idea of this solution is we add all the values of arr into a map called m. All we do is check whether m contains arr[i] + 1. If it does, we can add one to the resulting counter.
So the code:
First, makes a map called m and a variable called res. Then we loop through arr and add all the values into m.</description></item><item><title>Leetcode 1272</title><link>https://nathannaveen.dev/posts/leetcode-1272/</link><pubDate>Wed, 07 Apr 2021 12:36:27 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1272/</guid><description>1272. Remove Interval
What This Code Is Doing:
We make a new resulting array and then loop through intervals.
What we need to know for the following if and else statements is when the code loops through intervals, we get interval per iteration. interval is in the format [start, end]. Also, the constraints say -10^9 &amp;lt;= start &amp;lt; end &amp;lt;= 10^9, so we can see that start and end are never on the exact same location and the start is always lesser than end.</description></item><item><title>Leetcode 874</title><link>https://nathannaveen.dev/posts/leetcode-874/</link><pubDate>Wed, 07 Apr 2021 12:36:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-874/</guid><description>874. Walking Robot Simulation
Warning: This solution is pretty annoying.
What The Problem is Telling Us:
The problem description says that they will give an array called commands that tell you to turn right, left, or move forward, and they will also give you a matrix array called obstacles. obstacles is pretty self-explanatory. It is points where an obstacle is at. The points are in the format of (x, y).</description></item><item><title>Leetcode 1475</title><link>https://nathannaveen.dev/posts/leetcode-1475/</link><pubDate>Tue, 06 Apr 2021 09:57:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1475/</guid><description>1475. Final Prices With a Special Discount in a Shop
This solution is pretty simple just loop through prices and then find the first price smaller than the current one. After that, remake prices[i] the current price minus the minimum.
The Code:
func finalPrices(prices []int) []int { for i, price := range prices { minimum := 1001 for j := i + 1; j &amp;lt; len(prices); j++ { if prices[j] &amp;lt;= price { minimum = prices[j] break } } if minimum !</description></item><item><title>Leetcode 1465</title><link>https://nathannaveen.dev/posts/leetcode-1465/</link><pubDate>Mon, 05 Apr 2021 12:23:52 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1465/</guid><description>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
What The Problem Is Asking:
The problem is telling us that there are cuts in a rectangular cake of width w and height h. The cuts are only horizontal and vertical.
The problem wants us to find the largest slice of cake.
The Main Idea of This Solution:
We can find the maximum area slice by finding the maximum vertical length between each horizontal portion and the maximum horizontal length between each slice and then multiplying them together to get the maximum area.</description></item><item><title>Leetcode 658</title><link>https://nathannaveen.dev/posts/leetcode-658/</link><pubDate>Sun, 04 Apr 2021 16:47:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-658/</guid><description>658. Find K Closest Elements
What The Problem Is Asking:
The problem asks us to find the k closest elements in an array to the value x. We find the distance between elements by doing |value - x| and the k elements with the smallest distances.
The Main Idea Of This Solution:
Since we have to find the k closest elements, we can sort the array from the smallest distance to the greatest distance.</description></item><item><title>How the Manual Sort Works</title><link>https://nathannaveen.dev/posts/how-the-manual-sort-works/</link><pubDate>Sun, 04 Apr 2021 16:40:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/how-the-manual-sort-works/</guid><description>The idea of this is pretty simple:
We check whether the previous number is greater than the current number. If it is switch the two values in the array around and subtract two from i (i = The current position). After that we subtract 2 from i because we want to go back by one position. We subtract 2 to go back 1 because we add one to i in the for loop.</description></item><item><title>Leetcode 734</title><link>https://nathannaveen.dev/posts/leetcode-734/</link><pubDate>Fri, 02 Apr 2021 13:08:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-734/</guid><description>734. Sentence Similarity
The idea of this solution is to:
We have to first check whether the lengths of the two sentences are the same. If they aren&amp;rsquo;t, we return false. Then we have to make a map called m. The map is in a format of string, []string where string is the key and []string is the value. We add all the values from the matrix array called similarPairs to m.</description></item><item><title>Leetcode 1708</title><link>https://nathannaveen.dev/posts/leetcode-1708/</link><pubDate>Thu, 01 Apr 2021 11:53:48 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1708/</guid><description>1708. Largest Subarray Length K
The idea of this solution is pretty simple we get every subarray so length k. We get the max subarray, compare it with the current subarray, and then check which array is greater, the current subarray, or the maximum subarray.
We compare subarrays by looping through the length of the subarrays (They are both have the same size). Every time we iterate, we check whether the index of the current subarray is greater than the index of the max subarray and the opposite.</description></item><item><title>Leetcode 163</title><link>https://nathannaveen.dev/posts/leetcode-163/</link><pubDate>Fri, 26 Mar 2021 10:27:54 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-163/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 1791</title><link>https://nathannaveen.dev/posts/leetcode-1791/</link><pubDate>Wed, 24 Mar 2021 12:35:49 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1791/</guid><description>1791. Find Center of Star Graph
This solution is straightforward.
We first make an array called nodes with edges + 1 values. We need edges + 1 values because len(edges) is the number of edge nodes, and the + 1 is for the center node. We only need edges + 1 nodes because the nodes are from 1...n. Then we loop through edges and get each edge. edge[0] and edge[1] are the two values given per edge.</description></item><item><title>Leetcode 1213</title><link>https://nathannaveen.dev/posts/leetcode-1213/</link><pubDate>Wed, 24 Mar 2021 10:44:39 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1213/</guid><description>1213. Intersection of Three Sorted Arrays
What The Problem Asks:
The problem statement is:
Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays.
They are giving us an input of three strictly increasing arrays, and we have to find all the numbers that repeat in all three arrays.
This problem statement&amp;rsquo;s critical thing is strictly increasing because strictly increasing is different from Non-decreasing.</description></item><item><title>Leetcode 360</title><link>https://nathannaveen.dev/posts/leetcode-360/</link><pubDate>Tue, 23 Mar 2021 12:20:59 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-360/</guid><description>360. Sort Transformed Array
The idea of this solution is to loop through nums and do the quadratic equation f(x) = ax^2 + bx + c where x = nums[i] and then make nums[i] the result of the ax^2 + bx + c. After that we can sort and return nums.
Solution Using Manual Sort
func sortTransformedArray(nums []int, a int, b int, c int) []int { for i := 0; i &amp;lt; len(nums); i++ { nums[i] = a*nums[i]*nums[i] + b*nums[i] + c } for i := 1; i &amp;lt; len(nums); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i-1] { nums[i], nums[i-1] = nums[i-1], nums[i] i -= 2 } } return nums } The Same Solution But Using a Built In Sort:</description></item><item><title>Leetcode 1198</title><link>https://nathannaveen.dev/posts/leetcode-1198/</link><pubDate>Mon, 22 Mar 2021 12:57:36 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1198/</guid><description>1198. Find Smallest Common Element in All Rows
m = len(mat), n = len(mat[0])
speed = O(mn) space = O(number of unique numbers) What The Problem Is Asking:
The problem description is
Given a matrix mat where every row is sorted in strictly increasing order, return the smallest common element in all rows.
If there is no common element, return -1.
The problem is asking us to return an element that appears in every array of the matrix array, and if there are multiple, we should return the smallest.</description></item><item><title>Leetcode 296</title><link>https://nathannaveen.dev/posts/leetcode-296/</link><pubDate>Mon, 22 Mar 2021 11:57:20 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-296/</guid><description>296. Best Meeting Point
What the Problem Is Asking:
The problem gives us an input binary matrix array called grid. If grid[i][j] = 1 then it is a house of a friend, and if grid[i][j] = 0 then there is no house there.
The problem asks us to find a point on the grid that is the smallest distance to walk from all the houses. Note that the point on the grid with the smallest distance can be on a house or an empty space.</description></item><item><title>Leetcode 1121</title><link>https://nathannaveen.dev/posts/leetcode-1121/</link><pubDate>Sun, 21 Mar 2021 22:01:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1121/</guid><description>1121. Divide Array Into Increasing Sequences
What the Problem is Asking Us To Do:
The problem statement is:
Given a non-decreasing array of positive integers nums and an integer K, find out if this array can be divided into one or more disjoint increasing subsequences of length at least K.
What this is saying is:
We are first given a sorted array of positive integers called nums and an integer K for our input.</description></item><item><title>Leetcode 1214</title><link>https://nathannaveen.dev/posts/leetcode-1214/</link><pubDate>Sun, 21 Mar 2021 11:36:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1214/</guid><description>1214. Two Sum BSTs
Quick Run-Down On The Solutions
The first solution is the easiest of the three solutions and the worst-time complexity solution. The second solution has a different approach from the first solution and a little better time but still not that great. The third solution has a lot better time than the first two solutions and has a similar approach to the second solution. The Ideas of These Solutions:</description></item><item><title>Leetcode 272</title><link>https://nathannaveen.dev/posts/leetcode-272/</link><pubDate>Fri, 19 Mar 2021 09:50:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-272/</guid><description>272. Closest Binary Search Tree Value II
The idea of this solution is pretty simple, we just iterate through the tree and append the absolute difference between the popped value and target to an array called differences, then we append the popped value to an array called eachNumber. After we have iterated through the whole array we can sort the difference array while sorting the eachNumber array. After that we return the first k numbers from eachNumber.</description></item><item><title>Leetcode 1762</title><link>https://nathannaveen.dev/posts/leetcode-1762/</link><pubDate>Fri, 19 Mar 2021 09:39:06 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1762/</guid><description>1762. Buildings With an Ocean View
The idea of the solution:
The idea of this solution is to loop through the array heights backwards. Then we just have to find if a height that is greater that the curent height. After that we can reverse the resulting array because the problem asks us to give us the sorted array of indexes that have an ocean view.
If you don&amp;rsquo;t understand the explaination just look at the following images:</description></item><item><title>Leetcode 1085</title><link>https://nathannaveen.dev/posts/leetcode-1085/</link><pubDate>Thu, 18 Mar 2021 17:43:55 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1085/</guid><description>1085. Sum of Digits in the Minimum Number
The idea of the first two solutions is pretty simple. We sort the array A and then we just find the sum of the digits of the smallest number.
The idea of the second solution is pretty simple as well. We loop through A and find the minimum value, and the find the sum of the digits of the smallest number.
Solution: (Using a manual sort).</description></item><item><title>Leetcode 1133</title><link>https://nathannaveen.dev/posts/leetcode-1133/</link><pubDate>Thu, 18 Mar 2021 17:43:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1133/</guid><description>1133. Largest Unique Number
Here are two ways to solve this solution:
One way is to use an array of size 1001 which we call h (1001 because in the notes it says 0 &amp;lt;= A[i] &amp;lt;= 1000) and add one to h[A[i]]. Now we can see that the array will be sorted because we add the number of numbers to h. So all we have to do is iterate through h backward and check whether the value of h[i] == 1.</description></item><item><title>Leetcode 1469</title><link>https://nathannaveen.dev/posts/leetcode-1469/</link><pubDate>Thu, 18 Mar 2021 14:11:02 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1469/</guid><description>1469. Find All The Lonely Nodes
The idea of this solution is pretty simple, there are just four conditions:
if there is a left node but not a right node if there is a right node but not a left node if there is both a left and a right node if there are neither a left or a right node We can ignore the part where there is neither a left or a right node.</description></item><item><title>Leetcode 1138</title><link>https://nathannaveen.dev/posts/leetcode-1138/</link><pubDate>Thu, 18 Mar 2021 11:32:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1138/</guid><description>1138. Alphabet Board Path
I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.
What the Problem is asking:
The problem asks us to make a board of letters:
[ [a, b, c, d, e] [f, g, h, i, j] [k, l, m, n, o] [p, q, r, s, t] [u, v, w, x, y] [z] ] Then it gives us a word target.</description></item><item><title>Leetcode 692</title><link>https://nathannaveen.dev/posts/leetcode-692/</link><pubDate>Mon, 15 Mar 2021 11:52:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-692/</guid><description>692. Top K Frequent Words
The Main Idea:
This solution first adds the words to an array called frequency and sorts frequency after that, return the k most frequency words.
Adding to the array Frequency:
You might be confused when we do this part:
for _, ints := range frequency { if words[ints[0]] == word { contains = true ints[1]++ break } } We can simplify the if statement into if words[frequency[i][0]] = word.</description></item><item><title>Leetcode 1329</title><link>https://nathannaveen.dev/posts/leetcode-1329/</link><pubDate>Sat, 13 Mar 2021 10:42:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1329/</guid><description>1329. Sort the Matrix Diagonally
The idea of this solution is kind of hard to explain so I will show it with the following images:
i = len(mat), and j = len(mat[0])
The yellow part is every where i and j will iterate
the diagonal lines are in red
Before we continue you might be confused about why we switch 2 and 1 even though i = 1 and j = 1.</description></item><item><title>Leetcode 1752</title><link>https://nathannaveen.dev/posts/leetcode-1752/</link><pubDate>Tue, 09 Mar 2021 21:04:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1752/</guid><description>1752. Check if Array Is Sorted and Rotated
The idea of this solution is to loop through the array, and then check whether there is a nums[i] which is greater than nums[(i+1) % len(nums)] (By the way (i+1) % len(nums) is for getting the next number) if nums[i] &amp;gt; nums[(i+1)%len(nums)] then add one to a counter called counter. Then we check whether counter is greater than or equal to 2.</description></item><item><title>Leetcode 915</title><link>https://nathannaveen.dev/posts/leetcode-915/</link><pubDate>Mon, 08 Mar 2021 08:20:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-915/</guid><description>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index (1 indexed).
This can be shown with a picture:
func partitionDisjoint(A []int) int { max := A[0] for i := 0; i &amp;lt; len(A); i++ { shouldReturn := true if max &amp;lt; A[i] { max = A[i] } for j := i + 1; j &amp;lt; len(A); j++ { if A[j] &amp;lt; max { shouldReturn = false break } } if shouldReturn { return i + 1 } } return -1 }</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1773</title><link>https://nathannaveen.dev/posts/leetcode-1773/</link><pubDate>Sat, 06 Mar 2021 19:06:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1773/</guid><description>1773. Count Items Matching a Rule
The idea of this solution is pretty simple. We know that the array items has only 3 items. The first one is the ruleKey = &amp;quot;type&amp;quot; the next one is ruleKey = &amp;quot;color&amp;quot;, and the next one is ruleKey = &amp;quot;name&amp;quot;. We just have to set a index of each item to either 0, 1 or 2. Then just loop over each item and check whether the item[index] == ruleValue.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description></item><item><title>Leetcode 833</title><link>https://nathannaveen.dev/posts/leetcode-833/</link><pubDate>Thu, 04 Mar 2021 10:24:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-833/</guid><description>833. Find And Replace in String
func findReplaceString(S string, indexes []int, sources []string, targets []string) string { res := &amp;#34;&amp;#34; for i := 0; i &amp;lt; len(S); i++ { index := 0 // this is the index that is used for indexes, sources, and targets for i2, i3 := range indexes { if i3 == i { index = i2 // we do this because the indexes are not sorted } } if index &amp;lt; len(indexes) &amp;amp;&amp;amp; i == indexes[index] { currentString := sources[index] isSubstring := true for i2 := range currentString { // checking whether the whole substring is equal if string(S[i+i2]) !</description></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description></item><item><title>Leetcode 34</title><link>https://nathannaveen.dev/posts/leetcode-34/</link><pubDate>Tue, 02 Mar 2021 11:27:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-34/</guid><description>34. Find First and Last Position of Element in Sorted Array
Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra if statment inside the loop, while the second solution checks it outside of the loop.
func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left &amp;lt; right { if nums[left] !</description></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description></item></channel></rss>