<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>array on nathan naveen</title><link>https://nathannaveen.dev/tags/array/</link><description>Recent content in array on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 01 Mar 2021 14:20:15 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description></item></channel></rss>