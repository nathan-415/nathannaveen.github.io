<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on nathan naveen</title><link>https://nathannaveen.dev/tags/golang/</link><description>Recent content in golang on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 18 Mar 2021 12:19:52 -0400</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description></item><item><title>Leetcode 1119</title><link>https://nathannaveen.dev/posts/leetcode-1119/</link><pubDate>Thu, 18 Mar 2021 11:32:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1119/</guid><description>1119. Remove Vowels from a String
The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.
The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.
This can be shown with some images:
We can have:
input: &amp;quot;leetcode&amp;quot; expected output: &amp;quot;ltcd&amp;quot; We can fast forward to our first vowel, 'e'.</description></item><item><title>Leetcode 1138</title><link>https://nathannaveen.dev/posts/leetcode-1138/</link><pubDate>Thu, 18 Mar 2021 11:32:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1138/</guid><description>1138. Alphabet Board Path
I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.
What the Problem is asking:
The problem asks us to make a board of letters:
[ [a, b, c, d, e] [f, g, h, i, j] [k, l, m, n, o] [p, q, r, s, t] [u, v, w, x, y] [z] ] Then it gives us a word target.</description></item><item><title>Leetcode 1041</title><link>https://nathannaveen.dev/posts/leetcode-1041/</link><pubDate>Tue, 16 Mar 2021 12:41:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1041/</guid><description>1041. Robot Bounded In Circle
What the problem is asking:
The problem says that it will give a string with the letters &amp;quot;L&amp;quot;, &amp;quot;R&amp;quot; and &amp;quot;G&amp;quot; to command a robot. &amp;quot;L&amp;quot; means to turn left 90 degrees, &amp;quot;R&amp;quot; means to turn right 90 degrees, and &amp;quot;G&amp;quot; means to go forward one unit. The problem says to return true if the robot can continue in that pattern forever and keep going in a circle.</description></item><item><title>Leetcode 692</title><link>https://nathannaveen.dev/posts/leetcode-692/</link><pubDate>Mon, 15 Mar 2021 11:52:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-692/</guid><description>692. Top K Frequent Words
The Main Idea:
This solution first adds the words to an array called frequency and sorts frequency after that, return the k most frequency words.
Adding to the array Frequency:
You might be confused when we do this part:
for _, ints := range frequency { if words[ints[0]] == word { contains = true ints[1]++ break } } We can simplify the if statement into if words[frequency[i][0]] = word.</description></item><item><title>Leetcode 1721</title><link>https://nathannaveen.dev/posts/leetcode-1721/</link><pubDate>Sun, 14 Mar 2021 15:57:58 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1721/</guid><description>1721. Swapping Nodes in a Linked List
The idea of this solution is pretty simple.
First, we find the length of the linked list Next, we iterate through the linked list up until the ending kth node And then we iterate through the linked list to to kth node Then, last of all, switch the value of the kth node with the value of the kth node from the end.</description></item><item><title>Leetcode 1329</title><link>https://nathannaveen.dev/posts/leetcode-1329/</link><pubDate>Sat, 13 Mar 2021 10:42:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1329/</guid><description>1329. Sort the Matrix Diagonally
The idea of this solution is kind of hard to explain so I will show it with the following images:
i = len(mat), and j = len(mat[0])
The yellow part is every where i and j will iterate
the diagonal lines are in red
Before we continue you might be confused about why we switch 2 and 1 even though i = 1 and j = 1.</description></item><item><title>Leetcode 1461</title><link>https://nathannaveen.dev/posts/leetcode-1461/</link><pubDate>Fri, 12 Mar 2021 12:03:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1461/</guid><description>1461. Check If a String Contains All Binary Codes of Size K
The idea of this solution is to make a sliding window and add all the substrings os size k to a map, if the maps length is equal to 2^k return true.
We do 2^k because we have to acount for all posibilitys of 0 and 1.
func hasAllCodes(s string, k int) bool { m := make(map[string]int) for i := 0; i &amp;lt; len(s)-k+1; i++ { m[s[i:i+k]]++ } return len(m) == twoPow(k) } func twoPow(k int) int { res := 1 for i := 0; i &amp;lt; k; i++ { res *= 2 } return res } By using bit maniplation we can simplify the code, left shifting is basicly multiplying by 2.</description></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty simular to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description></item><item><title>Leetcode 1750</title><link>https://nathannaveen.dev/posts/leetcode-1750/</link><pubDate>Tue, 09 Mar 2021 21:04:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1750/</guid><description>1750. Minimum Length of String After Deleting Similar Ends
The idea of this solution is pretty simple, so it can be shown with this image:
func minimumLength(s string) int { for len(s) &amp;gt; 1 &amp;amp;&amp;amp; s[0] == s[len(s)-1] { end := s[len(s)-1] lenS := len(s) for i := 0; i &amp;lt; lenS; i++ { if s[len(s)-1] != s[0] { s = s[:len(s)-i-1] break } } lenS = len(s) for i := 0; i &amp;lt; lenS; i++ { if s[0] !</description></item><item><title>Leetcode 1752</title><link>https://nathannaveen.dev/posts/leetcode-1752/</link><pubDate>Tue, 09 Mar 2021 21:04:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1752/</guid><description>1752. Check if Array Is Sorted and Rotated
The idea of this solution is to loop through the array, and then check whether there is a nums[i] which is greater than nums[(i+1) % len(nums)] (By the way (i+1) % len(nums) is for getting the next number) if nums[i] &amp;gt; nums[(i+1)%len(nums)] then add one to a counter called counter. Then we check whether counter is greater than or equal to 2.</description></item><item><title>Leetcode 1784</title><link>https://nathannaveen.dev/posts/leetcode-1784/</link><pubDate>Mon, 08 Mar 2021 14:31:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1784/</guid><description>1784. Check if Binary String Has at Most One Segment of Ones
The problem description is:
Given a binary string s without leading zeros, return true if s contains at most one contiguous segment of ones. Otherwise, return false.
This is kind of hard to understand, so I am going to explain it. A contiguous segment of ones looks like:
111000 100 10 1 11110000 And some of the ones that are not contiguous are:</description></item><item><title>Leetcode 1332</title><link>https://nathannaveen.dev/posts/leetcode-1332/</link><pubDate>Mon, 08 Mar 2021 09:42:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1332/</guid><description>1332. Remove Palindromic Subsequences
This problem asks us to find all the subsequences in a string called s. s only contains the letters a and b.
When we are doing this problem, the main thing to look at is that it says &amp;ldquo;subsequences,&amp;rdquo; not &amp;ldquo;substrings,&amp;rdquo; and that there are only two letters a and b.
The difference between &amp;ldquo;substrings&amp;rdquo; and &amp;ldquo;subsequences&amp;rdquo; is substrings are consecutive letters, while subsequences doesn&amp;rsquo;t have to be consecutive.</description></item><item><title>Leetcode 915</title><link>https://nathannaveen.dev/posts/leetcode-915/</link><pubDate>Mon, 08 Mar 2021 08:20:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-915/</guid><description>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index (1 indexed).
This can be shown with a picture:
func partitionDisjoint(A []int) int { max := A[0] for i := 0; i &amp;lt; len(A); i++ { shouldReturn := true if max &amp;lt; A[i] { max = A[i] } for j := i + 1; j &amp;lt; len(A); j++ { if A[j] &amp;lt; max { shouldReturn = false break } } if shouldReturn { return i + 1 } } return -1 }</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1773</title><link>https://nathannaveen.dev/posts/leetcode-1773/</link><pubDate>Sat, 06 Mar 2021 19:06:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1773/</guid><description>1773. Count Items Matching a Rule
The idea of this solution is pretty simple. We know that the array items has only 3 items. The first one is the ruleKey = &amp;quot;type&amp;quot; the next one is ruleKey = &amp;quot;color&amp;quot;, and the next one is ruleKey = &amp;quot;name&amp;quot;. We just have to set a index of each item to either 0, 1 or 2. Then just loop over each item and check whether the item[index] == ruleValue.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description></item><item><title>Leetcode 833</title><link>https://nathannaveen.dev/posts/leetcode-833/</link><pubDate>Thu, 04 Mar 2021 10:24:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-833/</guid><description>833. Find And Replace in String
func findReplaceString(S string, indexes []int, sources []string, targets []string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(S); i++ { index := 0 // this is the index that is used for indexes, sources, and targets for i2, i3 := range indexes { if i3 == i { index = i2 // we do this because the indexes are not sorted } } if index &amp;lt; len(indexes) &amp;amp;&amp;amp; i == indexes[index] { currentString := sources[index] isSubstring := true for i2 := range currentString { // checking whether the whole substring is equal if string(S[i+i2]) !</description></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description></item><item><title>Leetcode 34</title><link>https://nathannaveen.dev/posts/leetcode-34/</link><pubDate>Tue, 02 Mar 2021 11:27:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-34/</guid><description>34. Find First and Last Position of Element in Sorted Array
Both of the solutions use a two pointer approche. The first solution is slower than the second solution because it checks an extra if statment inside the loop, while the second solution checks it outside of the loop.
func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left &amp;lt; right { if nums[left] !</description></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description></item><item><title>Leetcode 647</title><link>https://nathannaveen.dev/posts/leetcode-647/</link><pubDate>Mon, 01 Mar 2021 09:27:16 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-647/</guid><description>647. Palindromic Substrings
func countSubstrings(s string) int { res := 0 for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if s[j:j+i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; isPalindromic(s[j:j+i]) { res++ } } } if isPalindromic(s) { res++ } return res } func isPalindromic(s string) bool { left, right := 0, len(s)-1 for left &amp;lt;= right { if s[left] != s[right] { return false } left++ right-- } return true }</description></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description></item><item><title>Leetcode 5</title><link>https://nathannaveen.dev/posts/leetcode-5/</link><pubDate>Sun, 28 Feb 2021 11:41:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-5/</guid><description>5. Longest Palindromic Substring
In this solution we dont have to check whether the palindrome substring is greater than the max length substring because the length of the substring will always be greater than or equal to the length of the current max substring. This can be show in an image:
func longestPalindrome(s string) string { max := &amp;quot;&amp;quot; for i := 0; i &amp;lt; len(s); i++ { for j := 0; j &amp;lt;= len(s)-i; j++ { if isPalindromic(s[j : j + i]) { max = s[j : j + i] // getting the substring } } } if isPalindromic(s) { max = s } return max } func isPalindromic(s string) bool { left, right := 0, len(s) - 1 for left &amp;lt; right { if s[left] !</description></item><item><title>Leetcode 1016</title><link>https://nathannaveen.dev/posts/leetcode-1016/</link><pubDate>Fri, 26 Feb 2021 13:58:32 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1016/</guid><description>1016. Binary String With Substrings Representing 1 To N
The idea of this solution is to loop through 1...N and then make the string by adding the bytes to a string called s. Then check if S contains the reversed string of the bytes. The string s is reversed by a helper function.
func queryString(S string, N int) bool { for i := 1; i &amp;lt;= N; i++ { s := &amp;quot;&amp;quot; n := i for n &amp;gt; 0 { if n &amp;amp; 1 == 1 { s += &amp;quot;1&amp;quot; } else { s += &amp;quot;0&amp;quot; } n &amp;gt;&amp;gt;= 1 } if !</description></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1592</title><link>https://nathannaveen.dev/posts/leetcode-1592/</link><pubDate>Thu, 25 Feb 2021 15:48:58 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1592/</guid><description>1592. Rearrange Spaces Between Words
The idea of this solution is pretty simple, first split text by space. We have to split it manualy and not use a inbuild function because the text can contain multiple spaces inbetween words, and we have to count spaces. This can be show in an example:
input = &amp;quot; this is a sentence &amp;quot; inbuiltSplit = [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;sentence&amp;quot;, &amp;quot;&amp;quot;] The Code:</description></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description></item><item><title>Leetcode 1768</title><link>https://nathannaveen.dev/posts/leetcode-1768/</link><pubDate>Thu, 25 Feb 2021 15:48:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1768/</guid><description>1768. Merge Strings Alternately
The idea of this solution is pretty simple. First loop through the word with the greater length. Then check whether the length of the word is greater than the current characters index, if so then add the character to the result.
func mergeAlternately(word1 string, word2 string) string { res := &amp;quot;&amp;quot; for i := 0; i &amp;lt; int(math.Max(float64(len(word1)), float64(len(word2)))); i++ { if i &amp;lt; len(word1) { res += string(word1[i]) } if i &amp;lt; len(word2) { res += string(word2[i]) } } return res }</description></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description></item></channel></rss>