<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>queue on nathan naveen</title><link>https://nathannaveen.dev/tags/queue/</link><description>Recent content in queue on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Wed, 05 May 2021 15:45:43 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/queue/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 958</title><link>https://nathannaveen.dev/posts/leetcode-958/</link><pubDate>Wed, 05 May 2021 15:45:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-958/</guid><description>958. Check Completeness of a Binary Tree
This solution uses the facts that:
If there is a next row, we know that the whole row has to be full If there is no next row, all the nodes have to be to the left. If you have already looked at the code, you might have seen that we check whether there is a next row by checking whether queue[0].</description></item><item><title>Leetcode 103</title><link>https://nathannaveen.dev/posts/leetcode-103/</link><pubDate>Mon, 03 May 2021 10:26:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-103/</guid><description>103. Binary Tree Zigzag Level Order Traversal
The idea of this solution is to use BFS and a variable called fromRight. The fromRight checks whether the current row needs to be traversed from the right. If it does, we prepend all the nodes to temp.
func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int queue := []*TreeNode{root} fromRight := false for len(queue) != 0 { temp := []int{} n := len(queue) for i := 0; i &amp;lt; n; i++ { node := queue[0] queue = queue[1:] if node !</description></item><item><title>Leetcode 1609</title><link>https://nathannaveen.dev/posts/leetcode-1609/</link><pubDate>Mon, 03 May 2021 10:17:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1609/</guid><description>1609. Even Odd Tree
The main idea of this solution is to use BFS, but the details are:
We have a counter called row to count every row (We use this to check whether it is an even row or an odd row). Then we have a queue that has only the root to start. We loop while len(queue) != 0 Then we make a variable n equal to the len(queue).</description></item><item><title>Leetcode 107</title><link>https://nathannaveen.dev/posts/leetcode-107/</link><pubDate>Mon, 03 May 2021 10:17:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-107/</guid><description>107. Binary Tree Level Order Traversal II
First solution: faster than 100% Second solution: faster than 100%
I put in the edited for people who don&amp;rsquo;t code in go because people who don&amp;rsquo;t code in go won&amp;rsquo;t understand res = append(res[:0], append([][]int{temp}, res[0:]...)...). So if you don&amp;rsquo;t understand the first solution look at the edited.
First solution:
func levelOrderBottom(root *TreeNode) [][]int { res := [][]int{} queue := []*TreeNode{root} for len(queue) !</description></item><item><title>Leetcode 1602</title><link>https://nathannaveen.dev/posts/leetcode-1602/</link><pubDate>Mon, 03 May 2021 10:17:00 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1602/</guid><description>1602. Find Nearest Right Node in Binary Tree
The idea of this solution is to use a queue to loop through the tree, and then for every node we loop through, we check whether the node.Val == u.Val, if so, we go through the if statement if i == n - 1. Using this, we know whether the node is the last. If so, we return nil. Else we return the node after the current node.</description></item><item><title>Leetcode 1161</title><link>https://nathannaveen.dev/posts/leetcode-1161/</link><pubDate>Mon, 03 May 2021 10:16:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1161/</guid><description>1161. Maximum Level Sum of a Binary Tree
What the Problem is Asking Us:
The problem is asking us to go through each level of the binary tree and find the maximum sum and make that the returned level, but if the maximum sum is on two levels, we get the minimum level of those two.
The Code:
func maxLevelSum(root *TreeNode) int { maximum, minLevel, level := root.Val, 1, 0 queue := []*TreeNode{root} for len(queue) !</description></item></channel></rss>