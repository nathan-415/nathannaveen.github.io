<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>union find on nathan naveen</title><link>https://nathannaveen.dev/tags/union-find/</link><description>Recent content in union find on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 28 Oct 2021 15:57:56 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/union-find/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 684</title><link>https://nathannaveen.dev/posts/leetcode-684/</link><pubDate>Thu, 28 Oct 2021 15:57:56 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-684/</guid><description>684. Redundant Connection
The idea of this solution is to use union find to connect all the edges together, then in the Union() function if edge[0] parent equals edge[1] parent we have a redundant connection.
Note that I modified the average union find for this problem.
type unionFind struct { parent []int n int } func (this *unionFind) Find(x int) int { if x != this.parent[x] { this.</description></item></channel></rss>