<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcodem string on nathan naveen</title><link>https://nathannaveen.dev/tags/leetcodem-string/</link><description>Recent content in leetcodem string on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 17 May 2021 09:50:59 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/leetcodem-string/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1858</title><link>https://nathannaveen.dev/posts/leetcode-1858/</link><pubDate>Mon, 17 May 2021 09:50:59 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1858/</guid><description>1858. Longest Word With All Prefixes
This solution aims to sort words so we get the previous prefix of the max word before the word. An example of this could be
words = [&amp;quot;k&amp;quot;, &amp;quot;kiran&amp;quot;,&amp;quot;ki&amp;quot;,&amp;quot;kira&amp;quot;,&amp;quot;kir&amp;quot;] and when we sort, it becomes words = [&amp;quot;k&amp;quot;,&amp;quot;ki&amp;quot;,&amp;quot;kir&amp;quot;,&amp;quot;kira&amp;quot;, &amp;quot;kiran&amp;quot;].
Then we can use a map to build up the word. If the len(word) is equal to 1, we know that it is a start of a word, or if the map contains word without the last letter, we know that there is the prefix of the word.</description></item></channel></rss>