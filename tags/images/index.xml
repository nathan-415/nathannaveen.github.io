<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>images on nathan naveen</title><link>https://nathannaveen.dev/tags/images/</link><description>Recent content in images on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Fri, 04 Feb 2022 12:12:59 -0600</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/images/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 490</title><link>https://nathannaveen.dev/posts/leetcode-490/</link><pubDate>Fri, 04 Feb 2022 12:12:59 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-490/</guid><description>490. The Maze
The idea of this solution is to use BFS to find every path. And then if we find a path that leads to the destination we can return true.
I made a gif that basicly gives an example of all paths from start. Note that this is the same example as the problem statment.
While in the gif we just see the paths, in the code we have to make the path, meaning that we have to make a path one move at a time.</description></item><item><title>Leetcode 1102</title><link>https://nathannaveen.dev/posts/leetcode-1102/</link><pubDate>Fri, 04 Feb 2022 12:12:46 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1102/</guid><description>1102. Path With Maximum Minimum Value
This solution uses a max heap to keep track of all the paths, and which path we can go on to get the maximum minimum value.
type key struct { p pos min int } type pos struct { i, j int } type KeyHeap []key func (h KeyHeap) Len() int { return len(h) } func (h KeyHeap) Less(i, j int) bool { return h[i].</description></item><item><title>Leetcode 2155</title><link>https://nathannaveen.dev/posts/leetcode-2155/</link><pubDate>Fri, 04 Feb 2022 12:12:40 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2155/</guid><description>2155. All Divisions With the Highest Score of a Binary Array
The idea of this solution is to loop through nums and add one to a zero count if we have a zero, and subtract one from a one counter if it is a one. This can be shown using an illustration:
func maxScoreIndices(nums []int) []int { numZeros := 0 numOnes := 0 for _, n := range nums { numOnes += n } max := numOnes res := []int{0} for i, n := range nums { if n == 0 { numZeros++ } else { numOnes-- } if numZeros + numOnes &amp;gt; max { max = numZeros + numOnes res = []int{ i + 1 } } else if numZeros + numOnes == max { res = append(res, i + 1) } } return res } We can put:</description></item><item><title>Leetcode 1926</title><link>https://nathannaveen.dev/posts/leetcode-1926/</link><pubDate>Wed, 19 Jan 2022 13:01:49 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1926/</guid><description>1926. Nearest Exit from Entrance in Maze
I decided to try a solution that is similar to Dijkstra&amp;rsquo;s. Even though the positions are not weighted, we can make the distance the weight, so the nodes farther away from the start have a higher weight than the closer ones. All in all, we have to find the node on the edge with the smallest weight.
This can be shown using the following image:</description></item><item><title>Leetcode 2095</title><link>https://nathannaveen.dev/posts/leetcode-2095/</link><pubDate>Wed, 19 Jan 2022 13:01:36 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2095/</guid><description>2095. Delete the Middle Node of a Linked List
The idea of this solution is to use three-pointers, like in the following example:
Remember that the hare will always go up two values, while prev and turtle will only go up one.
The hare has reached the end, so we can stop moving the hare, turtle, and prev. Now, we have to remove the turtles position by doing prev.Next = prev.</description></item><item><title>Leetcode 2083</title><link>https://nathannaveen.dev/posts/leetcode-2083/</link><pubDate>Wed, 19 Jan 2022 13:01:07 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2083/</guid><description>2083. Substrings That Begin and End With the Same Letter
func numberOfSubstrings(s string) int64 { m := make(map[rune] int) res := int64(0) for _, letter := range s { m[letter]++ res += int64(m[letter]) } return res } The second solution is the fun solution. We can find the number of substrings, the beginning, and the end in the same letter. To show how this is done, we can take an example of &amp;quot;aaaaaa&amp;quot;:</description></item><item><title>Leetcode 543</title><link>https://nathannaveen.dev/posts/leetcode-543/</link><pubDate>Wed, 10 Nov 2021 09:57:49 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-543/</guid><description>I feel that enough people have explained the first type of solution, so I will not explain this.
Most People Do This:
var maximum = 0 func diameterOfBinaryTree(root *TreeNode) int { maximum = 0 helper(root) return maximum } func helper(root *TreeNode) int { if root == nil { return 0 } leftHeight, rightHeight := helper(root.Left), helper(root.Right) maximum = max(leftHeight + rightHeight, maximum) return 1 + max(leftHeight, rightHeight) } func max(a, b int) int { if a &amp;gt; b { return a } return b } The Second Solution Explanation:</description></item><item><title>Leetcode 2027</title><link>https://nathannaveen.dev/posts/leetcode-2027/</link><pubDate>Thu, 28 Oct 2021 15:58:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2027/</guid><description>2027. Minimum Moves to Convert String
The idea of this solution is if we are on a 'X' we can move the index up by three and add one to res.
An example could be:
input: s = &amp;quot;XXOXXXOOOXOXOXX&amp;quot; (I tried to capture as many edge cases as I could in this test case)
We can start with our index i = 0
s[i] == 'X', so we can skip the next two values (Skip the values at indexes 1 and 2 because according to the problem we have made s[0] = 'O', s[1] = 'O', s[2] = 'O'.</description></item><item><title>Leetcode 200</title><link>https://nathannaveen.dev/posts/leetcode-200/</link><pubDate>Thu, 28 Oct 2021 15:58:14 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-200/</guid><description>200. Number of Islands
The idea of this solution can be portrayed in its most basic idea by the following image:
var doneAlready = make(map[[2]int] bool) func numIslands(grid [][]byte) int { res := 0 doneAlready = make(map[[2]int] bool) for i := 0; i &amp;lt; len(grid); i++ { for j := 0; j &amp;lt; len(grid[0]); j++ { if helper(grid, i, j) { res++ } } } return res } func helper(grid [][]byte, i, j int) bool { temp := [2]int{i, j} if i &amp;lt; 0 || i &amp;gt;= len(grid) || j &amp;lt; 0 || j &amp;gt;= len(grid[0]) || doneAlready[temp] || grid[i][j] == &amp;#39;0&amp;#39; { return false } doneAlready[temp] = true helper(grid, i - 1, j) helper(grid, i + 1, j) helper(grid, i, j - 1) helper(grid, i, j + 1) return true } This is a variation of my Max Area of Island solution:</description></item><item><title>Leetcode 1428</title><link>https://nathannaveen.dev/posts/leetcode-1428/</link><pubDate>Thu, 28 Oct 2021 15:58:02 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1428/</guid><description>1428. Leftmost Column with at Least a One
This solution uses the fact that all rows are sorted. So, all the ones in every row will be at the end.
Basically, to not call binaryMatrix.Get(i, j) too many times. We can&amp;rsquo;t loop through all values of the matrix.
Since 1 &amp;lt;= rows, cols &amp;lt;= 100 the max number of elements in the matrix is 100 * 100, 10000. And the problem says that the max number of calls to binaryMatrix.</description></item><item><title>Leetcode 2046</title><link>https://nathannaveen.dev/posts/leetcode-2046/</link><pubDate>Thu, 28 Oct 2021 15:57:20 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2046/</guid><description>2046. Sort Linked List Already Sorted Using Absolute Values
The idea of this solution is to check whether the current value is smaller than 0. If so, we can remove it from its current position, add it to the beginning of the list, and make that the new beginning.
This solution works because the absolute value of -1 will always be smaller than the absolute value of -5, but -1 is greater than -5.</description></item><item><title>Leetcode 319</title><link>https://nathannaveen.dev/posts/leetcode-319/</link><pubDate>Thu, 28 Oct 2021 15:56:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-319/</guid><description>319. Bulb Switcher
Note: If you don&amp;rsquo;t understand this problem, think of it as something similar to Seive of Eratosthenes.
At first I didn&amp;rsquo;t understand how to go about this problem, so I drew it out. I made a graph that might be easier to understand than my drawing:
In this graph the numbers represent what round we are on (Y-axis = what round we are on). And the bulbs represent each bulb (X-axis = what bulb we are on).</description></item><item><title>Leetcode 1804</title><link>https://nathannaveen.dev/posts/leetcode-1804/</link><pubDate>Tue, 17 Aug 2021 12:33:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1804/</guid><description>1804. Implement Trie II (Prefix Tree)
The idea of this solution can be shown using the following image:
type Node struct { m map[rune] *Node isEndCounter int starts int } type Trie struct { node *Node } func Constructor() Trie { return Trie{node: &amp;amp;Node{make(map[rune] *Node), 0, 0}} } func (this *Trie) Insert(word string) { root := this.node root.starts++ for _, s := range word { if root.m[s] == nil { root.</description></item><item><title>Leetcode 1893</title><link>https://nathannaveen.dev/posts/leetcode-1893/</link><pubDate>Tue, 17 Aug 2021 12:30:59 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1893/</guid><description>1893. Check if All the Integers in a Range Are Covered
First, a walk-through of the code, and then an explanation.
A Walk Through Of the Solution:
We can sort ranges by the ranges left value (I think of ranges as ranges = [][]int{ []int{left, right} }). Then I loop through ranges and: If the ranges left value is greater than left, we can return false. If the ranges left value is smaller than or equal to left and the ranges right is smaller than right, we can re-make left.</description></item><item><title>Leetcode 1404</title><link>https://nathannaveen.dev/posts/leetcode-1404/</link><pubDate>Tue, 17 Aug 2021 12:30:51 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1404/</guid><description>1404. Number of Steps to Reduce a Number in Binary Representation to One
The idea of this solution is:
When we find a zero at the end of s, we know that s is divisible by 2, so we can remove the end of the string and add one to the result. When we find a 1 at the end of s, we know that s is not divisible by 2, so we can add 1 by keep making all values before the position equal to 0 if they are 1 and 1 if they are 0.</description></item><item><title>Leetcode 302</title><link>https://nathannaveen.dev/posts/leetcode-302/</link><pubDate>Tue, 17 Aug 2021 12:30:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-302/</guid><description>302. Smallest Rectangle Enclosing Black Pixels
Note: I think that the x and y coordinates are wrong in the problem because, in a graph, the axis are:
y ^ | | | +--------&amp;gt; x The idea of the solution can be shown using the following image:
The Code:
type key struct { x int y int } func minArea(image [][]byte, x int, y int) int { stack := []key{ key{ y, x } } minX, maxX := 101, 0 minY, maxY := 101, 0 for len(stack) !</description></item><item><title>Leetcode 888</title><link>https://nathannaveen.dev/posts/leetcode-888/</link><pubDate>Tue, 17 Aug 2021 12:30:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-888/</guid><description>888. Fair Candy Swap
The idea of this solution can be shown using the following image:
The Code:
func fairCandySwap(A []int, B []int) []int { alice, bob := 0, 0 m := make(map[int] int) for _, i := range A { alice += i } for _, i := range B { bob += i m[i]++ } temp := (alice - bob) / 2 for _, i := range A { if m[i - temp] &amp;gt;= 1 { return []int{i, i - temp} } } return []int{} }</description></item><item><title>Leetcode 1940</title><link>https://nathannaveen.dev/posts/leetcode-1940/</link><pubDate>Sun, 25 Jul 2021 18:33:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1940/</guid><description>1940. Longest Common Subsequence Between Sorted Arrays
At first, I thought that this would need a nice algorithm, but then when I read the description, it said that
&amp;ldquo;arrays is sorted in strictly increasing order&amp;rdquo;
and
&amp;ldquo;longest common subsequence&amp;rdquo;
The first part, &amp;ldquo;arrays is sorted in strictly increasing order,&amp;rdquo; tells us that each array is sorted and each array has unique numbers.
The second part, &amp;ldquo;longest common subsequence&amp;rdquo; says that it is a subsequence and not a subarray.</description></item><item><title>Leetcode 1886</title><link>https://nathannaveen.dev/posts/leetcode-1886/</link><pubDate>Sun, 25 Jul 2021 18:33:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1886/</guid><description>1886. Determine Whether Matrix Can Be Obtained By Rotation
The idea of this solution is to loop through every point in mat and check whether it has been rotated 0, 90, 180, or 270 degrees.
We don&amp;rsquo;t need to check whether mat has been rotated by 0 degrees the way we are doing the rest of the rotations. All we have to do is check whether mat == target.
I am going to explain how we do the rotations using some images.</description></item><item><title>Leetcode 1559</title><link>https://nathannaveen.dev/posts/leetcode-1559/</link><pubDate>Tue, 06 Jul 2021 18:32:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1559/</guid><description>1559. Detect Cycles in 2D Grid
The idea for this solution is to:
Find a backward L shape in the matrix. (Don&amp;rsquo;t worry if you don&amp;rsquo;t understand I will come back to it later) Then check whether the cycle all starts from one position. (I will also come back to this later) For this solution, I am going to explain how it works using an example:
If you look at the problem, you might see this example already there, I picked this example because we know the answer:</description></item><item><title>Leetcode 1669</title><link>https://nathannaveen.dev/posts/leetcode-1669/</link><pubDate>Tue, 06 Jul 2021 18:24:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1669/</guid><description>1669. Merge In Between Linked Lists
The idea of this solution can be explained with a simple image:
In image 1 we can see the input of list1 = [0, 1, 2, 3, 4, 5], list2 = [10, 11, 12], a = 3, and b = 4. We can iterate through list2 and store the beginning and end of the list. Then, we can iterate through list1 and find the pos of a - 1.</description></item><item><title>Leetcode 55</title><link>https://nathannaveen.dev/posts/leetcode-55/</link><pubDate>Tue, 06 Jul 2021 18:24:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-55/</guid><description>55. Jump Game
The idea of this solution is pretty simple once you understand it.
The idea of this solution is:
We get the maximum index we can go up to by getting the maximum of i + nums[i] and max. Then, if i has surpassed the maximum index, we can return false. Otherwise return true. If you don&amp;rsquo;t understand why this works, look at the following example:</description></item><item><title>Leetcode 1828</title><link>https://nathannaveen.dev/posts/leetcode-1828/</link><pubDate>Wed, 16 Jun 2021 11:22:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1828/</guid><description>1828. Queries on Number of Points Inside a Circle
The idea of this solution is to:
loop through the queries and then a nested loop to go through points.
After that we check whether squared(point[0] - query[0]) + squared(point[1] - query[1]) &amp;lt;= squared(query[2]). This is bascily checking whether the distance between two points is smaller than or equal to the radius but edited. This image that I have drawn and wrote up explains this part: (Note: point[0] = x1, query[0] = x2, point[1] = y1, query[1] = y2, query[2] = radius)</description></item><item><title>Leetcode 48</title><link>https://nathannaveen.dev/posts/leetcode-48/</link><pubDate>Wed, 16 Jun 2021 11:22:22 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-48/</guid><description>48. Rotate Image
The idea of this solution is first to flip the matrix, so it is upside down, and then transpose the matrix. If you don&amp;rsquo;t understand, look at the following images:
We flip the matrix by fliping the top and bottom len(matrix) / 2 rows, like in this image:
And transposing the matrix is basically making matrix[i][j] = matrix[j][i], and the flips should only flip from yellow to the blue, or blue to yellow in the following image:</description></item><item><title>Leetcode 1874</title><link>https://nathannaveen.dev/posts/leetcode-1874/</link><pubDate>Wed, 16 Jun 2021 11:22:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1874/</guid><description>1874. Minimize Product Sum of Two Arrays
The idea of both solutions is pretty much the same: The smallest number multiplied by the greatest number always makes the smallest sum. If you don&amp;rsquo;t understand, look at the following image:
In the image above, the top array is sorted in non-decreasing order, and the bottom array is sorted in non-increasing order. So when we multiply nums1[i] and nums2[i] together, we get the minimum product, and when we sum the products up, we get the minimum sum.</description></item><item><title>Leetcode 1689</title><link>https://nathannaveen.dev/posts/leetcode-1689/</link><pubDate>Wed, 16 Jun 2021 11:21:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1689/</guid><description>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
The idea of this solution is that the max digit in n will be the result. But you might be wondering why this works.
This works because the max digit can only be made by adding the max digit number of 1&amp;rsquo;s. If you don&amp;rsquo;t understand, look at the following image: The first image is an example, and the second example is for anyone who doesn&amp;rsquo;t understand the first example.</description></item><item><title>Leetcode 1605</title><link>https://nathannaveen.dev/posts/leetcode-1605/</link><pubDate>Wed, 16 Jun 2021 11:21:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1605/</guid><description>1605. Find Valid Matrix Given Row and Column Sums
The idea of this solution is pretty simple:
We loop through len(rowSum), and len(colSum). We find the minimum for colSum[j], and rowSum[i], making the resulting matrix have the minimum. After that, we subtract the minimum from both colSum[j], and rowSum[i].
Here is an image example to help with the explanation:
func restoreMatrix(rowSum []int, colSum []int) [][]int { res := make([][]int, len(rowSum)) for i := 0; i &amp;lt; len(rowSum); i++ { arr := make([]int, len(colSum)) for j := 0; j &amp;lt; len(colSum); j++ { arr[j] = colSum[j] if colSum[j] &amp;gt; rowSum[i] { arr[j] = rowSum[i] } rowSum[i], colSum[j] = rowSum[i] - arr[j], colSum[j] - arr[j] } res[i] = arr } return res }</description></item><item><title>Leetcode 406</title><link>https://nathannaveen.dev/posts/leetcode-406/</link><pubDate>Wed, 16 Jun 2021 11:21:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-406/</guid><description>406. Queue Reconstruction by Height
The idea of this solution is to:
sort people&amp;rsquo;s height in non-decreasing order, and when two people have the same height, we sort their kth place in non-increasing order.
And then we add the following person to the resulting array in the kth vacant position (zero-indexed), like in this image: As you can see in row 1, k = 4, so we add the person of height 4 into res at position 4.</description></item><item><title>Leetcode 1252</title><link>https://nathannaveen.dev/posts/leetcode-1252/</link><pubDate>Mon, 17 May 2021 09:50:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1252/</guid><description>1252. Cells with Odd Values in a Matrix
The idea of this solution is to use two maps, x, and y, and we can add all the values of indices to x, and y (index[0] to x, and index[1] to y).
Then we can check whether all the x&amp;rsquo;s plus all the y&amp;rsquo;s is odd. If so, we know that we can add one to the result.
If you don&amp;rsquo;t understand we can take an example:</description></item><item><title>Leetcode 1572</title><link>https://nathannaveen.dev/posts/leetcode-1572/</link><pubDate>Wed, 05 May 2021 15:45:36 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1572/</guid><description>1572. Matrix Diagonal Sum
The idea of the first solution is to add all the values in the diagonals, and if len(mat) is odd, we can subtract the middle element from res. You might be able to understand this solution a little more with two example images: The idea of the second solution is to find two positions in the array (Where a position is in the format (x, y)) which are on diagonals and are equal.</description></item><item><title>Leetcode 844</title><link>https://nathannaveen.dev/posts/leetcode-844/</link><pubDate>Wed, 28 Apr 2021 21:33:02 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-844/</guid><description>844. Backspace String Compare
To be truthful I am not sure whether this solution is an O(n) time or a O(2n) time because this code loops through s then t. Could someone tell me which it is?
So the idea of this solution is: *Note: I will be explaining only the loop for s because the loop for s is pretty much the same as the loop for t.
So the code first loops from 0 to len(s).</description></item><item><title>Leetcode 1564</title><link>https://nathannaveen.dev/posts/leetcode-1564/</link><pubDate>Sun, 25 Apr 2021 18:43:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1564/</guid><description>1564. Put Boxes Into the Warehouse I
The idea of this solution is:
We sort boxes. Then, we make an array called minimums, and put the minimum values of warehouse from left to right into the array. If you don&amp;rsquo;t understand, look at the following images: Then we can just look from len(minimums) - 1 to 0 and check whether minimums[i] &amp;gt;= boxes[boxCounter] we can go to the next box, other wise we continue going through the loop until minimums[i] &amp;gt;= boxes[boxCounter].</description></item><item><title>Leetcode 892</title><link>https://nathannaveen.dev/posts/leetcode-892/</link><pubDate>Fri, 09 Apr 2021 10:56:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-892/</guid><description>892. Surface Area of 3D Shapes
The Idea Of This Solution:
This solution uses the fact that each stack of cubes surface area is the equation 2 + 4 * v. This works because each cube has 6 sides. This can be shown using some images:
We can see that each cube has 6 planes. There are 4 sides, 1 top, and 1 bottom.
Now, as we can see, there are 10 units of surface area while the other one only had 6, there are 8 sides, 1 top, and 1 bottom.</description></item><item><title>Leetcode 1272</title><link>https://nathannaveen.dev/posts/leetcode-1272/</link><pubDate>Wed, 07 Apr 2021 12:36:27 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1272/</guid><description>1272. Remove Interval
What This Code Is Doing:
We make a new resulting array and then loop through intervals.
What we need to know for the following if and else statements is when the code loops through intervals, we get interval per iteration. interval is in the format [start, end]. Also, the constraints say -10^9 &amp;lt;= start &amp;lt; end &amp;lt;= 10^9, so we can see that start and end are never on the exact same location and the start is always lesser than end.</description></item><item><title>Leetcode 1762</title><link>https://nathannaveen.dev/posts/leetcode-1762/</link><pubDate>Fri, 19 Mar 2021 09:39:06 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1762/</guid><description>1762. Buildings With an Ocean View
The idea of the solution:
The idea of this solution is to loop through the array heights backwards. Then we just have to find if a height that is greater that the curent height. After that we can reverse the resulting array because the problem asks us to give us the sorted array of indexes that have an ocean view.
If you don&amp;rsquo;t understand the explaination just look at the following images:</description></item><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description></item><item><title>Leetcode 1119</title><link>https://nathannaveen.dev/posts/leetcode-1119/</link><pubDate>Thu, 18 Mar 2021 11:32:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1119/</guid><description>1119. Remove Vowels from a String
The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.
The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.
This can be shown with some images:
We can have:
input: &amp;quot;leetcode&amp;quot; expected output: &amp;quot;ltcd&amp;quot; We can fast forward to our first vowel, 'e'.</description></item><item><title>Leetcode 1138</title><link>https://nathannaveen.dev/posts/leetcode-1138/</link><pubDate>Thu, 18 Mar 2021 11:32:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1138/</guid><description>1138. Alphabet Board Path
I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.
What the Problem is asking:
The problem asks us to make a board of letters:
[ [a, b, c, d, e] [f, g, h, i, j] [k, l, m, n, o] [p, q, r, s, t] [u, v, w, x, y] [z] ] Then it gives us a word target.</description></item><item><title>Leetcode 692</title><link>https://nathannaveen.dev/posts/leetcode-692/</link><pubDate>Mon, 15 Mar 2021 11:52:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-692/</guid><description>692. Top K Frequent Words
The Main Idea:
This solution first adds the words to an array called frequency and sorts frequency after that, return the k most frequency words.
Adding to the array Frequency:
You might be confused when we do this part:
for _, ints := range frequency { if words[ints[0]] == word { contains = true ints[1]++ break } } We can simplify the if statement into if words[frequency[i][0]] = word.</description></item><item><title>Leetcode 1329</title><link>https://nathannaveen.dev/posts/leetcode-1329/</link><pubDate>Sat, 13 Mar 2021 10:42:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1329/</guid><description>1329. Sort the Matrix Diagonally
The idea of this solution is kind of hard to explain so I will show it with the following images:
i = len(mat), and j = len(mat[0])
The yellow part is every where i and j will iterate
the diagonal lines are in red
Before we continue you might be confused about why we switch 2 and 1 even though i = 1 and j = 1.</description></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty similar to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description></item><item><title>Leetcode 1750</title><link>https://nathannaveen.dev/posts/leetcode-1750/</link><pubDate>Tue, 09 Mar 2021 21:04:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1750/</guid><description>1750. Minimum Length of String After Deleting Similar Ends
The idea of this solution is pretty simple, so it can be shown with this image:
func minimumLength(s string) int { for len(s) &amp;gt; 1 &amp;amp;&amp;amp; s[0] == s[len(s)-1] { end := s[len(s)-1] lenS := len(s) for i := 0; i &amp;lt; lenS; i++ { if s[len(s)-1] != s[0] { s = s[:len(s)-i-1] break } } lenS = len(s) for i := 0; i &amp;lt; lenS; i++ { if s[0] !</description></item><item><title>Leetcode 1752</title><link>https://nathannaveen.dev/posts/leetcode-1752/</link><pubDate>Tue, 09 Mar 2021 21:04:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1752/</guid><description>1752. Check if Array Is Sorted and Rotated
The idea of this solution is to loop through the array, and then check whether there is a nums[i] which is greater than nums[(i+1) % len(nums)] (By the way (i+1) % len(nums) is for getting the next number) if nums[i] &amp;gt; nums[(i+1)%len(nums)] then add one to a counter called counter. Then we check whether counter is greater than or equal to 2.</description></item><item><title>Leetcode 915</title><link>https://nathannaveen.dev/posts/leetcode-915/</link><pubDate>Mon, 08 Mar 2021 08:20:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-915/</guid><description>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index (1 indexed).
This can be shown with a picture:
func partitionDisjoint(A []int) int { max := A[0] for i := 0; i &amp;lt; len(A); i++ { shouldReturn := true if max &amp;lt; A[i] { max = A[i] } for j := i + 1; j &amp;lt; len(A); j++ { if A[j] &amp;lt; max { shouldReturn = false break } } if shouldReturn { return i + 1 } } return -1 }</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description></item></channel></rss>