<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>images on nathan naveen</title><link>https://nathannaveen.dev/tags/images/</link><description>Recent content in images on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Tue, 06 Jul 2021 18:32:45 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/images/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1559</title><link>https://nathannaveen.dev/posts/leetcode-1559/</link><pubDate>Tue, 06 Jul 2021 18:32:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1559/</guid><description>1559. Detect Cycles in 2D Grid
The idea for this solution is to:
Find a backward L shape in the matrix. (Don&amp;rsquo;t worry if you don&amp;rsquo;t understand I will come back to it later) Then check whether the cycle all starts from one position. (I will also come back to this later) For this solution, I am going to explain how it works using an example:
If you look at the problem, you might see this example already there, I picked this example because we know the answer:</description></item><item><title>Leetcode 1669</title><link>https://nathannaveen.dev/posts/leetcode-1669/</link><pubDate>Tue, 06 Jul 2021 18:24:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1669/</guid><description>1669. Merge In Between Linked Lists
The idea of this solution can be explained with a simple image:
In image 1 we can see the input of list1 = [0, 1, 2, 3, 4, 5], list2 = [10, 11, 12], a = 3, and b = 4. We can iterate through list2 and store the beginning and end of the list. Then, we can iterate through list1 and find the pos of a - 1.</description></item><item><title>Leetcode 55</title><link>https://nathannaveen.dev/posts/leetcode-55/</link><pubDate>Tue, 06 Jul 2021 18:24:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-55/</guid><description>55. Jump Game
The idea of this solution is pretty simple once you understand it.
The idea of this solution is:
We get the maximum index we can go up to by getting the maximum of i + nums[i] and max. Then, if i has surpassed the maximum index, we can return false. Otherwise return true. If you don&amp;rsquo;t understand why this works, look at the following example:</description></item><item><title>Leetcode 1828</title><link>https://nathannaveen.dev/posts/leetcode-1828/</link><pubDate>Wed, 16 Jun 2021 11:22:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1828/</guid><description>1828. Queries on Number of Points Inside a Circle
The idea of this solution is to:
loop through the queries and then a nested loop to go through points.
After that we check whether squared(point[0] - query[0]) + squared(point[1] - query[1]) &amp;lt;= squared(query[2]). This is bascily checking whether the distance between two points is smaller than or equal to the radius but edited. This image that I have drawn and wrote up explains this part: (Note: point[0] = x1, query[0] = x2, point[1] = y1, query[1] = y2, query[2] = radius)</description></item><item><title>Leetcode 48</title><link>https://nathannaveen.dev/posts/leetcode-48/</link><pubDate>Wed, 16 Jun 2021 11:22:22 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-48/</guid><description>48. Rotate Image
The idea of this solution is first to flip the matrix, so it is upside down, and then transpose the matrix. If you don&amp;rsquo;t understand, look at the following images:
We flip the matrix by fliping the top and bottom len(matrix) / 2 rows, like in this image:
And transposing the matrix is basically making matrix[i][j] = matrix[j][i], and the flips should only flip from yellow to the blue, or blue to yellow in the following image:</description></item><item><title>Leetcode 1874</title><link>https://nathannaveen.dev/posts/leetcode-1874/</link><pubDate>Wed, 16 Jun 2021 11:22:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1874/</guid><description>1874. Minimize Product Sum of Two Arrays
The idea of both solutions is pretty much the same: The smallest number multiplied by the greatest number always makes the smallest sum. If you don&amp;rsquo;t understand, look at the following image:
In the image above, the top array is sorted in non-decreasing order, and the bottom array is sorted in non-increasing order. So when we multiply nums1[i] and nums2[i] together, we get the minimum product, and when we sum the products up, we get the minimum sum.</description></item><item><title>Leetcode 1689</title><link>https://nathannaveen.dev/posts/leetcode-1689/</link><pubDate>Wed, 16 Jun 2021 11:21:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1689/</guid><description>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
The idea of this solution is that the max digit in n will be the result. But you might be wondering why this works.
This works because the max digit can only be made by adding the max digit number of 1&amp;rsquo;s. If you don&amp;rsquo;t understand, look at the following image: The first image is an example, and the second example is for anyone who doesn&amp;rsquo;t understand the first example.</description></item><item><title>Leetcode 1605</title><link>https://nathannaveen.dev/posts/leetcode-1605/</link><pubDate>Wed, 16 Jun 2021 11:21:28 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1605/</guid><description>1605. Find Valid Matrix Given Row and Column Sums
The idea of this solution is pretty simple:
We loop through len(rowSum), and len(colSum). We find the minimum for colSum[j], and rowSum[i], making the resulting matrix have the minimum. After that, we subtract the minimum from both colSum[j], and rowSum[i].
Here is an image example to help with the explanation:
func restoreMatrix(rowSum []int, colSum []int) [][]int { res := make([][]int, len(rowSum)) for i := 0; i &amp;lt; len(rowSum); i++ { arr := make([]int, len(colSum)) for j := 0; j &amp;lt; len(colSum); j++ { arr[j] = colSum[j] if colSum[j] &amp;gt; rowSum[i] { arr[j] = rowSum[i] } rowSum[i], colSum[j] = rowSum[i] - arr[j], colSum[j] - arr[j] } res[i] = arr } return res }</description></item><item><title>Leetcode 406</title><link>https://nathannaveen.dev/posts/leetcode-406/</link><pubDate>Wed, 16 Jun 2021 11:21:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-406/</guid><description>406. Queue Reconstruction by Height
The idea of this solution is to:
sort people&amp;rsquo;s height in non-decreasing order, and when two people have the same height, we sort their kth place in non-increasing order.
And then we add the following person to the resulting array in the kth vacant position (zero-indexed), like in this image: As you can see in row 1, k = 4, so we add the person of height 4 into res at position 4.</description></item><item><title>Leetcode 1252</title><link>https://nathannaveen.dev/posts/leetcode-1252/</link><pubDate>Mon, 17 May 2021 09:50:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1252/</guid><description>1252. Cells with Odd Values in a Matrix
The idea of this solution is to use two maps, x, and y, and we can add all the values of indices to x, and y (index[0] to x, and index[1] to y).
Then we can check whether all the x&amp;rsquo;s plus all the y&amp;rsquo;s is odd. If so, we know that we can add one to the result.
If you don&amp;rsquo;t understand we can take an example:</description></item><item><title>Leetcode 1572</title><link>https://nathannaveen.dev/posts/leetcode-1572/</link><pubDate>Wed, 05 May 2021 15:45:36 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1572/</guid><description>1572. Matrix Diagonal Sum
The idea of the first solution is to add all the values in the diagonals, and if len(mat) is odd, we can subtract the middle element from res. You might be able to understand this solution a little more with two example images: The idea of the second solution is to find two positions in the array (Where a position is in the format (x, y)) which are on diagonals and are equal.</description></item><item><title>Leetcode 844</title><link>https://nathannaveen.dev/posts/leetcode-844/</link><pubDate>Wed, 28 Apr 2021 21:33:02 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-844/</guid><description>844. Backspace String Compare
To be truthful I am not sure whether this solution is an O(n) time or a O(2n) time because this code loops through s then t. Could someone tell me which it is?
So the idea of this solution is: *Note: I will be explaining only the loop for s because the loop for s is pretty much the same as the loop for t.
So the code first loops from 0 to len(s).</description></item><item><title>Leetcode 1564</title><link>https://nathannaveen.dev/posts/leetcode-1564/</link><pubDate>Sun, 25 Apr 2021 18:43:09 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1564/</guid><description>1564. Put Boxes Into the Warehouse I
The idea of this solution is:
We sort boxes. Then, we make an array called minimums, and put the minimum values of warehouse from left to right into the array. If you don&amp;rsquo;t understand, look at the following images: Then we can just look from len(minimums) - 1 to 0 and check whether minimums[i] &amp;gt;= boxes[boxCounter] we can go to the next box, other wise we continue going through the loop until minimums[i] &amp;gt;= boxes[boxCounter].</description></item><item><title>Leetcode 892</title><link>https://nathannaveen.dev/posts/leetcode-892/</link><pubDate>Fri, 09 Apr 2021 10:56:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-892/</guid><description>892. Surface Area of 3D Shapes
The Idea Of This Solution:
This solution uses the fact that each stack of cubes surface area is the equation 2 + 4 * v. This works because each cube has 6 sides. This can be shown using some images:
We can see that each cube has 6 planes. There are 4 sides, 1 top, and 1 bottom.
Now, as we can see, there are 10 units of surface area while the other one only had 6, there are 8 sides, 1 top, and 1 bottom.</description></item><item><title>Leetcode 1272</title><link>https://nathannaveen.dev/posts/leetcode-1272/</link><pubDate>Wed, 07 Apr 2021 12:36:27 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1272/</guid><description>1272. Remove Interval
What This Code Is Doing:
We make a new resulting array and then loop through intervals.
What we need to know for the following if and else statements is when the code loops through intervals, we get interval per iteration. interval is in the format [start, end]. Also, the constraints say -10^9 &amp;lt;= start &amp;lt; end &amp;lt;= 10^9, so we can see that start and end are never on the exact same location and the start is always lesser than end.</description></item><item><title>Leetcode 1762</title><link>https://nathannaveen.dev/posts/leetcode-1762/</link><pubDate>Fri, 19 Mar 2021 09:39:06 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1762/</guid><description>1762. Buildings With an Ocean View
The idea of the solution:
The idea of this solution is to loop through the array heights backwards. Then we just have to find if a height that is greater that the curent height. After that we can reverse the resulting array because the problem asks us to give us the sorted array of indexes that have an ocean view.
If you don&amp;rsquo;t understand the explaination just look at the following images:</description></item><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description></item><item><title>Leetcode 1119</title><link>https://nathannaveen.dev/posts/leetcode-1119/</link><pubDate>Thu, 18 Mar 2021 11:32:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1119/</guid><description>1119. Remove Vowels from a String
The first approach is pretty simple. If the letter is not a vowel, add it to a resulting string.
The second approach is better because we keep on using the same string. We remake the string every time there is a vowel by going around the vowel.
This can be shown with some images:
We can have:
input: &amp;quot;leetcode&amp;quot; expected output: &amp;quot;ltcd&amp;quot; We can fast forward to our first vowel, 'e'.</description></item><item><title>Leetcode 1138</title><link>https://nathannaveen.dev/posts/leetcode-1138/</link><pubDate>Thu, 18 Mar 2021 11:32:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1138/</guid><description>1138. Alphabet Board Path
I have to admit the code might look daunting but it is actualy not that complicated after I explain it to you.
What the Problem is asking:
The problem asks us to make a board of letters:
[ [a, b, c, d, e] [f, g, h, i, j] [k, l, m, n, o] [p, q, r, s, t] [u, v, w, x, y] [z] ] Then it gives us a word target.</description></item><item><title>Leetcode 692</title><link>https://nathannaveen.dev/posts/leetcode-692/</link><pubDate>Mon, 15 Mar 2021 11:52:46 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-692/</guid><description>692. Top K Frequent Words
The Main Idea:
This solution first adds the words to an array called frequency and sorts frequency after that, return the k most frequency words.
Adding to the array Frequency:
You might be confused when we do this part:
for _, ints := range frequency { if words[ints[0]] == word { contains = true ints[1]++ break } } We can simplify the if statement into if words[frequency[i][0]] = word.</description></item><item><title>Leetcode 1329</title><link>https://nathannaveen.dev/posts/leetcode-1329/</link><pubDate>Sat, 13 Mar 2021 10:42:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1329/</guid><description>1329. Sort the Matrix Diagonally
The idea of this solution is kind of hard to explain so I will show it with the following images:
i = len(mat), and j = len(mat[0])
The yellow part is every where i and j will iterate
the diagonal lines are in red
Before we continue you might be confused about why we switch 2 and 1 even though i = 1 and j = 1.</description></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty similar to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description></item><item><title>Leetcode 1750</title><link>https://nathannaveen.dev/posts/leetcode-1750/</link><pubDate>Tue, 09 Mar 2021 21:04:18 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1750/</guid><description>1750. Minimum Length of String After Deleting Similar Ends
The idea of this solution is pretty simple, so it can be shown with this image:
func minimumLength(s string) int { for len(s) &amp;gt; 1 &amp;amp;&amp;amp; s[0] == s[len(s)-1] { end := s[len(s)-1] lenS := len(s) for i := 0; i &amp;lt; lenS; i++ { if s[len(s)-1] != s[0] { s = s[:len(s)-i-1] break } } lenS = len(s) for i := 0; i &amp;lt; lenS; i++ { if s[0] !</description></item><item><title>Leetcode 1752</title><link>https://nathannaveen.dev/posts/leetcode-1752/</link><pubDate>Tue, 09 Mar 2021 21:04:13 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1752/</guid><description>1752. Check if Array Is Sorted and Rotated
The idea of this solution is to loop through the array, and then check whether there is a nums[i] which is greater than nums[(i+1) % len(nums)] (By the way (i+1) % len(nums) is for getting the next number) if nums[i] &amp;gt; nums[(i+1)%len(nums)] then add one to a counter called counter. Then we check whether counter is greater than or equal to 2.</description></item><item><title>Leetcode 915</title><link>https://nathannaveen.dev/posts/leetcode-915/</link><pubDate>Mon, 08 Mar 2021 08:20:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-915/</guid><description>The idea of this solution is to find the max of the left and then check whether the max is always smaller than all the rights. If it is smaller than all of them return the index (1 indexed).
This can be shown with a picture:
func partitionDisjoint(A []int) int { max := A[0] for i := 0; i &amp;lt; len(A); i++ { shouldReturn := true if max &amp;lt; A[i] { max = A[i] } for j := i + 1; j &amp;lt; len(A); j++ { if A[j] &amp;lt; max { shouldReturn = false break } } if shouldReturn { return i + 1 } } return -1 }</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description></item><item><title>Leetcode 347</title><link>https://nathannaveen.dev/posts/leetcode-347/</link><pubDate>Thu, 04 Mar 2021 15:47:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-347/</guid><description>347. Top K Frequent Elements
The idea of this solution is pretty simple. First, add all the numbers to a matrix array with the size [number of different elements][2]. Then sort the array, and then add the values to a regular array of size K.
The matrix array has a size of [number of different elemtnets][2] because we need to add every element to its corresponding place in the array and then update the frequency by adding one to it.</description></item><item><title>Leetcode 1636</title><link>https://nathannaveen.dev/posts/leetcode-1636/</link><pubDate>Wed, 03 Mar 2021 16:02:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1636/</guid><description>1636. Sort Array by Increasing Frequency
The main idea of both the solutions is to add all the numbers to a matrix of lengths [len(nums)][2] and then sort each frequency of numbers by the max frequency. Suppose two values have the same frequency sort them by the value in descending order. After they are sorted, add all the values back to nums and return nums.
This is the sort:
for i := 1; i &amp;lt; len(arr); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; ((arr[i-1][0] &amp;gt; arr[i][0]) || (arr[i-1][0] == arr[i][0] &amp;amp;&amp;amp; arr[i-1][1] &amp;lt; arr[i][1])) { arr[i], arr[i-1] = arr[i-1], arr[i] i -= 2 } } The idea of it is to start at the second item (first if 0 indexed) and then check whether the frequency of the number before the current is greater than the frequency of the current number.</description></item><item><title>Leetcode 459</title><link>https://nathannaveen.dev/posts/leetcode-459/</link><pubDate>Sun, 28 Feb 2021 14:46:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-459/</guid><description>459. Repeated Substring Pattern
The idea of this solution is any substring that is repeated throughout the string s has to start at the 0&amp;lsquo;th index and end at another index, such as the 3&amp;lsquo;ed. This can be shown by using a image.
In both the examples the substrings that are repeated are green.
In the first example the substring abc starts at the 0&amp;lsquo;th index and ends at the 2&amp;rsquo;d index.</description></item><item><title>Leetcode 946</title><link>https://nathannaveen.dev/posts/leetcode-946/</link><pubDate>Fri, 26 Feb 2021 10:59:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-946/</guid><description>The idea of this solution is to append the pushed value to the stack. If peeked value is equal to the poped value then pop it off the stack, keep poping off the peeked value if it is equal to the poped value. This can be show in an image
func validateStackSequences(pushed []int, popped []int) bool { stack := []int{} popCounter := 0 for i := 0; i &amp;lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) !</description></item><item><title>Leetcode 1704</title><link>https://nathannaveen.dev/posts/leetcode-1704/</link><pubDate>Thu, 25 Feb 2021 20:22:25 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1704/</guid><description>The idea of this solution is to first make the input string lowercase, and then add 1 to an integer array at the index of every letter, a = 0, b = 1, c = 2.... First we add to the array called first, then starting at a certain index start adding it to second.
After that, add the number of vowel that have occured. The code does this by doing</description></item><item><title>Leetcode 1296</title><link>https://nathannaveen.dev/posts/leetcode-1296/</link><pubDate>Thu, 25 Feb 2021 15:47:35 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1296/</guid><description>Divide array in sets of k consecutive numbers
The idea of this solution is to loop over the nums array until all the values are -1. The reason they all will become negative one is, whenever a item is used the value will become -1 so the code knows to not use that number again.
If you didn&amp;rsquo;t understand the explanation this can be shown using the code on the bottom, an example and some pictures: By the way sorry if my handwriting is messy</description></item><item><title>Leetcode 1566</title><link>https://nathannaveen.dev/posts/leetcode-1566/</link><pubDate>Thu, 25 Feb 2021 15:46:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1566/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times The idea of this can be show by this image
func containsPattern(arr []int, m int, k int) bool { counter := 0 for i := 0; i &amp;lt; len(arr) - m; i++ { if arr[i] != arr[i+m] { counter = 0 } else { counter++ } if counter == (k-1)*m { return true } } return false }</description></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description></item></channel></rss>