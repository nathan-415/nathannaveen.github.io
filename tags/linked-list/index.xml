<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linked list on nathan naveen</title><link>https://nathannaveen.dev/tags/linked-list/</link><description>Recent content in linked list on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 07 Feb 2022 10:21:53 -0600</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/linked-list/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 23</title><link>https://nathannaveen.dev/posts/leetcode-23/</link><pubDate>Mon, 07 Feb 2022 10:21:53 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-23/</guid><description>23. Merge k Sorted Lists
I think that the idea of this solution can be shown bellow:
func mergeKLists(lists []*ListNode) *ListNode { res := &amp;amp;ListNode{} cur := res done := false for !done { done = true min := 10000 for _, list := range lists { if list != nil &amp;amp;&amp;amp; list.Val &amp;lt; min { min = list.Val done = false } } for i := range lists { if lists[i] !</description></item><item><title>Leetcode 2095</title><link>https://nathannaveen.dev/posts/leetcode-2095/</link><pubDate>Wed, 19 Jan 2022 13:01:36 -0600</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2095/</guid><description>2095. Delete the Middle Node of a Linked List
The idea of this solution is to use three-pointers, like in the following example:
Remember that the hare will always go up two values, while prev and turtle will only go up one.
The hare has reached the end, so we can stop moving the hare, turtle, and prev. Now, we have to remove the turtles position by doing prev.Next = prev.</description></item><item><title>Leetcode 2046</title><link>https://nathannaveen.dev/posts/leetcode-2046/</link><pubDate>Thu, 28 Oct 2021 15:57:20 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-2046/</guid><description>2046. Sort Linked List Already Sorted Using Absolute Values
The idea of this solution is to check whether the current value is smaller than 0. If so, we can remove it from its current position, add it to the beginning of the list, and make that the new beginning.
This solution works because the absolute value of -1 will always be smaller than the absolute value of -5, but -1 is greater than -5.</description></item><item><title>Leetcode 817</title><link>https://nathannaveen.dev/posts/leetcode-817/</link><pubDate>Tue, 06 Jul 2021 18:25:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-817/</guid><description>817. Linked List Components
The idea of this solution is:
We make a map to store all the values in nums because all the values in nums are unordered subsets of our linked list, so finding whether nums contains a value is now done in O(1) time (Note that to get all the values into the map it takes O(n) time). Then all we have to do is loop through our linked list and if m (Our map is called m) contains the current value and it doesn&amp;rsquo;t contain the previous value or the value is the head and m contains the value we know that we have another component.</description></item><item><title>Leetcode 61</title><link>https://nathannaveen.dev/posts/leetcode-61/</link><pubDate>Tue, 06 Jul 2021 18:25:10 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-61/</guid><description>61. Rotate List
The idea of this solution is pretty simple, and I will explain it using this image below:
Note: Before we get into what this picture represents, I want you to know that we already know the length of the linked list because the first loop in the code is for finding the length.
The image above is from the problem description and is showing the input and output as: Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3]</description></item><item><title>Leetcode 1669</title><link>https://nathannaveen.dev/posts/leetcode-1669/</link><pubDate>Tue, 06 Jul 2021 18:24:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1669/</guid><description>1669. Merge In Between Linked Lists
The idea of this solution can be explained with a simple image:
In image 1 we can see the input of list1 = [0, 1, 2, 3, 4, 5], list2 = [10, 11, 12], a = 3, and b = 4. We can iterate through list2 and store the beginning and end of the list. Then, we can iterate through list1 and find the pos of a - 1.</description></item><item><title>Leetcode 1721</title><link>https://nathannaveen.dev/posts/leetcode-1721/</link><pubDate>Sun, 14 Mar 2021 15:57:58 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1721/</guid><description>1721. Swapping Nodes in a Linked List
The idea of this solution is pretty simple.
First, we find the length of the linked list Next, we iterate through the linked list up until the ending kth node And then we iterate through the linked list to to kth node Then, last of all, switch the value of the kth node with the value of the kth node from the end.</description></item></channel></rss>