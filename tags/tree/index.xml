<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tree on nathan naveen</title><link>https://nathannaveen.dev/tags/tree/</link><description>Recent content in tree on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 25 Jul 2021 18:33:21 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 199</title><link>https://nathannaveen.dev/posts/leetcode-199/</link><pubDate>Sun, 25 Jul 2021 18:33:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-199/</guid><description>199. Binary Tree Right Side View
The idea of both solutions is pretty simple, we just use BFS to iterate through all the rows and append the last element in the row (The right most element).
Iterative:
func rightSideView(root *TreeNode) []int { res := []int{} if root != nil { queue := []*TreeNode{ root } for len(queue) != 0 { n := len(queue) res = append(res, queue[n - 1].Val) for i := 0; i &amp;lt; n; i++ { pop := queue[0] queue = queue[1:] if pop.</description></item><item><title>Leetcode 590</title><link>https://nathannaveen.dev/posts/leetcode-590/</link><pubDate>Sun, 25 Jul 2021 18:32:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-590/</guid><description>590. N-ary Tree Postorder Traversal
The First Solution:
This solution seems pretty self-explanatory.
func postorder(root *Node) []int { return helper(root, []int{}) } func helper(r *Node, l []int)[]int{ if r != nil{ for _,item := range r.Children{ l = helper(item,l) } l = append(l,r.Val) } return l } The Second Solution:
If you look at the following code and don&amp;rsquo;t understand, it is probably because of: r.Children[len(r.Children) - i - 1], but if you look at it carefully, you will see that it is the same as reversing r.</description></item><item><title>Leetcode 987</title><link>https://nathannaveen.dev/posts/leetcode-987/</link><pubDate>Sun, 25 Jul 2021 18:32:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-987/</guid><description>987. Vertical Order Traversal of a Binary Tree
I know that this solution is very cumbersome and annoying, so I am just going to explain what the main idea is:
We first use BFS to find every node with its row and column and store those values in an array. Then, we add all the values from the array to a matrix array which stores the nodes value and the row of the node in the position of the column.</description></item><item><title>Leetcode 958</title><link>https://nathannaveen.dev/posts/leetcode-958/</link><pubDate>Wed, 05 May 2021 15:45:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-958/</guid><description>958. Check Completeness of a Binary Tree
This solution uses the facts that:
If there is a next row, we know that the whole row has to be full If there is no next row, all the nodes have to be to the left. If you have already looked at the code, you might have seen that we check whether there is a next row by checking whether queue[0].</description></item><item><title>Leetcode 103</title><link>https://nathannaveen.dev/posts/leetcode-103/</link><pubDate>Mon, 03 May 2021 10:26:05 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-103/</guid><description>103. Binary Tree Zigzag Level Order Traversal
The idea of this solution is to use BFS and a variable called fromRight. The fromRight checks whether the current row needs to be traversed from the right. If it does, we prepend all the nodes to temp.
func zigzagLevelOrder(root *TreeNode) [][]int { var res [][]int queue := []*TreeNode{root} fromRight := false for len(queue) != 0 { temp := []int{} n := len(queue) for i := 0; i &amp;lt; n; i++ { node := queue[0] queue = queue[1:] if node !</description></item><item><title>Leetcode 1609</title><link>https://nathannaveen.dev/posts/leetcode-1609/</link><pubDate>Mon, 03 May 2021 10:17:57 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1609/</guid><description>1609. Even Odd Tree
The main idea of this solution is to use BFS, but the details are:
We have a counter called row to count every row (We use this to check whether it is an even row or an odd row). Then we have a queue that has only the root to start. We loop while len(queue) != 0 Then we make a variable n equal to the len(queue).</description></item><item><title>Leetcode 1602</title><link>https://nathannaveen.dev/posts/leetcode-1602/</link><pubDate>Mon, 03 May 2021 10:17:00 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1602/</guid><description>1602. Find Nearest Right Node in Binary Tree
The idea of this solution is to use a queue to loop through the tree, and then for every node we loop through, we check whether the node.Val == u.Val, if so, we go through the if statement if i == n - 1. Using this, we know whether the node is the last. If so, we return nil. Else we return the node after the current node.</description></item><item><title>Leetcode 1161</title><link>https://nathannaveen.dev/posts/leetcode-1161/</link><pubDate>Mon, 03 May 2021 10:16:45 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1161/</guid><description>1161. Maximum Level Sum of a Binary Tree
What the Problem is Asking Us:
The problem is asking us to go through each level of the binary tree and find the maximum sum and make that the returned level, but if the maximum sum is on two levels, we get the minimum level of those two.
The Code:
func maxLevelSum(root *TreeNode) int { maximum, minLevel, level := root.Val, 1, 0 queue := []*TreeNode{root} for len(queue) !</description></item><item><title>Leetcode 1214</title><link>https://nathannaveen.dev/posts/leetcode-1214/</link><pubDate>Sun, 21 Mar 2021 11:36:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1214/</guid><description>1214. Two Sum BSTs
Quick Run-Down On The Solutions
The first solution is the easiest of the three solutions and the worst-time complexity solution. The second solution has a different approach from the first solution and a little better time but still not that great. The third solution has a lot better time than the first two solutions and has a similar approach to the second solution. The Ideas of These Solutions:</description></item><item><title>Leetcode 272</title><link>https://nathannaveen.dev/posts/leetcode-272/</link><pubDate>Fri, 19 Mar 2021 09:50:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-272/</guid><description>272. Closest Binary Search Tree Value II
The idea of this solution is pretty simple, we just iterate through the tree and append the absolute difference between the popped value and target to an array called differences, then we append the popped value to an array called eachNumber. After we have iterated through the whole array we can sort the difference array while sorting the eachNumber array. After that we return the first k numbers from eachNumber.</description></item><item><title>Leetcode 1469</title><link>https://nathannaveen.dev/posts/leetcode-1469/</link><pubDate>Thu, 18 Mar 2021 14:11:02 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1469/</guid><description>1469. Find All The Lonely Nodes
The idea of this solution is pretty simple, there are just four conditions:
if there is a left node but not a right node if there is a right node but not a left node if there is both a left and a right node if there are neither a left or a right node We can ignore the part where there is neither a left or a right node.</description></item><item><title>Leetcode 270</title><link>https://nathannaveen.dev/posts/leetcode-270/</link><pubDate>Thu, 18 Mar 2021 14:10:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-270/</guid><description>270. Closest Binary Search Tree Value
The idea of this solution is pretty simple. We have to iterate through the tree and then find the absolute minimum difference between the target and the value from the tree. (Keep in mind that we want everything to be a float64, so then we get proper comparisons). This can be shown with the equation:
The Code:
func closestValue(root *TreeNode, target float64) int { stack := []*TreeNode{root} minimum := float64(1000000000) number := 0 for len(stack) !</description></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description></item></channel></rss>