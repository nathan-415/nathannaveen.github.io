<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tree on nathan naveen</title><link>https://nathannaveen.dev/tags/tree/</link><description>Recent content in tree on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 18 Mar 2021 14:11:02 -0400</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1469</title><link>https://nathannaveen.dev/posts/leetcode-1469/</link><pubDate>Thu, 18 Mar 2021 14:11:02 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1469/</guid><description>1469. Find All The Lonely Nodes
The idea of this solution is pretty simple, there are just four conditions:
if there is a left node but not a right node if there is a right node but not a left node if there is both a left and a right node if there are neither a left or a right node We can ignore the part where there is neither a left or a right node.</description></item><item><title>Leetcode 270</title><link>https://nathannaveen.dev/posts/leetcode-270/</link><pubDate>Thu, 18 Mar 2021 14:10:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-270/</guid><description>270. Closest Binary Search Tree Value
The idea of this solution is pretty simple. We have to iterate through the tree and then find the absolute minimum difference between the target and the value from the tree. (Keep in mind that we want everything to be a float64, so then we get proper comparisons). This can be shown with the equation:
The Code:
func closestValue(root *TreeNode, target float64) int { stack := []*TreeNode{root} minimum := float64(1000000000) number := 0 for len(stack) !</description></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description></item></channel></rss>