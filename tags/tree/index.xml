<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tree on nathan naveen</title><link>https://nathannaveen.dev/tags/tree/</link><description>Recent content in tree on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 21 Mar 2021 11:36:17 -0400</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1214</title><link>https://nathannaveen.dev/posts/leetcode-1214/</link><pubDate>Sun, 21 Mar 2021 11:36:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1214/</guid><description>This is a simple depth-first-search (dfs) solution. We first iterate through the first tree and then the second tree. We add all the values from the first tree to the array arr1 and then add the second tree&amp;rsquo;s values to the array arr2. After that, we find whether two values from arr1, arr2 summed up equals target return true.
func twoSumBSTs(root1 *TreeNode, root2 *TreeNode, target int) bool { stack := []*TreeNode{root1} arr1 := []int{} arr2 := []int{} for len(stack) !</description></item><item><title>Leetcode 272</title><link>https://nathannaveen.dev/posts/leetcode-272/</link><pubDate>Fri, 19 Mar 2021 09:50:42 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-272/</guid><description>272. Closest Binary Search Tree Value II
The idea of this solution is pretty simple, we just iterate through the tree and append the absolute difference between the popped value and target to an array called differences, then we append the popped value to an array called eachNumber. After we have iterated through the whole array we can sort the difference array while sorting the eachNumber array. After that we return the first k numbers from eachNumber.</description></item><item><title>Leetcode 1469</title><link>https://nathannaveen.dev/posts/leetcode-1469/</link><pubDate>Thu, 18 Mar 2021 14:11:02 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1469/</guid><description>1469. Find All The Lonely Nodes
The idea of this solution is pretty simple, there are just four conditions:
if there is a left node but not a right node if there is a right node but not a left node if there is both a left and a right node if there are neither a left or a right node We can ignore the part where there is neither a left or a right node.</description></item><item><title>Leetcode 270</title><link>https://nathannaveen.dev/posts/leetcode-270/</link><pubDate>Thu, 18 Mar 2021 14:10:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-270/</guid><description>270. Closest Binary Search Tree Value
The idea of this solution is pretty simple. We have to iterate through the tree and then find the absolute minimum difference between the target and the value from the tree. (Keep in mind that we want everything to be a float64, so then we get proper comparisons). This can be shown with the equation:
The Code:
func closestValue(root *TreeNode, target float64) int { stack := []*TreeNode{root} minimum := float64(1000000000) number := 0 for len(stack) !</description></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description></item></channel></rss>