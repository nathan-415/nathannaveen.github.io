<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>math on nathan naveen</title><link>https://nathannaveen.dev/tags/math/</link><description>Recent content in math on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Tue, 06 Jul 2021 18:25:01 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 504</title><link>https://nathannaveen.dev/posts/leetcode-504/</link><pubDate>Tue, 06 Jul 2021 18:25:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-504/</guid><description>504. Base 7
The main idea of both solutions is to convert the number to base seven. To convert a number to base 7 we can do something similar to converting to base 2, 3, 4 and so on. So if you know how to convert a number to another base you can just scroll down to the code and skip the example image.
Using Math, and then returning string(res):</description></item><item><title>Leetcode 1828</title><link>https://nathannaveen.dev/posts/leetcode-1828/</link><pubDate>Wed, 16 Jun 2021 11:22:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1828/</guid><description>1828. Queries on Number of Points Inside a Circle
The idea of this solution is to:
loop through the queries and then a nested loop to go through points.
After that we check whether squared(point[0] - query[0]) + squared(point[1] - query[1]) &amp;lt;= squared(query[2]). This is bascily checking whether the distance between two points is smaller than or equal to the radius but edited. This image that I have drawn and wrote up explains this part: (Note: point[0] = x1, query[0] = x2, point[1] = y1, query[1] = y2, query[2] = radius)</description></item><item><title>Leetcode 1837</title><link>https://nathannaveen.dev/posts/leetcode-1837/</link><pubDate>Wed, 16 Jun 2021 11:22:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1837/</guid><description>1837. Sum of Digits in Base K
Before I explain both solution I just want to say that for me the first solution is not as readable as the second solution but easyer to understand (Note: I wrote the first solution before the second solution so that might be why).
The first solution basicly uses the fact that n only goes up to 100 and that k has a range of 2 to 10</description></item><item><title>Leetcode 1854</title><link>https://nathannaveen.dev/posts/leetcode-1854/</link><pubDate>Wed, 16 Jun 2021 11:22:38 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1854/</guid><description>1854. Maximum Population Year
I first did this solution using an O(n^2) approach but then tried to think about how to do it better. I couldn&amp;rsquo;t, so I looked at the discussion and saw votrubac solution. The code below is pretty similar, except I make an array of size 101 instead of 2051 because we only need the years from 2050 to 1950.
func maximumPopulation(logs [][]int) int { populationPerYear := make([]int, 101) res := 0 for _, log := range logs { populationPerYear[log[0] - 1950]++ populationPerYear[log[1] - 1950]-- } for i := 1; i &amp;lt; 101; i++ { populationPerYear[i] += populationPerYear[i - 1] if populationPerYear[i] &amp;gt; populationPerYear[res] { res = i } } return res + 1950 }</description></item><item><title>Leetcode 1874</title><link>https://nathannaveen.dev/posts/leetcode-1874/</link><pubDate>Wed, 16 Jun 2021 11:22:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1874/</guid><description>1874. Minimize Product Sum of Two Arrays
The idea of both solutions is pretty much the same: The smallest number multiplied by the greatest number always makes the smallest sum. If you don&amp;rsquo;t understand, look at the following image:
In the image above, the top array is sorted in non-decreasing order, and the bottom array is sorted in non-increasing order. So when we multiply nums1[i] and nums2[i] together, we get the minimum product, and when we sum the products up, we get the minimum sum.</description></item><item><title>Leetcode 1403</title><link>https://nathannaveen.dev/posts/leetcode-1403/</link><pubDate>Wed, 16 Jun 2021 11:22:07 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1403/</guid><description>1403. Minimum Subsequence in Non-Increasing Order
The idea of this solution is pretty simple, we first sort nums in non-increasing order and then find the sum of nums. After that, we can loop through nums and subtract the greatest numbers in nums from the total sum and add the greatest numbers in nums to a different sum. And then, we append the num to res (the resulting function). If the other sum is greater than the total sum, we can break out of the loop and return res.</description></item><item><title>Leetcode 1689</title><link>https://nathannaveen.dev/posts/leetcode-1689/</link><pubDate>Wed, 16 Jun 2021 11:21:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1689/</guid><description>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers
The idea of this solution is that the max digit in n will be the result. But you might be wondering why this works.
This works because the max digit can only be made by adding the max digit number of 1&amp;rsquo;s. If you don&amp;rsquo;t understand, look at the following image: The first image is an example, and the second example is for anyone who doesn&amp;rsquo;t understand the first example.</description></item><item><title>Leetcode 36</title><link>https://nathannaveen.dev/posts/leetcode-36/</link><pubDate>Mon, 17 May 2021 09:32:30 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-36/</guid><description>36. Valid Sudoku
The main idea of this solution is to find the rows, columns, and squares of the numbers. By squares, I mean the nine squares in the board:
The code goes through every position, and if the value is not a &amp;quot;.&amp;quot;, we check whether the row, column, or square contains the number. If so, we can return false.
How to Calculate The Rows And Columns
We check whether the row or column contains the number by using primes.</description></item><item><title>Leetcode 1232</title><link>https://nathannaveen.dev/posts/leetcode-1232/</link><pubDate>Sun, 25 Apr 2021 21:15:52 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1232/</guid><description>1232. Check If It Is a Straight Line
The idea of this solution is we use 3 points to find whether two slopes are equal. We can use the equation:where x0, x1, x2, y0, y1, y2 are all coordinates: You might not understand the equation, so we can multiply divide both sides by (x1 - x0) and (x2 - x1) and we can get: The equation above is based off of a familar slope equation: The reason we are doing the original equation instead of the where we have divided both sides by (x1 - x0) and (x2 - x1) is we don&amp;rsquo;t have to worry about dividing by 0 such as when we divide both sides by (x1 - x0) and (x2 - x1) but (x1 - x0) = 0 or (x2 - x1) = 0 we have to contumplate what to do.</description></item><item><title>Leetcode 748</title><link>https://nathannaveen.dev/posts/leetcode-748/</link><pubDate>Sun, 25 Apr 2021 11:08:04 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-748/</guid><description>Shortest Completing Word
Here is how I got to this solution. I couldn&amp;rsquo;t think of any way to solve this problem without doing a naive solution, so I looked at the discussion and saw jmcelvenny&amp;rsquo;s solution.
The idea of this solution is:
we get all the letters in licensePlate and multiply each letter&amp;rsquo;s prime number to a variable called product. We have an array of 26 prime numbers, so each letter has its own prime number (upper case and lower case of the same letter share a prime number), such as a : primes[0], b : primes[1], c : primes[2], and A : primes[0], B : primes[1], C : primes[2].</description></item><item><title>Leetcode 1176</title><link>https://nathannaveen.dev/posts/leetcode-1176/</link><pubDate>Mon, 19 Apr 2021 10:48:25 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1176/</guid><description>1176. Diet Plan Performance
This is how the code works:
We sum up the first k elements. Then compare whether sum is greater than upper or smaller than lower. After comparing we can loop from k to len(calories). Then we can take off the beggining of the subarray by subtracting calories[i - k]. And then we have to add the next element from the end of the subarray to the end to the subarray, we do this by adding calories[i].</description></item><item><title>Leetcode 1323</title><link>https://nathannaveen.dev/posts/leetcode-1323/</link><pubDate>Mon, 19 Apr 2021 10:48:16 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1323/</guid><description>1323. Maximum 69 Number
This solution is pretty simple once you understand it.
The idea of this solution is since 9 - 6 = 3, so 6 + 3 = 9. When we add 3 * the current place value to 6 * the current place value we get 9 * the current place value. So if we do 60 + (3 * 10) = 90, 600 + (3 * 100) = 900, 6000 + (3 * 1000) = 9000.</description></item><item><title>Leetcode 1822</title><link>https://nathannaveen.dev/posts/leetcode-1822/</link><pubDate>Thu, 15 Apr 2021 09:40:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1822/</guid><description>1822. Sign of the Product of an Array
The idea of this solution is elementary:
If the current number in nums is negative, then we can flip the sign If the current number in nums is equal to 0, we can return 0 because any number multiplied by 0 is 0. You might think that we can check for if num == 0 after we have iterated, but that won&amp;rsquo;t work because we only switch the sign and don&amp;rsquo;t multiply by 0, so we will never know whether there is a 0 in the array.</description></item><item><title>Leetcode 118</title><link>https://nathannaveen.dev/posts/leetcode-118/</link><pubDate>Wed, 14 Apr 2021 12:29:07 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-118/</guid><description>118. Pascal&amp;rsquo;s Triangle
The idea of this solution is pretty simple:
We first have a matrix array called res Then we loop through numRows While iterating through numRows we have to make an array called temp. It is going to be our current row. We make temp[0] and temp[len(temp)] equal to 1 so we get the outer 1&amp;rsquo;s. Then we loop through the middle elements (basically excluding the outside 1&amp;rsquo;s) We have to make every temp[j] equal to the previous rows previous rows[j - 1] + previous rows[j].</description></item><item><title>Leetcode 1551</title><link>https://nathannaveen.dev/posts/leetcode-1551/</link><pubDate>Sat, 10 Apr 2021 20:14:34 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1551/</guid><description>1551. Minimum Operations to Make Array Equal
This is a pretty simple solution once you understand the concept.
What the Problem Is Asking:
The problem gives us an array where arr[i] = (2 * i) + 1, you could make an array where every arr[i] = (2 * i) + 1 but I am just going to tell you that this plots a sequence of odd integers. Bascily arr[1, 3, 5 .</description></item><item><title>Leetcode 892</title><link>https://nathannaveen.dev/posts/leetcode-892/</link><pubDate>Fri, 09 Apr 2021 10:56:50 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-892/</guid><description>892. Surface Area of 3D Shapes
The Idea Of This Solution:
This solution uses the fact that each stack of cubes surface area is the equation 2 + 4 * v. This works because each cube has 6 sides. This can be shown using some images:
We can see that each cube has 6 planes. There are 4 sides, 1 top, and 1 bottom.
Now, as we can see, there are 10 units of surface area while the other one only had 6, there are 8 sides, 1 top, and 1 bottom.</description></item><item><title>Leetcode 874</title><link>https://nathannaveen.dev/posts/leetcode-874/</link><pubDate>Wed, 07 Apr 2021 12:36:17 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-874/</guid><description>874. Walking Robot Simulation
Warning: This solution is pretty annoying.
What The Problem is Telling Us:
The problem description says that they will give an array called commands that tell you to turn right, left, or move forward, and they will also give you a matrix array called obstacles. obstacles is pretty self-explanatory. It is points where an obstacle is at. The points are in the format of (x, y).</description></item><item><title>Leetcode 633</title><link>https://nathannaveen.dev/posts/leetcode-633/</link><pubDate>Mon, 05 Apr 2021 12:24:12 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-633/</guid><description>633. Sum of Square Numbers
Both solutions use the simple knowledge of:
If c = a^2 + b^2 then b^2 = c - a^2 and a^2 = c - b^2.
The Idea of the First Solution:
The idea of this solution is pretty simple since we know that a^2 = c - b^2 we can store a^2 in a map called m, and then we check whether m contains c - b^2.</description></item><item><title>Leetcode 1465</title><link>https://nathannaveen.dev/posts/leetcode-1465/</link><pubDate>Mon, 05 Apr 2021 12:23:52 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1465/</guid><description>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts
What The Problem Is Asking:
The problem is telling us that there are cuts in a rectangular cake of width w and height h. The cuts are only horizontal and vertical.
The problem wants us to find the largest slice of cake.
The Main Idea of This Solution:
We can find the maximum area slice by finding the maximum vertical length between each horizontal portion and the maximum horizontal length between each slice and then multiplying them together to get the maximum area.</description></item><item><title>Leetcode 1118</title><link>https://nathannaveen.dev/posts/leetcode-1118/</link><pubDate>Thu, 01 Apr 2021 13:15:33 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1118/</guid><description>1118. Number of Days in a Month
To start, I wouldn&amp;rsquo;t say that this is a good interview problem because it is not an algorithmic problem.
The months and the number of days in each month can be shown in the table below:
In February, it can be either 28 days or 29 days. 28 days in a regular year and 29 days in a leap year.
We can see that if the month is January, March, May, July, August, October, December, we return 31 days.</description></item><item><title>Leetcode 246</title><link>https://nathannaveen.dev/posts/leetcode-246/</link><pubDate>Thu, 01 Apr 2021 10:34:39 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-246/</guid><description>246. Strobogrammatic Number
This solution is pretty simple and pretty similar to Leetcode 163.
The problem asks us to flip a number by 180 degrees and then return true if the fliped number is equal to the non-fliped number.
You might think that just flipping every digit and then check whether the following fliped number is equal to the non fliped number, but there is a problem with just flipping. Here is an example to show that just flipping doesn&amp;rsquo;t work:</description></item><item><title>Leetcode 1427</title><link>https://nathannaveen.dev/posts/leetcode-1427/</link><pubDate>Tue, 30 Mar 2021 13:23:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1427/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 360</title><link>https://nathannaveen.dev/posts/leetcode-360/</link><pubDate>Tue, 23 Mar 2021 12:20:59 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-360/</guid><description>360. Sort Transformed Array
The idea of this solution is to loop through nums and do the quadratic equation f(x) = ax^2 + bx + c where x = nums[i] and then make nums[i] the result of the ax^2 + bx + c. After that we can sort and return nums.
Solution Using Manual Sort
func sortTransformedArray(nums []int, a int, b int, c int) []int { for i := 0; i &amp;lt; len(nums); i++ { nums[i] = a*nums[i]*nums[i] + b*nums[i] + c } for i := 1; i &amp;lt; len(nums); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i-1] { nums[i], nums[i-1] = nums[i-1], nums[i] i -= 2 } } return nums } The Same Solution But Using a Built In Sort:</description></item><item><title>Leetcode 1134</title><link>https://nathannaveen.dev/posts/leetcode-1134/</link><pubDate>Thu, 18 Mar 2021 17:44:12 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1134/</guid><description>1134. Armstrong Number
The idea of this solution is to just loop through every digit of n then add the n^(lengthOfNumber) to a variable called sum, then we return sum == n.
func isArmstrong(n int) bool { lengthOfNumber := len(strconv.Itoa(n)) sum := 0 newN := n for newN &amp;gt; 0 { sum += powerOfK(lengthOfNumber, newN%10) newN /= 10 } return sum == n } func powerOfK(lengthOfNumber, n int) int { res := 1 for i := 0; i &amp;lt; lengthOfNumber; i++ { res *= n } return res }</description></item><item><title>Leetcode 1085</title><link>https://nathannaveen.dev/posts/leetcode-1085/</link><pubDate>Thu, 18 Mar 2021 17:43:55 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1085/</guid><description>1085. Sum of Digits in the Minimum Number
The idea of the first two solutions is pretty simple. We sort the array A and then we just find the sum of the digits of the smallest number.
The idea of the second solution is pretty simple as well. We loop through A and find the minimum value, and the find the sum of the digits of the smallest number.
Solution: (Using a manual sort).</description></item><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description></item><item><title>Leetcode 1041</title><link>https://nathannaveen.dev/posts/leetcode-1041/</link><pubDate>Tue, 16 Mar 2021 12:41:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1041/</guid><description>1041. Robot Bounded In Circle
What the problem is asking:
The problem says that it will give a string with the letters &amp;quot;L&amp;quot;, &amp;quot;R&amp;quot; and &amp;quot;G&amp;quot; to command a robot. &amp;quot;L&amp;quot; means to turn left 90 degrees, &amp;quot;R&amp;quot; means to turn right 90 degrees, and &amp;quot;G&amp;quot; means to go forward one unit. The problem says to return true if the robot can continue in that pattern forever and keep going in a circle.</description></item><item><title>Leetcode 1461</title><link>https://nathannaveen.dev/posts/leetcode-1461/</link><pubDate>Fri, 12 Mar 2021 12:03:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1461/</guid><description>1461. Check If a String Contains All Binary Codes of Size K
The idea of this solution is to make a sliding window and add all the substrings os size k to a map, if the maps length is equal to 2^k return true.
We do 2^k because we have to acount for all posibilitys of 0 and 1.
func hasAllCodes(s string, k int) bool { m := make(map[string]int) for i := 0; i &amp;lt; len(s)-k+1; i++ { m[s[i:i+k]]++ } return len(m) == twoPow(k) } func twoPow(k int) int { res := 1 for i := 0; i &amp;lt; k; i++ { res *= 2 } return res } By using bit maniplation we can simplify the code, left shifting is basicly multiplying by 2.</description></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty similar to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description></item></channel></rss>