<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>math on nathan naveen</title><link>https://nathannaveen.dev/tags/math/</link><description>Recent content in math on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 01 Apr 2021 10:34:39 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 246</title><link>https://nathannaveen.dev/posts/leetcode-246/</link><pubDate>Thu, 01 Apr 2021 10:34:39 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-246/</guid><description>246. Strobogrammatic Number
This solution is pretty simple and pretty similar to Leetcode 163.
The problem asks us to flip a number by 180 degrees and then return true if the fliped number is equal to the non-fliped number.
You might think that just flipping every digit and then check whether the following fliped number is equal to the non fliped number, but there is a problem with just flipping. Here is an example to show that just flipping doesn&amp;rsquo;t work:</description></item><item><title>Leetcode 1427</title><link>https://nathannaveen.dev/posts/leetcode-1427/</link><pubDate>Tue, 30 Mar 2021 13:23:55 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1427/</guid><description>1427. Perform String Shifts
The idea of this solution is pretty simple.
Since there are only two directions, we can shift the strings in one direction. The reason we can shift in only one direction is when the input tells us to shift
First left and then right: The right might cancel out the left and will end up with no shift. The right might be greater than the left, so we shift right.</description></item><item><title>Leetcode 360</title><link>https://nathannaveen.dev/posts/leetcode-360/</link><pubDate>Tue, 23 Mar 2021 12:20:59 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-360/</guid><description>360. Sort Transformed Array
The idea of this solution is to loop through nums and do the quadratic equation f(x) = ax^2 + bx + c where x = nums[i] and then make nums[i] the result of the ax^2 + bx + c. After that we can sort and return nums.
Solution Using Manual Sort
func sortTransformedArray(nums []int, a int, b int, c int) []int { for i := 0; i &amp;lt; len(nums); i++ { nums[i] = a*nums[i]*nums[i] + b*nums[i] + c } for i := 1; i &amp;lt; len(nums); i++ { if i &amp;gt;= 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i-1] { nums[i], nums[i-1] = nums[i-1], nums[i] i -= 2 } } return nums } The Same Solution But Using a Built In Sort:</description></item><item><title>Leetcode 1134</title><link>https://nathannaveen.dev/posts/leetcode-1134/</link><pubDate>Thu, 18 Mar 2021 17:44:12 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1134/</guid><description>1134. Armstrong Number
The idea of this solution is to just loop through every digit of n then add the n^(lengthOfNumber) to a variable called sum, then we return sum == n.
func isArmstrong(n int) bool { lengthOfNumber := len(strconv.Itoa(n)) sum := 0 newN := n for newN &amp;gt; 0 { sum += powerOfK(lengthOfNumber, newN%10) newN /= 10 } return sum == n } func powerOfK(lengthOfNumber, n int) int { res := 1 for i := 0; i &amp;lt; lengthOfNumber; i++ { res *= n } return res }</description></item><item><title>Leetcode 1085</title><link>https://nathannaveen.dev/posts/leetcode-1085/</link><pubDate>Thu, 18 Mar 2021 17:43:55 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1085/</guid><description>1085. Sum of Digits in the Minimum Number
The idea of the first two solutions is pretty simple. We sort the array A and then we just find the sum of the digits of the smallest number.
The idea of the second solution is pretty simple as well. We loop through A and find the minimum value, and the find the sum of the digits of the smallest number.
Solution: (Using a manual sort).</description></item><item><title>Leetcode 292</title><link>https://nathannaveen.dev/posts/leetcode-292/</link><pubDate>Thu, 18 Mar 2021 12:19:52 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-292/</guid><description>292. Nim Game
func canWinNim(n int) bool { return n%4 != 0 } This is all the code we need to solve this problem.
We have to return n % 4 != 0 because we are asked to pick from 1 to 3 stones, and if we pick;
If we pick one stone, the other player can choose three stones If we pick two stones, the other player can select two stones If we pick three stones, the other player can choose one stone As you can see, when we add the stones together in the examples above, they all equal 4 stones.</description></item><item><title>Leetcode 1041</title><link>https://nathannaveen.dev/posts/leetcode-1041/</link><pubDate>Tue, 16 Mar 2021 12:41:13 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1041/</guid><description>1041. Robot Bounded In Circle
What the problem is asking:
The problem says that it will give a string with the letters &amp;quot;L&amp;quot;, &amp;quot;R&amp;quot; and &amp;quot;G&amp;quot; to command a robot. &amp;quot;L&amp;quot; means to turn left 90 degrees, &amp;quot;R&amp;quot; means to turn right 90 degrees, and &amp;quot;G&amp;quot; means to go forward one unit. The problem says to return true if the robot can continue in that pattern forever and keep going in a circle.</description></item><item><title>Leetcode 1461</title><link>https://nathannaveen.dev/posts/leetcode-1461/</link><pubDate>Fri, 12 Mar 2021 12:03:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1461/</guid><description>1461. Check If a String Contains All Binary Codes of Size K
The idea of this solution is to make a sliding window and add all the substrings os size k to a map, if the maps length is equal to 2^k return true.
We do 2^k because we have to acount for all posibilitys of 0 and 1.
func hasAllCodes(s string, k int) bool { m := make(map[string]int) for i := 0; i &amp;lt; len(s)-k+1; i++ { m[s[i:i+k]]++ } return len(m) == twoPow(k) } func twoPow(k int) int { res := 1 for i := 0; i &amp;lt; k; i++ { res *= 2 } return res } By using bit maniplation we can simplify the code, left shifting is basicly multiplying by 2.</description></item><item><title>Leetcode 1401</title><link>https://nathannaveen.dev/posts/leetcode-1401/</link><pubDate>Fri, 12 Mar 2021 11:01:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1401/</guid><description>1401. Circle and Rectangle Overlapping
The Main Idea
The idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.
If you don&amp;rsquo;t understand, look at the following images:
As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle.</description></item><item><title>Leetcode 836</title><link>https://nathannaveen.dev/posts/leetcode-836/</link><pubDate>Wed, 10 Mar 2021 12:10:01 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-836/</guid><description>836. Rectangle Overlap
This solution is pretty simular to my other solution Leetcode: 223 This is the part in the other solution which I based this solution on:
// A = rec1[0], B = rec1[1], C = rec1[2], D = rec1[3] // E = rec2[0], F = rec2[1], G = rec2[2], H = rec2[3] left, right := max(A, E), min(G, C) up, down := min(D, H), max(F, B) if right &amp;gt; left &amp;amp;&amp;amp; up &amp;gt; down { sum -= (right - left) * (up - down) // overlap } The idea of this solution can be shown using some images:</description></item><item><title>Leetcode 973</title><link>https://nathannaveen.dev/posts/leetcode-973/</link><pubDate>Sun, 07 Mar 2021 10:43:03 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-973/</guid><description>973. K Closest Points to Origin
The New Distance Formula:
The Euclidean Distance Formula equals (I have drawn this in a picture because the symbols don&amp;rsquo;t aline up when writen up in text)
This can be simplifyed by taking out the square root. We can take out the square root because we are not finding the minimum distance but the point with the minimum distance, and the distance doesn&amp;rsquo;t need to be square rooted.</description></item><item><title>Leetcode 1779</title><link>https://nathannaveen.dev/posts/leetcode-1779/</link><pubDate>Sat, 06 Mar 2021 19:05:54 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1779/</guid><description>1779. Find Nearest Point That Has the Same X or Y Coordinate
What The Problem Is Asking:
This problem asks you to find the smallest Manhattan distance from a given point to a matrix array of points called points.
The problem also asks you to only find the Manhattan distance of the points that have the same x value as the first given point, or the same y value as the given point.</description></item><item><title>Leetcode 223</title><link>https://nathannaveen.dev/posts/leetcode-223/</link><pubDate>Fri, 05 Mar 2021 11:04:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-223/</guid><description>223. Rectangle Area
The main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them.
If you don&amp;rsquo;t understand the ABCDRectangle and the EFGHRectangle then look at the following images:
We can have the example:
Let us start of with the ABCDRectangle:
When we do the equation (D - B) * (C - A) we are basicly doing width * length.</description></item><item><title>Leetcode 908</title><link>https://nathannaveen.dev/posts/leetcode-908/</link><pubDate>Thu, 04 Mar 2021 15:47:37 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-908/</guid><description>908. Smallest Range I
func smallestRangeI(A []int, K int) int { max, min := A[0], A[0] for _, i := range A { if i &amp;gt; max {max = i} if i &amp;lt; min {min = i} } if max-min-2*K &amp;gt; 0 { return max - min - 2 * K } return 0 }</description></item><item><title>Leetcode 1385</title><link>https://nathannaveen.dev/posts/leetcode-1385/</link><pubDate>Wed, 03 Mar 2021 13:25:26 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1385/</guid><description>1385. Find the Distance Value Between Two Arrays
The idea of this solution is to iterate through arr1 and then inside each iteration iterate through arr2. If the absolute value of arr1[i] - arr2[j] is smaller than or equal to d, we know that arr1[i] can&amp;rsquo;t be added to the resulting counter, so we can just break from the loop.
There is a abs function because math.Abs takes longer. When using math.</description></item><item><title>Leetcode 645</title><link>https://nathannaveen.dev/posts/leetcode-645/</link><pubDate>Tue, 02 Mar 2021 11:27:21 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-645/</guid><description>645. Set Mismatch
The idea of this solution is to add every number in the array nums to another array called temp. Next we go through the array temp and check whether the number of a certain number is equal to 2, if it is then we know that it is the repeated number. If it is not 2 but it is 0 we know that it is the skiped number.</description></item><item><title>Leetcode 4</title><link>https://nathannaveen.dev/posts/leetcode-4/</link><pubDate>Mon, 01 Mar 2021 14:20:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-4/</guid><description>4. Median of Two Sorted Arrays
The idea of this solution is pretty simple, first append all the nums2 values to nums1. Then sort nums1. If there are a even number of values then the median is the middle two numbers added together and divided by 2. An example could be:
input: nums1 = [1,2], nums2 = [3,4] expected output: 2.5
When the two arrays are combined the new array would be [1, 2, 3, 4] and the two middle numbers are 2, and 3.</description></item><item><title>Leetcode 976</title><link>https://nathannaveen.dev/posts/leetcode-976/</link><pubDate>Thu, 25 Feb 2021 13:50:15 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-976/</guid><description>976. Largest Perimeter Triangle
The idea of this solution is to sort the array and then keep on checking the largest three side lengths.
In the problem it asks us to &amp;ldquo;return the largest perimeter of a triangle with non-zero area.&amp;rdquo; Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images</description></item><item><title>Leetcode 1523</title><link>https://nathannaveen.dev/posts/leetcode-1523/</link><pubDate>Wed, 24 Feb 2021 17:03:24 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1523/</guid><description>1523. Count Odd Numbers in an Interval Range
The idea of this solution is to get the number odd numbers from 0 to high, and then subtract the number of odd numbers from 0 to low - 1. The idea can be shown by an example:
high: 7 low : 3 The odd numbers from 0 to high (7). There are 4 odd numbers from 0 to 7. The odd numbers from 0 to low - 1 (2).</description></item><item><title>Leetcode 1637</title><link>https://nathannaveen.dev/posts/leetcode-1637/</link><pubDate>Wed, 24 Feb 2021 16:52:08 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1637/</guid><description>1637. Widest Vertical Area Between Two Points Containing No Points
points = {x, y} The idea of this solution is to ignore the y part of points because the vertical area is the made of vertical lines. Vertical lines are made up off one x value for every y value. An example could be the line x = 3, this is a vertical line at the x value 3.</description></item></channel></rss>