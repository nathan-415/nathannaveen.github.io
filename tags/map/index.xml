<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>map on nathan naveen</title><link>https://nathannaveen.dev/tags/map/</link><description>Recent content in map on nathan naveen</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 28 Oct 2021 15:58:40 -0500</lastBuildDate><atom:link href="https://nathannaveen.dev/tags/map/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 1257</title><link>https://nathannaveen.dev/posts/leetcode-1257/</link><pubDate>Thu, 28 Oct 2021 15:58:40 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1257/</guid><description>1257. Smallest Common Region
A quick idea of this solution is (Note: This solution is not very good if you want a solution that is easy to understand, look after this):
To use a map to store every region as the key and the value as the region in which the original region is contained. Then loop through all the regions in the food chain of region1 (I am calling a food chain whenever we start with region1, and then find the region that contains it) and store all the values into another map.</description></item><item><title>Leetcode 1858</title><link>https://nathannaveen.dev/posts/leetcode-1858/</link><pubDate>Mon, 17 May 2021 09:50:59 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1858/</guid><description>1858. Longest Word With All Prefixes
This solution aims to sort words so we get the previous prefix of the max word before the word. An example of this could be
words = [&amp;quot;k&amp;quot;, &amp;quot;kiran&amp;quot;,&amp;quot;ki&amp;quot;,&amp;quot;kira&amp;quot;,&amp;quot;kir&amp;quot;] and when we sort, it becomes words = [&amp;quot;k&amp;quot;,&amp;quot;ki&amp;quot;,&amp;quot;kir&amp;quot;,&amp;quot;kira&amp;quot;, &amp;quot;kiran&amp;quot;].
Then we can use a map to build up the word. If the len(word) is equal to 1, we know that it is a start of a word, or if the map contains word without the last letter, we know that there is the prefix of the word.</description></item><item><title>Leetcode 720</title><link>https://nathannaveen.dev/posts/leetcode-720/</link><pubDate>Wed, 28 Apr 2021 21:30:47 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-720/</guid><description>720. Longest Word in Dictionary
The idea of this solution is pretty simple:
The code will sort words, so the minor parts we use to build the biggest words are before the built-up words. Also, since words is sorted, we don&amp;rsquo;t have to worry about the &amp;ldquo;longest word with the smallest lexicographical order&amp;rdquo;; we only have to care about the &amp;ldquo;longest word&amp;rdquo; part. After that, the code will loop through words.</description></item><item><title>Leetcode 500</title><link>https://nathannaveen.dev/posts/leetcode-500/</link><pubDate>Wed, 28 Apr 2021 21:30:43 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-500/</guid><description>500. Keyboard Row
I know that this code is not pretty, but the idea of the solution is pretty simple:
We can first make a map of letters where the top rows letters are assigned to the number 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, the middle row&amp;rsquo;s characters are assigned to the numbers 10, 11, 12, 13, 14, 15, 16, 17, 18, and the last rows characters are assigned to the numbers 19, 20, 21, 22, 23, 24, 25.</description></item><item><title>Leetcode 229</title><link>https://nathannaveen.dev/posts/leetcode-229/</link><pubDate>Sat, 17 Apr 2021 09:23:24 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-229/</guid><description>229. Majority Element II
This solution is pretty simple:
We loop through nums We add 1 to a map of integers called m, so we add 1 to m[num] where num is the current number in nums. Then we check whether m[num] == len(nums) / 3 + 1 this is checking whether the element is a majority element. Note: We can&amp;rsquo;t do m[num] &amp;gt;= len(nums) / 3 + 1. This can be shown with an example:</description></item><item><title>Leetcode 1742</title><link>https://nathannaveen.dev/posts/leetcode-1742/</link><pubDate>Sat, 10 Apr 2021 09:44:53 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1742/</guid><description>1742. Maximum Number of Balls in a Box
The idea of this solution is pretty simple:
We use a map to store all the elements and their frequencies, and we use a variable called maximum to store the maximum frequency. We loop from lowLimit to highLimit. Inside the first loop, we make a nested loop to sum up all the digits of each number between lowLimit and highLimt. After we have got the sum, we do m[sum]++ because we have to add one to the frequency of sum.</description></item><item><title>Leetcode 1426</title><link>https://nathannaveen.dev/posts/leetcode-1426/</link><pubDate>Sat, 10 Apr 2021 09:44:48 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1426/</guid><description>1426. Counting Elements
This solution is straightforward, and the idea of this solution is we add all the values of arr into a map called m. All we do is check whether m contains arr[i] + 1. If it does, we can add one to the resulting counter.
So the code:
First, makes a map called m and a variable called res. Then we loop through arr and add all the values into m.</description></item><item><title>Leetcode 1214</title><link>https://nathannaveen.dev/posts/leetcode-1214/</link><pubDate>Sun, 21 Mar 2021 11:36:17 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1214/</guid><description>1214. Two Sum BSTs
Quick Run-Down On The Solutions
The first solution is the easiest of the three solutions and the worst-time complexity solution. The second solution has a different approach from the first solution and a little better time but still not that great. The third solution has a lot better time than the first two solutions and has a similar approach to the second solution. The Ideas of These Solutions:</description></item><item><title>Leetcode 1133</title><link>https://nathannaveen.dev/posts/leetcode-1133/</link><pubDate>Thu, 18 Mar 2021 17:43:48 -0400</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1133/</guid><description>1133. Largest Unique Number
Here are two ways to solve this solution:
One way is to use an array of size 1001 which we call h (1001 because in the notes it says 0 &amp;lt;= A[i] &amp;lt;= 1000) and add one to h[A[i]]. Now we can see that the array will be sorted because we add the number of numbers to h. So all we have to do is iterate through h backward and check whether the value of h[i] == 1.</description></item><item><title>Leetcode 1461</title><link>https://nathannaveen.dev/posts/leetcode-1461/</link><pubDate>Fri, 12 Mar 2021 12:03:46 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-1461/</guid><description>1461. Check If a String Contains All Binary Codes of Size K
The idea of this solution is to make a sliding window and add all the substrings os size k to a map, if the maps length is equal to 2^k return true.
We do 2^k because we have to acount for all posibilitys of 0 and 1.
func hasAllCodes(s string, k int) bool { m := make(map[string]int) for i := 0; i &amp;lt; len(s)-k+1; i++ { m[s[i:i+k]]++ } return len(m) == twoPow(k) } func twoPow(k int) int { res := 1 for i := 0; i &amp;lt; k; i++ { res *= 2 } return res } By using bit maniplation we can simplify the code, left shifting is basicly multiplying by 2.</description></item><item><title>Leetcode 448</title><link>https://nathannaveen.dev/posts/leetcode-448/</link><pubDate>Fri, 26 Feb 2021 10:28:29 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-448/</guid><description>448. Find All Numbers Disappeared in an Array
The idea of this solution is to add all the numbers to a map and then check whether the map doesn&amp;rsquo;t contain a number. If it doesn&amp;rsquo;t contain then add it to the array arr.
We return the array from the first position to the end because when we make the array it comes out with a 0 at the zeroth index. For example a input array could be [4,3,2,7,8,2,3,1].</description></item><item><title>Leetcode 501</title><link>https://nathannaveen.dev/posts/leetcode-501/</link><pubDate>Thu, 25 Feb 2021 15:48:23 -0500</pubDate><guid>https://nathannaveen.dev/posts/leetcode-501/</guid><description>501. Find Mode in Binary Search Tree
The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.
func findMode(root *TreeNode) []int { max := 0 m := make(map[int]int) res := []int{} stack := []*TreeNode{} stack = append(stack, root) for len(stack) != 0 { pop := stack[len(stack)-1] stack = stack[:len(stack)-1] if pop !</description></item></channel></rss>